



test "create TCP listener" {
    var cnfr: Configurator = .{
        .tcp_server = TCPServerConfigurator.init(localIP, configurator.DefaultPort),
    };

    var listener = try create_listener(&cnfr);

    defer listener.deinit();
}

test "create UDS listener" {
    var cnfr: Configurator = .{
        .uds_server = UDSServerConfigurator.init(""),
    };

    var listener = try create_listener(&cnfr);

    defer listener.deinit();
}

test "create TCP client" {
    var pool = try Pool.init(gpa, null);
    defer pool.close();

    var cnfr: Configurator = .{
        .tcp_server = TCPServerConfigurator.init(localIP, configurator.DefaultPort),
    };

    var listener = try create_listener(&cnfr);

    defer listener.deinit();

    var clcnfr: Configurator = .{
        .tcp_client = TCPClientConfigurator.init(null, null),
    };

    var client = try create_client(&clcnfr, &pool);

    defer client.deinit();
}

test "create UDS client" {
    var pool = try Pool.init(gpa, null);
    defer pool.close();

    var tup: Notifier.TempUdsPath = .{};
    const udsPath = try tup.buildPath(gpa);

    var cnfr: Configurator = .{
        .uds_server = UDSServerConfigurator.init(udsPath),
    };

    var listener = try create_listener(&cnfr);

    defer listener.deinit();

     const c_array_ptr: [*:0]const u8 = @ptrCast(&listener.accept.skt.address.un.path);
     const length = std.mem.len(c_array_ptr);
     const zig_slice: []const u8 = c_array_ptr[0..length];

    var clcnfr: Configurator = .{
        .uds_client = UDSClientConfigurator.init(udsPath),
    };

    var client = try create_client(&clcnfr, &pool);

    defer client.deinit();
}




     tardy: poll.zig - slightly changed
    if (comptime builtin.os.tag == .macos) {  was false
        const server_socket = try std.posix.socket(std.posix.AF.INET, std.posix.SOCK.STREAM, 0);
        defer std.posix.close(server_socket);

        const addr = std.net.Address.initIp4(.{ 127, 0, 0, 1 }, 0);
        try std.posix.bind(server_socket, &addr.any, addr.getOsSockLen());

        var binded_addr: std.posix.sockaddr = undefined;
        var binded_size: std.posix.socklen_t = @sizeOf(std.posix.sockaddr);
        try std.posix.getsockname(server_socket, &binded_addr, &binded_size);

        try std.posix.listen(server_socket, 1);

        const write_end = try std.posix.socket(std.posix.AF.INET, std.posix.SOCK.STREAM | posix.SOCK.NONBLOCK, 0);
        errdefer std.posix.close(write_end);

        _ = try waitConnect(write_end);

        try std.posix.connect(write_end, &binded_addr, binded_size);

        const read_end = try std.posix.accept(server_socket, null, null, std.posix.SOCK.NONBLOCK);
        errdefer std.posix.close(read_end);

        return .{
            .sender = write_end,
            .receiver = read_end,
        };
    }


 Grok generated from former waitConnect
 Define kqueue constants for macOS
pub fn waitConnect(client: posix.socket_t) !bool {
    log.debug("TRY WAITCONNECT ON FD {x}", .{client});
    defer log.debug("FINISH WAITCONNECT ON FD {x}", .{client});
    if (comptime false) {  grok version below
         Compile-time OS detection
        switch (builtin.os.tag) {
            .linux => {
                 Linux implementation using poll
                var spoll: [1]posix.pollfd = .{
                    .{
                        .fd = client,
                        .events = posix.POLL.OUT,
                        .revents = 0,
                    },
                };

                const timeout_ms = 3000;  Assuming SEC_TIMEOUT_MS is 1000
                const pollstatus = try posix.poll(&spoll, timeout_ms);

                if (pollstatus == 0) {
                    return false;
                }

                if (spoll[0].revents & posix.POLL.HUP != 0) {
                    return false;
                }

                return true;
            },
            .macos => {
                 macOS implementation using kqueue
                const kq = try posix.kqueue();
                defer posix.close(kq);

                var changelist: [1]posix.Kevent = .{
                    .{
                        .ident = @intCast(client),
                        .filter = KqueueConstants.EVFILT_WRITE,
                        .flags = KqueueConstants.EV_ADD | KqueueConstants.EV_ONESHOT,
                        .fflags = 0,
                        .data = 0,
                        .udata = 0,
                    },
                };

                const timeout_ms = 3000;  Assuming SEC_TIMEOUT_MS is 1000
                var timeout = posix.timespec{
                    .sec = timeout_ms / 1000,
                    .nsec = (timeout_ms % 1000) * 1_000_000,
                };

                var eventlist: [1]posix.Kevent = undefined;
                const nevents = try posix.kevent(kq, &changelist, &eventlist, &timeout);

                if (nevents == 0) {
                    return false;
                }

                if (eventlist[0].flags & KqueueConstants.EV_ERROR != 0 or
                    eventlist[0].flags & KqueueConstants.EV_EOF != 0)
                {
                    return false;
                }

                return true;
            },
            else => @compileError("Unsupported OS: waitConnect is only implemented for Linux (poll) and macOS (kqueue)."),
        }
    } else { chatgpt version
        if (builtin.os.tag == .linux) {
            return waitConnectLinux(client);
        } else if (builtin.os.tag == .macos) {
            return waitConnectMacos(client);
        } else {
            @compileError("waitConnect is only implemented for Linux and macOS.");
        }
    }
}

fn waitConnectLinux(client: posix.socket_t) !bool {
    var spoll: [1]posix.pollfd = undefined;

    while (true) {
        spoll = .{
            .{
                .fd = client,
                .events = posix.POLL.OUT,
                .revents = 0,
            },
        };

        const pollstatus = try posix.poll(&spoll, SEC_TIMEOUT_MS * 3);

        if (pollstatus == 1) {
            break;
        }
    }

    if (spoll[0].revents & posix.POLL.HUP != 0) {
        return false;
    }

    return true;
}

fn waitConnectMacos(client: posix.socket_t) !bool {
    const kq = try posix.kqueue();
    defer posix.close(kq);

    const change: posix.Kevent = .{
        .ident = @intCast(client),
        .filter = KqueueConstants.EVFILT_WRITE,
        .flags = KqueueConstants.EV_ADD,
        .fflags = 0,
        .data = 0,
        .udata = 0,
    };

    _ = try posix.kevent(kq, &.{change}, &.{}, null);

    var ts: posix.timespec = .{
        .sec = SEC_TIMEOUT_MS * 3 / 1000,
        .nsec = (SEC_TIMEOUT_MS * 3 % 1000) * 1_000_000,
    };

    var ev: [1]posix.Kevent = undefined;

    while (true) {
        const n = try posix.kevent(kq, &.{}, &ev, &ts);
        if (n == 0) {
            continue;
        }
        if (n == 1) {
            break;
        }
    }

    if ((ev[0].flags & KqueueConstants.EV_ERROR) != 0 or
        (ev[0].flags & KqueueConstants.EV_EOF) != 0)
    {
        return false;
    }

    return true;
}

const KqueueConstants = if (builtin.os.tag == .macos) struct {
    const EVFILT_WRITE: i16 = -2;  From sys/event.h
    const EV_ADD: u16 = 0x0001;
    const EV_ONESHOT: u16 = 0x0010;
    const EV_ERROR: u16 = 0x4000;
    const EV_EOF: u16 = 0x8000;
} else struct {};


language: "en-US"

reviews:
  profile: "chill"
  high_level_summary: true

auto_review:
  enabled: true
  drafts: false

path_filters:
  - "src/**/*.zig"
  - "build.zig"
  - "!zig-cache/**"
  - "!zig-out/**"

tools:
  gitleaks:
    enabled: true




 const ErrorToStatusMap = std.enums.EnumMap(AmpeError, AmpeStatus).init(.{
     .NotImplementedYet = .not_implemented_yet,
     .WrongConfiguration = .wrong_configuration,
     .NotAllowed = .not_allowed,
     .NullMessage = .null_message,
     .InvalidMessage = .invalid_message,
     .InvalidMessageType = .invalid_message_type,
     .InvalidMessageMode = .invalid_message_mode,
     .InvalidHeadersLen = .invalid_headers_len,
     .InvalidBodyLen = .invalid_body_len,
     .InvalieChannelNumber = .invalid_channel_number,
     .InvalieMessageId = .invalid_message_id,
     .InvalidAddress = .invalid_address,
     .InvalidMoreUsage = .invalid_more_usage,
     .NotificationDisabled = .notification_disabled,
     .NotificationFailed = .notification_failed,
     .PeerDisconnected = .peer_disconnected,
     .CommunicationFailed = .communication_failed,
     .PoolEmpty = .pool_empty,
     .AllocationFailed = .allocation_failed,
     .WaitInterrupted = .wait_interrupted,
     .ChannelClosed = .channel_closed,
     .ShutdownStarted = .shutdown_started,
 });


pub fn markForDelete(dtr: *Distributor, chn: message.ChannelNumber) !void {
    const trchn = dtr.trgrd_map.getPtr(chn);
    if (trchn) |ch| {
        ch.mrk4del = true;
    }
    return;
}


pub fn addDumbChannel(dtr: *Distributor, chN: channels.ChannelNumber) !void {
     var dcn = TriggeredChannel.createDumbChannel(dtr);

     dcn.acn = dtr.*.acns.activeChannel(dtr.currBhdr.channel_number) catch unreachable;

     try dtr.addChannel(dcn);

     return;
}

pub fn addIoClientChannel(dtr: *Distributor, chN: channels.ChannelNumber) !void {
     var cnfgr: Configurator = Configurator.fromMessage(dtr.currMsg.?);

     if (cnfgr.isWrong()) {
         return AmpeError.WrongConfiguration;
     }

     var dcn = TriggeredChannel.createDumbChannel(dtr);

     dcn.acn = dtr.*.acns.activeChannel(dtr.currBhdr.channel_number) catch unreachable;

     dtr.trgrd_map.put(chN, dcn) catch {
         return AmpeError.AllocationFailed;
     };

     return;
}


    const TofuClient = struct {
        const Self = @This();
        gpa: Allocator = undefined,
        ampe: Ampe = undefined,
        cfg: *Configurator = undefined,
        result: anyerror!status.AmpeStatus = undefined,

        fn runOnThread(tfcl: *Self) void {
            log.debug("---> On client thread", .{});
            defer log.debug("<--- On client thread", .{});
            _ = tfcl;
            return;
        }
    };

    var clnt: TofuClient = .{};

    const TofuServer = struct {
        const Self = @This();
        gpa: Allocator = undefined,
        ampe: Ampe = undefined,
        cfg: *Configurator = undefined,
        result: anyerror!status.AmpeStatus = undefined,

        fn runOnThread(tfsrv: *Self) void {
            log.debug("---> On server thread", .{});
            defer log.debug("<--- On server thread", .{});
            _ = tfsrv;
            return;
        }
    };
    var srvr: TofuServer = .{};

    {
        const clntThread: std.Thread =
            try std.Thread.spawn(.{}, TofuClient.runOnThread, .{&clnt});
        defer clntThread.join();

        const srvrThread: std.Thread =
            try std.Thread.spawn(.{}, TofuServer.runOnThread, .{&srvr});
        defer srvrThread.join();
    }




pub const Library = struct {
    gpa: Allocator = undefined,

    pub fn Create(gpa: Allocator) !*Library {
        const ret = try gpa.alloc(Library);
        ret.gpa = gpa;
        return ret;
    }

    pub fn giveAllocator(lib: *Library) Allocator {
        return lib.gpa;
    }

    pub fn asyncSend(lib: *Library, buf: []const u8) void {
        ......................................
    }
};

pub const Client = struct {
    lib: *Library = undefined,

    pub fn Create(lib: *Library) !*Client {
        const ret = try lib.giveAllocator();
        ret.lib = lib;
        return ret;
    }

    pub fn process(cln: *Client) void {
        .....................................
        const blob: []const u8 = try cln.lib.giveAllocator().alloc(u8, 1024);
        cln.lib.asyncSend(blob);
        .....................................
    }
};

fn codeExample() !void {
    var lib: *Library = try Library.Create(std.testing.allocator);

    ........................
    .........................

    var client: *Client = try Client.Create(lib);

    .........................
    .........................

    client.process();

}

    ==================================================
    User: Zig how add to build clean up of zig cache?
    ==================================================

Assistant: To add a build step that cleans up the Zig cache, you can define a custom step in your build.zig file. The step should use std.fs.deleteTree to recursively remove the .zig-cache directory.
Example: Add a clean step to build.zig
Here is a typical build.zig file with a clean step that depends on a separate clean-cache step. This avoids a "FileBusy" error on Windows because the build runner won't try to delete itself while it's running.
build.zig
zig

const std = @import("std");

pub fn build(b: *std.Build) void {
    // Other build steps...
    // Example: building an executable
    const exe = b.addExecutable(.{
        .name = "my_project",
        .root_source_file = b.path("src/main.zig"),
        .target = b.standardTargetOptions(.{}),
        .optimize = b.standardOptimizeOption(.{}),
    });
    b.installArtifact(exe);
    const run_step = b.addRunArtifact(exe);
    b.step("run", "Run the app").dependOn(&run_step.step);

    // --- Clean Steps ---

    // Clean step for the install directory (zig-out)
    const clean_out_step = b.addRemoveDirTree(.{
        .step_name = "clean-out",
        .dir = b.install_dir,
    });
    b.step("clean-out", "Removes the `zig-out` installation directory.").dependOn(&clean_out_step.step);

    // Get the path to the local cache directory
    const cache_path = b.getCacheRoot().path.?.toOwnedAllocator(b.allocator) catch unreachable;

    // Clean step for the local cache directory (.zig-cache)
    const clean_cache_step = b.addRemoveDirTree(.{
        .step_name = "clean-cache",
        .dir = &cache_path,
    });
    b.step("clean-cache", "Removes the `.zig-cache` directory.").dependOn(&clean_cache_step.step);

    // Unified clean step that depends on both
    const clean_step = b.step("clean", "Removes both build artifacts and cache.");
    clean_step.dependOn(&clean_out_step.step);
    clean_step.dependOn(&clean_cache_step.step);
}

Use code with caution.
How to use the new steps

    Add the code to your build.zig file: Copy and paste the provided code into your project's build.zig. You can place it anywhere inside the pub fn build function, but grouping the clean steps at the end is a good practice.
    Clean the cache and build artifacts: From your terminal, run the new clean step.
    bash

    zig build clean

    Use code with caution.

Clean only the build artifacts (zig-out):
bash

zig build clean-out

Use code with caution.
Clean only the project cache (.zig-cache):
bash

zig build clean-cache

Use code with caution.


Why this approach works best

    Avoids "FileBusy" errors: On operating systems like Windows, you cannot delete a directory that contains an executable that is currently running. The zig build command runs an executable from the .zig-cache directory. By separating the cleanup of .zig-cache into a distinct step, you can run zig build clean-cache as a standalone command.
    Clear and separate steps: Having dedicated clean-out and clean-cache steps, plus a unified clean step, makes your build system's intent clear and provides flexibility.
    Discoverable via --help: The step name and description will appear when you run zig build --help, making the command easy for other developers to find and use.
    User: How to run cleanup steam automatically before test step?
    Assistant: To make a cleanup step run automatically before your tests, you need to establish a dependency in your build.zig file. The build system is based on a directed acyclic graph (DAG), where a step can depend on one or more other steps. By making your test step dependent on a clean-cache step, you ensure the cache is cleared every time you run zig build test.

Example build.zig with clean-cache dependency
Modify your build.zig file to define a clean-cache step and then make the test step depend on it.
build.zig
zig

const std = @import("std");

pub fn build(b: *std.Build) void {
    // Standard release options for your project
    const mode = b.standardReleaseOptions();

    // The test executable for your source file
    const tests = b.addTest(.{
        .root_source_file = b.path("src/main.zig"),
        .target = b.standardTargetOptions(.{}),
        .optimize = mode,
    });

    // Step to actually run the tests
    const test_step = b.step("test", "Run the library tests");
    test_step.dependOn(&tests.step);

    // --- Cleanup Steps ---

    // Define a step to remove the local `.zig-cache` directory
    // NOTE: This cannot be called by itself from `zig build` as it will cause a "FileBusy" error
    // because the build runner is inside the directory it's trying to delete.
    // It must be run as a dependency of another step.
    const cache_path = b.getCacheRoot().path.?.toOwnedAllocator(b.allocator) catch unreachable;
    const clean_cache_step = b.addRemoveDirTree(.{
        .dir = &cache_path,
        .step_name = "clean-cache-run-before-test",
    });

    // --- Add the dependency ---

    // Ensure the clean-cache step runs BEFORE the test step.
    // When you run `zig build test`, the build system will resolve the `test_step`'s dependencies first.
    tests.step.dependOn(&clean_cache_step.step);

    // --- Other project steps (e.g., executable) ---

    // Optional: add a top-level `clean-cache` step that can be run on its own
    // This allows you to manually run `zig build clean-cache` without running tests.
    // It must be named differently than the dependency step above.
    const clean_manual_step = b.step("clean-cache", "Manually remove the .zig-cache directory.");
    clean_manual_step.dependOn(&clean_cache_step.step);
}

Use code with caution.
How to use

    Run tests with automatic cleanup: Now, every time you execute the test step, the clean-cache-run-before-test step will be automatically invoked first.
    sh

    zig build test

    Use code with caution.

Manually clean the cache: For those times you want to clear the cache without running tests, you can use the separate manual step.
sh

zig build clean-cache

Use code with caution.

Important considerations

    FileBusy error: You cannot define a top-level step named clean-cache that also cleans the cache directly before tests. The build process itself runs from within the .zig-cache directory. Trying to delete this directory while a process inside it is running will fail on Windows and sometimes on other platforms. The solution is to:
        Create the addRemoveDirTree step.
        Make your test step depend on it.
        Call zig build test. The build runner will clean the cache and then exit, and the test step will be run in a new process.
    Dependency graph: The Zig build system handles dependencies by creating a DAG. In this example, the tests.step (the test compilation step) is made dependent on the clean_cache_step. The test_step (the test execution step) is dependent on the tests.step, so the sequence is: cleanup, then compile tests, then run tests.
    User: Create file with context of this session, ready for downloading
    Assistant: To create a downloadable file containing the context of this session, you can use a small JavaScript snippet that runs in your browser's developer console. This method captures the conversation and formats it as a text file for you to save.

User: Zig how add to build clean up of zig cache?
Assistant: To add a build step that cleans up the Zig cache, you can define a custom step in your build.zig file. The step should use std.fs.deleteTree to recursively remove the .zig-cache directory.
Example: Add a clean step to build.zig
Here is a typical build.zig file with a clean step that depends on a separate clean-cache step. This avoids a "FileBusy" error on Windows because the build runner won't try to delete itself while it's running.
build.zig
zig

const std = @import("std");

pub fn build(b: *std.Build) void {
    // Other build steps...
    // Example: building an executable
    const exe = b.addExecutable(.{
        .name = "my_project",
        .root_source_file = b.path("src/main.zig"),
        .target = b.standardTargetOptions(.{}),
        .optimize = b.standardOptimizeOption(.{}),
    });
    b.installArtifact(exe);
    const run_step = b.addRunArtifact(exe);
    b.step("run", "Run the app").dependOn(&run_step.step);

    // --- Clean Steps ---

    // Clean step for the install directory (zig-out)
    const clean_out_step = b.addRemoveDirTree(.{
        .step_name = "clean-out",
        .dir = b.install_dir,
    });
    b.step("clean-out", "Removes the `zig-out` installation directory.").dependOn(&clean_out_step.step);

    // Get the path to the local cache directory
    const cache_path = b.getCacheRoot().path.?.toOwnedAllocator(b.allocator) catch unreachable;

    // Clean step for the local cache directory (.zig-cache)
    const clean_cache_step = b.addRemoveDirTree(.{
        .step_name = "clean-cache",
        .dir = &cache_path,
    });
    b.step("clean-cache", "Removes the `.zig-cache` directory.").dependOn(&clean_cache_step.step);

    // Unified clean step that depends on both
    const clean_step = b.step("clean", "Removes both build artifacts and cache.");
    clean_step.dependOn(&clean_out_step.step);
    clean_step.dependOn(&clean_cache_step.step);
}

Use code with caution.
How to use the new steps

    Add the code to your build.zig file: Copy and paste the provided code into your project's build.zig. You can place it anywhere inside the pub fn build function, but grouping the clean steps at the end is a good practice.
    Clean the cache and build artifacts: From your terminal, run the new clean step.
    bash

    zig build clean

    Use code with caution.

Clean only the build artifacts (zig-out):
bash

zig build clean-out

Use code with caution.
Clean only the project cache (.zig-cache):
bash

zig build clean-cache

Use code with caution.


Why this approach works best

    Avoids "FileBusy" errors: On operating systems like Windows, you cannot delete a directory that contains an executable that is currently running. The zig build command runs an executable from the .zig-cache directory. By separating the cleanup of .zig-cache into a distinct step, you can run zig build clean-cache as a standalone command.
    Clear and separate steps: Having dedicated clean-out and clean-cache steps, plus a unified clean step, makes your build system's intent clear and provides flexibility.
    Discoverable via --help: The step name and description will appear when you run zig build --help, making the command easy for other developers to find and use.
    User: How to run cleanup steam automatically before test step?
    Assistant: To make a cleanup step run automatically before your tests, you need to establish a dependency in your build.zig file. The build system is based on a directed acyclic graph (DAG), where a step can depend on one or more other steps. By making your test step dependent on a clean-cache step, you ensure the cache is cleared every time you run zig build test.

Example build.zig with clean-cache dependency
Modify your build.zig file to define a clean-cache step and then make the test step depend on it.
build.zig
zig

const std = @import("std");

pub fn build(b: *std.Build) void {
    // Standard release options for your project
    const mode = b.standardReleaseOptions();

    // The test executable for your source file
    const tests = b.addTest(.{
        .root_source_file = b.path("src/main.zig"),
        .target = b.standardTargetOptions(.{}),
        .optimize = mode,
    });

    // Step to actually run the tests
    const test_step = b.step("test", "Run the library tests");
    test_step.dependOn(&tests.step);

    // --- Cleanup Steps ---

    // Define a step to remove the local `.zig-cache` directory
    // NOTE: This cannot be called by itself from `zig build` as it will cause a "FileBusy" error
    // because the build runner is inside the directory it's trying to delete.
    // It must be run as a dependency of another step.
    const cache_path = b.getCacheRoot().path.?.toOwnedAllocator(b.allocator) catch unreachable;
    const clean_cache_step = b.addRemoveDirTree(.{
        .dir = &cache_path,
        .step_name = "clean-cache-run-before-test",
    });

    // --- Add the dependency ---

    // Ensure the clean-cache step runs BEFORE the test step.
    // When you run `zig build test`, the build system will resolve the `test_step`'s dependencies first.
    tests.step.dependOn(&clean_cache_step.step);

    // --- Other project steps (e.g., executable) ---

    // Optional: add a top-level `clean-cache` step that can be run on its own
    // This allows you to manually run `zig build clean-cache` without running tests.
    // It must be named differently than the dependency step above.
    const clean_manual_step = b.step("clean-cache", "Manually remove the .zig-cache directory.");
    clean_manual_step.dependOn(&clean_cache_step.step);
}

Use code with caution.
How to use

    Run tests with automatic cleanup: Now, every time you execute the test step, the clean-cache-run-before-test step will be automatically invoked first.
    sh

    zig build test

    Use code with caution.

Manually clean the cache: For those times you want to clear the cache without running tests, you can use the separate manual step.
sh

zig build clean-cache

Use code with caution.

Important considerations

    FileBusy error: You cannot define a top-level step named clean-cache that also cleans the cache directly before tests. The build process itself runs from within the .zig-cache directory. Trying to delete this directory while a process inside it is running will fail on Windows and sometimes on other platforms. The solution is to:
        Create the addRemoveDirTree step.
        Make your test step depend on it.
        Call zig build test. The build runner will clean the cache and then exit, and the test step will be run in a new process.
    Dependency graph: The Zig build system handles dependencies by creating a DAG. In this example, the tests.step (the test compilation step) is made dependent on the clean_cache_step. The test_step (the test execution step) is dependent on the tests.step, so the sequence is: cleanup, then compile tests, then run tests.
    User: Create file with context of this session, ready for downloading
    Assistant: To create a downloadable file containing the context of this session, you can use a small JavaScript snippet that runs in your browser's developer console. This method captures the conversation and formats it as a text file for you to save.


User: Zig how add to build clean up of zig cache?
Assistant: To add a build step that cleans up the Zig cache, you can define a custom step in your build.zig file. The step should use std.fs.deleteTree to recursively remove the .zig-cache directory.
Example: Add a clean step to build.zig
Here is a typical build.zig file with a clean step that depends on a separate clean-cache step. This avoids a "FileBusy" error on Windows because the build runner won't try to delete itself while it's running.
build.zig
zig

const std = @import("std");

pub fn build(b: *std.Build) void {
    // Other build steps...
    // Example: building an executable
    const exe = b.addExecutable(.{
        .name = "my_project",
        .root_source_file = b.path("src/main.zig"),
        .target = b.standardTargetOptions(.{}),
        .optimize = b.standardOptimizeOption(.{}),
    });
    b.installArtifact(exe);
    const run_step = b.addRunArtifact(exe);
    b.step("run", "Run the app").dependOn(&run_step.step);

    // --- Clean Steps ---

    // Clean step for the install directory (zig-out)
    const clean_out_step = b.addRemoveDirTree(.{
        .step_name = "clean-out",
        .dir = b.install_dir,
    });
    b.step("clean-out", "Removes the `zig-out` installation directory.").dependOn(&clean_out_step.step);

    // Get the path to the local cache directory
    const cache_path = b.getCacheRoot().path.?.toOwnedAllocator(b.allocator) catch unreachable;

    // Clean step for the local cache directory (.zig-cache)
    const clean_cache_step = b.addRemoveDirTree(.{
        .step_name = "clean-cache",
        .dir = &cache_path,
    });
    b.step("clean-cache", "Removes the `.zig-cache` directory.").dependOn(&clean_cache_step.step);

    // Unified clean step that depends on both
    const clean_step = b.step("clean", "Removes both build artifacts and cache.");
    clean_step.dependOn(&clean_out_step.step);
    clean_step.dependOn(&clean_cache_step.step);
}

Use code with caution.
How to use the new steps

    Add the code to your build.zig file: Copy and paste the provided code into your project's build.zig. You can place it anywhere inside the pub fn build function, but grouping the clean steps at the end is a good practice.
    Clean the cache and build artifacts: From your terminal, run the new clean step.
    bash

    zig build clean

    Use code with caution.

Clean only the build artifacts (zig-out):
bash

zig build clean-out

Use code with caution.
Clean only the project cache (.zig-cache):
bash

zig build clean-cache

Use code with caution.


Why this approach works best

    Avoids "FileBusy" errors: On operating systems like Windows, you cannot delete a directory that contains an executable that is currently running. The zig build command runs an executable from the .zig-cache directory. By separating the cleanup of .zig-cache into a distinct step, you can run zig build clean-cache as a standalone command.
    Clear and separate steps: Having dedicated clean-out and clean-cache steps, plus a unified clean step, makes your build system's intent clear and provides flexibility.
    Discoverable via --help: The step name and description will appear when you run zig build --help, making the command easy for other developers to find and use.
    User: How to run cleanup steam automatically before test step?
    Assistant: To make a cleanup step run automatically before your tests, you need to establish a dependency in your build.zig file. The build system is based on a directed acyclic graph (DAG), where a step can depend on one or more other steps. By making your test step dependent on a clean-cache step, you ensure the cache is cleared every time you run zig build test.

Example build.zig with clean-cache dependency
Modify your build.zig file to define a clean-cache step and then make the test step depend on it.
build.zig
zig

const std = @import("std");

pub fn build(b: *std.Build) void {
    // Standard release options for your project
    const mode = b.standardReleaseOptions();

    // The test executable for your source file
    const tests = b.addTest(.{
        .root_source_file = b.path("src/main.zig"),
        .target = b.standardTargetOptions(.{}),
        .optimize = mode,
    });

    // Step to actually run the tests
    const test_step = b.step("test", "Run the library tests");
    test_step.dependOn(&tests.step);

    // --- Cleanup Steps ---

    // Define a step to remove the local `.zig-cache` directory
    // NOTE: This cannot be called by itself from `zig build` as it will cause a "FileBusy" error
    // because the build runner is inside the directory it's trying to delete.
    // It must be run as a dependency of another step.
    const cache_path = b.getCacheRoot().path.?.toOwnedAllocator(b.allocator) catch unreachable;
    const clean_cache_step = b.addRemoveDirTree(.{
        .dir = &cache_path,
        .step_name = "clean-cache-run-before-test",
    });

    // --- Add the dependency ---

    // Ensure the clean-cache step runs BEFORE the test step.
    // When you run `zig build test`, the build system will resolve the `test_step`'s dependencies first.
    tests.step.dependOn(&clean_cache_step.step);

    // --- Other project steps (e.g., executable) ---

    // Optional: add a top-level `clean-cache` step that can be run on its own
    // This allows you to manually run `zig build clean-cache` without running tests.
    // It must be named differently than the dependency step above.
    const clean_manual_step = b.step("clean-cache", "Manually remove the .zig-cache directory.");
    clean_manual_step.dependOn(&clean_cache_step.step);
}

Use code with caution.
How to use

    Run tests with automatic cleanup: Now, every time you execute the test step, the clean-cache-run-before-test step will be automatically invoked first.
    sh

    zig build test

    Use code with caution.

Manually clean the cache: For those times you want to clear the cache without running tests, you can use the separate manual step.
sh

zig build clean-cache

Use code with caution.



// -----------------------------------------------------------------------------
// TESTS
// -----------------------------------------------------------------------------

test "valueToSlice - success (u32)" {
    var dest = [_]u8{0} ** 8;
    const value: u32 = 0x12345678;
    const expected_size = @sizeOf(u32);

    const filled_slice = valueToSlice(u32, value, dest[0..]);
    try std.testing.expectEqual(expected_size, filled_slice.len);

    // Check content based on native endianness
    if (std.builtin.target.cpu.arch.endian() == .little) {
        // Little-endian: Least significant byte first (78)
        try std.testing.expectEqual(@as(u8, 0x78), filled_slice[0]);
        try std.testing.expectEqual(@as(u8, 0x12), filled_slice[3]);
    } else {
        // Big-endian: Most significant byte first (12)
        try std.testing.expectEqual(@as(u8, 0x12), filled_slice[0]);
        try std.testing.expectEqual(@as(u8, 0x78), filled_slice[3]);
    }
}

test "valueToSlice - destination too small" {
    var dest = [_]u8{0} ** 3; // Needs 4 bytes for u32
    const value: u32 = 0x12345678;
    const filled_slice = valueToSlice(u32, value, dest[0..]);
    try std.testing.expectEqual(@as(usize, 0), filled_slice.len);
}

test "sliceToValue - success (i64)" {
    // A slice representing the i64 value 0x0102030405060708
    const bytes_le = [_]u8{ 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01 };
    const bytes_be = [_]u8{ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };

    const slice_to_test = if (std.builtin.target.cpu.arch.endian() == .little) bytes_le[0..] else bytes_be[0..];
    const expected_value: i64 = 0x0102030405060708;

    const value = try sliceToValue(i64, slice_to_test);
    try std.testing.expectEqual(expected_value, value);
}

test "sliceToValue - slice too small" {
    const bytes = [_]u8{ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 }; // Needs 8 bytes for i64
    const err = sliceToValue(i64, bytes[0..]);
    try std.testing.expectEqual(err, error.SliceTooSmall);
}

test "roundtrip conversion (f32)" {
    var dest = [_]u8{0} ** 8;
    const original_value: f32 = 3.14159;
    const expected_size = @sizeOf(f32);

    // Value to Slice
    const filled_slice = valueToSlice(f32, original_value, dest[0..]);
    try std.testing.expectEqual(expected_size, filled_slice.len);

    // Slice to Value
    const decoded_value = try sliceToValue(f32, filled_slice);

    // Due to the nature of floating point, comparing equality is fine for an exact byte-for-byte round trip.
    try std.testing.expectEqual(original_value, decoded_value);
}

test "valueToSlice - pointer - sliceToValue" {
    const T = *const u32;
    var dest = [_]u8{0} ** @sizeOf(T);
    var x: u32 = 42;
    const ptr: T = &x;

    const vsl = valueToSlice(T, ptr, dest[0..]);

    const ptr2 = try sliceToValue(T, vsl);

    try std.testing.expectEqual(ptr, ptr2);
}


// inline fn isFirstServerRequest(msg: *Message) bool {
//     if (msg.bhdr.proto.mtype != .welcome) {
//         return false;
//     }
//     if (msg.bhdr.proto.role != .request) {
//         return false;
//     }
//     if (msg.bhdr.proto.more != .last) {
//         return false;
//     }
//     if (msg.bhdr.proto.origin != .application) {
//         return false;
//     }
//
//     return true;
// }
//
// inline fn isFirstClientRequest(msg: *Message) bool {
//     if (msg.bhdr.proto.mtype != .hello) {
//         return false;
//     }
//     if (msg.bhdr.proto.role != .request) {
//         return false;
//     }
//     if (msg.bhdr.proto.more != .last) {
//         return false;
//     }
//     if (msg.bhdr.proto.origin != .application) {
//         return false;
//     }
//
//     return true;
// }
