



test "create TCP listener" {
    var cnfr: Configurator = .{
        .tcp_server = TCPServerConfigurator.init(localIP, configurator.DefaultPort),
    };

    var listener = try create_listener(&cnfr);

    defer listener.deinit();
}

test "create UDS listener" {
    var cnfr: Configurator = .{
        .uds_server = UDSServerConfigurator.init(""),
    };

    var listener = try create_listener(&cnfr);

    defer listener.deinit();
}

test "create TCP client" {
    var pool = try Pool.init(gpa, null);
    defer pool.close();

    var cnfr: Configurator = .{
        .tcp_server = TCPServerConfigurator.init(localIP, configurator.DefaultPort),
    };

    var listener = try create_listener(&cnfr);

    defer listener.deinit();

    var clcnfr: Configurator = .{
        .tcp_client = TCPClientConfigurator.init(null, null),
    };

    var client = try create_client(&clcnfr, &pool);

    defer client.deinit();
}

test "create UDS client" {
    var pool = try Pool.init(gpa, null);
    defer pool.close();

    var tup: Notifier.TempUdsPath = .{};
    const udsPath = try tup.buildPath(gpa);

    var cnfr: Configurator = .{
        .uds_server = UDSServerConfigurator.init(udsPath),
    };

    var listener = try create_listener(&cnfr);

    defer listener.deinit();

     const c_array_ptr: [*:0]const u8 = @ptrCast(&listener.accept.skt.address.un.path);
     const length = std.mem.len(c_array_ptr);
     const zig_slice: []const u8 = c_array_ptr[0..length];

    var clcnfr: Configurator = .{
        .uds_client = UDSClientConfigurator.init(udsPath),
    };

    var client = try create_client(&clcnfr, &pool);

    defer client.deinit();
}




     tardy: poll.zig - slightly changed
    if (comptime builtin.os.tag == .macos) {  was false
        const server_socket = try std.posix.socket(std.posix.AF.INET, std.posix.SOCK.STREAM, 0);
        defer std.posix.close(server_socket);

        const addr = std.net.Address.initIp4(.{ 127, 0, 0, 1 }, 0);
        try std.posix.bind(server_socket, &addr.any, addr.getOsSockLen());

        var binded_addr: std.posix.sockaddr = undefined;
        var binded_size: std.posix.socklen_t = @sizeOf(std.posix.sockaddr);
        try std.posix.getsockname(server_socket, &binded_addr, &binded_size);

        try std.posix.listen(server_socket, 1);

        const write_end = try std.posix.socket(std.posix.AF.INET, std.posix.SOCK.STREAM | posix.SOCK.NONBLOCK, 0);
        errdefer std.posix.close(write_end);

        _ = try waitConnect(write_end);

        try std.posix.connect(write_end, &binded_addr, binded_size);

        const read_end = try std.posix.accept(server_socket, null, null, std.posix.SOCK.NONBLOCK);
        errdefer std.posix.close(read_end);

        return .{
            .sender = write_end,
            .receiver = read_end,
        };
    }


 Grok generated from former waitConnect
 Define kqueue constants for macOS
pub fn waitConnect(client: posix.socket_t) !bool {
    log.debug("TRY WAITCONNECT ON FD {x}", .{client});
    defer log.debug("FINISH WAITCONNECT ON FD {x}", .{client});
    if (comptime false) {  grok version below
         Compile-time OS detection
        switch (builtin.os.tag) {
            .linux => {
                 Linux implementation using poll
                var spoll: [1]posix.pollfd = .{
                    .{
                        .fd = client,
                        .events = posix.POLL.OUT,
                        .revents = 0,
                    },
                };

                const timeout_ms = 3000;  Assuming SEC_TIMEOUT_MS is 1000
                const pollstatus = try posix.poll(&spoll, timeout_ms);

                if (pollstatus == 0) {
                    return false;
                }

                if (spoll[0].revents & posix.POLL.HUP != 0) {
                    return false;
                }

                return true;
            },
            .macos => {
                 macOS implementation using kqueue
                const kq = try posix.kqueue();
                defer posix.close(kq);

                var changelist: [1]posix.Kevent = .{
                    .{
                        .ident = @intCast(client),
                        .filter = KqueueConstants.EVFILT_WRITE,
                        .flags = KqueueConstants.EV_ADD | KqueueConstants.EV_ONESHOT,
                        .fflags = 0,
                        .data = 0,
                        .udata = 0,
                    },
                };

                const timeout_ms = 3000;  Assuming SEC_TIMEOUT_MS is 1000
                var timeout = posix.timespec{
                    .sec = timeout_ms / 1000,
                    .nsec = (timeout_ms % 1000) * 1_000_000,
                };

                var eventlist: [1]posix.Kevent = undefined;
                const nevents = try posix.kevent(kq, &changelist, &eventlist, &timeout);

                if (nevents == 0) {
                    return false;
                }

                if (eventlist[0].flags & KqueueConstants.EV_ERROR != 0 or
                    eventlist[0].flags & KqueueConstants.EV_EOF != 0)
                {
                    return false;
                }

                return true;
            },
            else => @compileError("Unsupported OS: waitConnect is only implemented for Linux (poll) and macOS (kqueue)."),
        }
    } else { chatgpt version
        if (builtin.os.tag == .linux) {
            return waitConnectLinux(client);
        } else if (builtin.os.tag == .macos) {
            return waitConnectMacos(client);
        } else {
            @compileError("waitConnect is only implemented for Linux and macOS.");
        }
    }
}

fn waitConnectLinux(client: posix.socket_t) !bool {
    var spoll: [1]posix.pollfd = undefined;

    while (true) {
        spoll = .{
            .{
                .fd = client,
                .events = posix.POLL.OUT,
                .revents = 0,
            },
        };

        const pollstatus = try posix.poll(&spoll, SEC_TIMEOUT_MS * 3);

        if (pollstatus == 1) {
            break;
        }
    }

    if (spoll[0].revents & posix.POLL.HUP != 0) {
        return false;
    }

    return true;
}

fn waitConnectMacos(client: posix.socket_t) !bool {
    const kq = try posix.kqueue();
    defer posix.close(kq);

    const change: posix.Kevent = .{
        .ident = @intCast(client),
        .filter = KqueueConstants.EVFILT_WRITE,
        .flags = KqueueConstants.EV_ADD,
        .fflags = 0,
        .data = 0,
        .udata = 0,
    };

    _ = try posix.kevent(kq, &.{change}, &.{}, null);

    var ts: posix.timespec = .{
        .sec = SEC_TIMEOUT_MS * 3 / 1000,
        .nsec = (SEC_TIMEOUT_MS * 3 % 1000) * 1_000_000,
    };

    var ev: [1]posix.Kevent = undefined;

    while (true) {
        const n = try posix.kevent(kq, &.{}, &ev, &ts);
        if (n == 0) {
            continue;
        }
        if (n == 1) {
            break;
        }
    }

    if ((ev[0].flags & KqueueConstants.EV_ERROR) != 0 or
        (ev[0].flags & KqueueConstants.EV_EOF) != 0)
    {
        return false;
    }

    return true;
}

const KqueueConstants = if (builtin.os.tag == .macos) struct {
    const EVFILT_WRITE: i16 = -2;  From sys/event.h
    const EV_ADD: u16 = 0x0001;
    const EV_ONESHOT: u16 = 0x0010;
    const EV_ERROR: u16 = 0x4000;
    const EV_EOF: u16 = 0x8000;
} else struct {};


language: "en-US"

reviews:
  profile: "chill"
  high_level_summary: true

auto_review:
  enabled: true
  drafts: false

path_filters:
  - "src/**/*.zig"
  - "build.zig"
  - "!zig-cache/**"
  - "!zig-out/**"

tools:
  gitleaks:
    enabled: true




 const ErrorToStatusMap = std.enums.EnumMap(AmpeError, AmpeStatus).init(.{
     .NotImplementedYet = .not_implemented_yet,
     .WrongConfiguration = .wrong_configuration,
     .NotAllowed = .not_allowed,
     .NullMessage = .null_message,
     .InvalidMessage = .invalid_message,
     .InvalidMessageType = .invalid_message_type,
     .InvalidMessageMode = .invalid_message_mode,
     .InvalidHeadersLen = .invalid_headers_len,
     .InvalidBodyLen = .invalid_body_len,
     .InvalieChannelNumber = .invalid_channel_number,
     .InvalieMessageId = .invalid_message_id,
     .InvalidAddress = .invalid_address,
     .InvalidMoreUsage = .invalid_more_usage,
     .NotificationDisabled = .notification_disabled,
     .NotificationFailed = .notification_failed,
     .PeerDisconnected = .peer_disconnected,
     .CommunicationFailed = .communication_failed,
     .PoolEmpty = .pool_empty,
     .AllocationFailed = .allocation_failed,
     .WaitInterrupted = .wait_interrupted,
     .ChannelClosed = .channel_closed,
     .ShutdownStarted = .shutdown_started,
 });


pub fn markForDelete(dtr: *Distributor, chn: message.ChannelNumber) !void {
    const trchn = dtr.trgrd_map.getPtr(chn);
    if (trchn) |ch| {
        ch.mrk4del = true;
    }
    return;
}


pub fn addDumbChannel(dtr: *Distributor, chN: channels.ChannelNumber) !void {
     var dcn = TriggeredChannel.createDumbChannel(dtr);

     dcn.acn = dtr.*.acns.activeChannel(dtr.currBhdr.channel_number) catch unreachable;

     try dtr.addChannel(dcn);

     return;
}

pub fn addIoClientChannel(dtr: *Distributor, chN: channels.ChannelNumber) !void {
     var cnfgr: Configurator = Configurator.fromMessage(dtr.currMsg.?);

     if (cnfgr.isWrong()) {
         return AmpeError.WrongConfiguration;
     }

     var dcn = TriggeredChannel.createDumbChannel(dtr);

     dcn.acn = dtr.*.acns.activeChannel(dtr.currBhdr.channel_number) catch unreachable;

     dtr.trgrd_map.put(chN, dcn) catch {
         return AmpeError.AllocationFailed;
     };

     return;
}


    const TofuClient = struct {
        const Self = @This();
        gpa: Allocator = undefined,
        ampe: Ampe = undefined,
        cfg: *Configurator = undefined,
        result: anyerror!status.AmpeStatus = undefined,

        fn runOnThread(tfcl: *Self) void {
            log.debug("---> On client thread", .{});
            defer log.debug("<--- On client thread", .{});
            _ = tfcl;
            return;
        }
    };

    var clnt: TofuClient = .{};

    const TofuServer = struct {
        const Self = @This();
        gpa: Allocator = undefined,
        ampe: Ampe = undefined,
        cfg: *Configurator = undefined,
        result: anyerror!status.AmpeStatus = undefined,

        fn runOnThread(tfsrv: *Self) void {
            log.debug("---> On server thread", .{});
            defer log.debug("<--- On server thread", .{});
            _ = tfsrv;
            return;
        }
    };
    var srvr: TofuServer = .{};

    {
        const clntThread: std.Thread =
            try std.Thread.spawn(.{}, TofuClient.runOnThread, .{&clnt});
        defer clntThread.join();

        const srvrThread: std.Thread =
            try std.Thread.spawn(.{}, TofuServer.runOnThread, .{&srvr});
        defer srvrThread.join();
    }

