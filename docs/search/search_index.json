{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"\"Before machines can work, people must talk.\"    Get Started API Examples"},{"location":"blog/","title":"Blog","text":""},{"location":"mds/address/","title":"Address","text":"<p>tofu supports two transport types: TCP and Unix Domain Sockets (UDS).</p> <p>Address helpers do two things:</p> <ol> <li>Set the message opCode (HelloRequest or WelcomeRequest)</li> <li>Add the address header (~connect_to or ~listen_on)</li> </ol> <p>One call prepares a complete connection or listener message.</p>"},{"location":"mds/address/#address-types","title":"Address Types","text":"Type Use Case Format TCP Client Connect to a server IP address + port TCP Server Listen for connections IP address + port UDS Client Connect via Unix socket File path UDS Server Listen via Unix socket File path"},{"location":"mds/address/#tcp-addresses","title":"TCP Addresses","text":""},{"location":"mds/address/#tcpclientaddress","title":"TCPClientAddress","text":"<p>For connecting to a TCP server.</p> Connect to localhost:7099<pre><code>var addr: Address = .{\n    .tcp_client_addr = address.TCPClientAddress.init(\"127.0.0.1\", 7099)\n};\ntry addr.format(msg.?);  // Sets opCode=HelloRequest, adds ~connect_to header\n</code></pre>"},{"location":"mds/address/#tcpserveraddress","title":"TCPServerAddress","text":"<p>For listening on a TCP port.</p> Listen on all interfaces, port 7099<pre><code>var addr: Address = .{\n    .tcp_server_addr = address.TCPServerAddress.init(\"0.0.0.0\", 7099)\n};\ntry addr.format(msg.?);  // Sets opCode=WelcomeRequest, adds ~listen_on header\n</code></pre> <p>Common IP values:</p> Address Meaning <code>0.0.0.0</code> All IPv4 interfaces (listen on all) <code>127.0.0.1</code> Localhost only (loopback) <code>192.168.x.x</code> Specific network interface"},{"location":"mds/address/#uds-addresses","title":"UDS Addresses","text":"<p>Unix Domain Sockets use file paths instead of IP:port.</p> NAQ: When should I use UDS vs TCP? <p>Use UDS when both sides run on the same machine. No network overhead. Use TCP when sides run on different machines, or when you need standard ports.</p>"},{"location":"mds/address/#udsclientaddress","title":"UDSClientAddress","text":"Connect via Unix socket<pre><code>var addr: Address = .{\n    .uds_client_addr = address.UDSClientAddress.init(\"/tmp/my-app.sock\")\n};\ntry addr.format(msg.?);  // Sets opCode=HelloRequest, adds ~connect_to header\n</code></pre>"},{"location":"mds/address/#udsserveraddress","title":"UDSServerAddress","text":"Listen via Unix socket<pre><code>var addr: Address = .{\n    .uds_server_addr = address.UDSServerAddress.init(\"/tmp/my-app.sock\")\n};\ntry addr.format(msg.?);  // Sets opCode=WelcomeRequest, adds ~listen_on header\n</code></pre> <p>UDS paths</p> <p>The socket file is created when the server starts listening. If the file already exists, <code>listen</code> may fail. Clean up old socket files before starting.</p>"},{"location":"mds/address/#wire-format","title":"Wire Format","text":"<p>Address headers use pipe-separated format:</p> <pre><code>~connect_to: \"tcp|127.0.0.1|7099\"\n~connect_to: \"uds|/tmp/socket.sock\"\n~listen_on: \"tcp|0.0.0.0|7099\"\n~listen_on: \"uds|/tmp/socket.sock\"\n</code></pre> <p>Use helpers, not strings</p> <p>Always use the address helpers (<code>TCPClientAddress</code>, etc.) instead of building header strings manually. The helpers handle formatting correctly.</p>"},{"location":"mds/address/#complete-examples","title":"Complete Examples","text":""},{"location":"mds/address/#tcp-client-connecting-to-server","title":"TCP Client connecting to server","text":"<pre><code>var msg = try ampe.get(.always);\ndefer ampe.put(&amp;msg);\n\nvar addr: Address = .{\n    .tcp_client_addr = address.TCPClientAddress.init(\"192.168.1.100\", 8080)\n};\ntry addr.format(msg.?);\n\nconst bhdr = try chnls.post(&amp;msg);\nconst server_channel = bhdr.channel_number;\n</code></pre>"},{"location":"mds/address/#tcp-server-starting-listener","title":"TCP Server starting listener","text":"<pre><code>var msg = try ampe.get(.always);\ndefer ampe.put(&amp;msg);\n\nvar addr: Address = .{\n    .tcp_server_addr = address.TCPServerAddress.init(\"0.0.0.0\", 8080)\n};\ntry addr.format(msg.?);\n\nconst bhdr = try chnls.post(&amp;msg);\nconst listener_channel = bhdr.channel_number;\n\n// Wait for confirmation\nvar resp = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;resp);\n// resp.bhdr.proto.opCode == .WelcomeResponse\n</code></pre>"},{"location":"mds/address/#uds-for-same-machine-communication","title":"UDS for same-machine communication","text":"<pre><code>// Server\nvar srvAddr: Address = .{\n    .uds_server_addr = address.UDSServerAddress.init(\"/var/run/myapp.sock\")\n};\n\n// Client (same machine)\nvar cltAddr: Address = .{\n    .uds_client_addr = address.UDSClientAddress.init(\"/var/run/myapp.sock\")\n};\n</code></pre>"},{"location":"mds/address/#quick-reference","title":"Quick Reference","text":"Address type OpCode set Header added <code>TCPClientAddress</code> HelloRequest <code>~connect_to: tcp\\|...\\|...</code> <code>TCPServerAddress</code> WelcomeRequest <code>~listen_on: tcp\\|...\\|...</code> <code>UDSClientAddress</code> HelloRequest <code>~connect_to: uds\\|...</code> <code>UDSServerAddress</code> WelcomeRequest <code>~listen_on: uds\\|...</code>"},{"location":"mds/advanced-topics/","title":"Advanced Topics","text":"<p>Details for production use.</p>"},{"location":"mds/advanced-topics/#channel-lifecycle","title":"Channel Lifecycle","text":"<p>Channels go through states. You don't manage states directly, but understanding helps.</p>"},{"location":"mds/advanced-topics/#listener-channel","title":"Listener Channel","text":"<pre><code>WelcomeRequest \u2500\u2500\u25ba [opening] \u2500\u2500\u25ba WelcomeResponse \u2500\u2500\u25ba [ready]\n                                    \u2502\n                   status != 0 \u2500\u2500\u2500\u2500\u2500\u2518 (failed)\n</code></pre> <p>After <code>ready</code>: accepts incoming connections, creates IO channels.</p>"},{"location":"mds/advanced-topics/#io-channel-client-side","title":"IO Channel (Client Side)","text":"<pre><code>HelloRequest \u2500\u2500\u25ba [connecting] \u2500\u2500\u25ba HelloResponse \u2500\u2500\u25ba [ready]\n                                      \u2502\n                     status != 0 \u2500\u2500\u2500\u2500\u2500\u2518 (failed)\n</code></pre>"},{"location":"mds/advanced-topics/#io-channel-server-side","title":"IO Channel (Server Side)","text":"<pre><code>HelloRequest received \u2500\u2500\u25ba [ready]\n</code></pre> <p>Server's IO channel is ready immediately when HelloRequest arrives.</p>"},{"location":"mds/advanced-topics/#closing","title":"Closing","text":"<pre><code>ByeRequest \u2500\u2500\u25ba [closing] \u2500\u2500\u25ba ByeResponse \u2500\u2500\u25ba [closed]\n\nByeSignal \u2500\u2500\u25ba [closed] (immediate)\n</code></pre>"},{"location":"mds/advanced-topics/#channel-number-reuse","title":"Channel Number Reuse","text":"<p>tofu reuses channel numbers after channels close.</p> <pre><code>1. Channel 5 opened for Client A\n2. Client A disconnects, channel 5 closed\n3. Client B connects, gets channel 5 again\n</code></pre> <p>Don't cache channel numbers long-term</p> <p>If you store channel numbers, update them on <code>channel_closed</code>. An old channel number might refer to a different connection later.</p>"},{"location":"mds/advanced-topics/#memory-management","title":"Memory Management","text":""},{"location":"mds/advanced-topics/#message-pool","title":"Message Pool","text":"<p>tofu pre-allocates messages in a pool. Configure pool size at startup:</p> <pre><code>const options: tofu.Options = .{\n    .initialPoolMsgs = 32,   // Start with 32 messages\n    .maxPoolMsgs = 128,      // Can grow to 128\n};\n\nvar rtr: *Reactor = try Reactor.create(gpa, options);\n</code></pre>"},{"location":"mds/advanced-topics/#allocation-strategy","title":"Allocation Strategy","text":"<p><code>ampe.get()</code> takes a strategy:</p> <pre><code>// Only from pool - returns null if empty\nvar msg = try ampe.get(.poolOnly);\n\n// Pool first, allocate if empty - never returns null\nvar msg = try ampe.get(.always);\n</code></pre> <p>Use <code>.poolOnly</code> when you can handle null (non-critical messages). Use <code>.always</code> when you must have a message (critical operations).</p>"},{"location":"mds/advanced-topics/#returning-messages","title":"Returning Messages","text":"<p>Always return messages promptly:</p> <pre><code>// Good - defer immediately after get\nvar msg = try ampe.get(.always);\ndefer ampe.put(&amp;msg);\n\n// Good - return received messages\nvar resp = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;resp);\n</code></pre> <p>defer handles post() correctly</p> <p>After <code>post()</code>, msg becomes null. <code>put(null)</code> is a no-op. So <code>defer ampe.put(&amp;msg)</code> is always safe.</p>"},{"location":"mds/advanced-topics/#adding-messages-to-pool","title":"Adding Messages to Pool","text":"<p>If pool runs low, you can add messages:</p> <pre><code>fn addToPool(ampe: Ampe, count: usize) !void {\n    const allocator = ampe.getAllocator();\n    for (0..count) |_| {\n        var msg: ?*Message = try Message.create(allocator);\n        ampe.put(&amp;msg);\n    }\n}\n</code></pre>"},{"location":"mds/advanced-topics/#multiple-channelgroups","title":"Multiple ChannelGroups","text":"<p>You can create multiple ChannelGroups for different purposes:</p> <pre><code>const ampe: Ampe = try rtr.ampe();\n\n// Separate groups for different subsystems\nconst clientChannels: ChannelGroup = try ampe.create();\nconst serverChannels: ChannelGroup = try ampe.create();\nconst adminChannels: ChannelGroup = try ampe.create();\n\ndefer tofu.DestroyChannels(ampe, clientChannels);\ndefer tofu.DestroyChannels(ampe, serverChannels);\ndefer tofu.DestroyChannels(ampe, adminChannels);\n</code></pre> <p>Each group has its own <code>waitReceive()</code>. Messages go to the group that owns the channel.</p> NAQ: When should I use multiple ChannelGroups? <p>When you have separate subsystems that should process messages independently. Example: main protocol on one group, admin/monitoring on another.</p>"},{"location":"mds/advanced-topics/#multi-listener-server","title":"Multi-Listener Server","text":"<p>One server can listen on multiple addresses (TCP + UDS):</p> <pre><code>// TCP listener\nvar tcpAddr: Address = .{\n    .tcp_server_addr = address.TCPServerAddress.init(\"0.0.0.0\", 8080)\n};\nvar tcpReq: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;tcpReq);\ntry tcpAddr.format(tcpReq.?);\nconst tcpBhdr = try chnls.post(&amp;tcpReq);\n\n// UDS listener\nvar udsAddr: Address = .{\n    .uds_server_addr = address.UDSServerAddress.init(\"/var/run/myapp.sock\")\n};\nvar udsReq: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;udsReq);\ntry udsAddr.format(udsReq.?);\nconst udsBhdr = try chnls.post(&amp;udsReq);\n\n// Wait for both confirmations\nvar resp1 = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;resp1);\nvar resp2 = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;resp2);\n\n// Both listeners ready\n// HelloRequests from either transport arrive via waitReceive()\n</code></pre>"},{"location":"mds/advanced-topics/#updatereceiver","title":"UpdateReceiver","text":"<p>Wake up a blocked <code>waitReceive()</code> from another thread:</p> <pre><code>// Thread A: blocked on waitReceive\nvar msg = try chnls.waitReceive(tofu.waitReceive_INFINITE_TIMEOUT);\n\n// Thread B: wake up Thread A\nvar signal: ?*Message = null;  // or a message with data\ntry chnls.updateReceiver(&amp;signal);\n</code></pre> <p>Thread A receives a message with <code>status == .receiver_update</code>.</p> <p>Use for:</p> <ul> <li>Shutdown signal</li> <li>New work available</li> <li>Configuration change</li> </ul> <pre><code>// Check for updateReceiver signal\nif (msg.?.isFromEngine()) {\n    const sts = tofu.status.raw_to_status(msg.?.bhdr.status);\n    if (sts == .receiver_update) {\n        if (shutdown_requested) {\n            break;\n        }\n        // Handle other updates\n    }\n}\n</code></pre>"},{"location":"mds/advanced-topics/#threading-model","title":"Threading Model","text":"<p>tofu uses internal threads for I/O:</p> <pre><code>Your Thread(s)              tofu Threads\n     \u2502                           \u2502\n     \u251c\u2500\u2500post()\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba  IO Thread \u2500\u2500\u25ba socket\n     \u2502                           \u2502\n     \u25c4\u2500\u2500waitReceive()\u2500\u2500\u2500\u2500\u2500  IO Thread \u25c4\u2500\u2500 socket\n     \u2502                           \u2502\n</code></pre> <ul> <li><code>post()</code> and <code>waitReceive()</code> are thread-safe</li> <li>Multiple threads can call them on the same ChannelGroup</li> <li>Each ChannelGroup has its own receive queue</li> </ul> <p>Thread safety</p> <p>You can call <code>post()</code> from any thread. Only one thread should call <code>waitReceive()</code> per ChannelGroup at a time.</p>"},{"location":"mds/advanced-topics/#performance-tips","title":"Performance Tips","text":""},{"location":"mds/advanced-topics/#pool-size","title":"Pool Size","text":"<p>Set pool size based on expected concurrency:</p> <pre><code>const options: tofu.Options = .{\n    .initialPoolMsgs = concurrent_requests * 2,\n    .maxPoolMsgs = concurrent_requests * 4,\n};\n</code></pre>"},{"location":"mds/advanced-topics/#reuse-messages","title":"Reuse Messages","text":"<p>Reuse received messages for responses:</p> <pre><code>// Instead of get() + put() + get()\nvar msg = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;msg);\n\n// Reuse for response\nmsg.?.bhdr.proto.opCode = .Response;\nmsg.?.body.clear();\ntry msg.?.body.append(result);\n_ = try chnls.post(&amp;msg);\n// defer handles the now-null msg\n</code></pre>"},{"location":"mds/advanced-topics/#batch-operations","title":"Batch Operations","text":"<p>Process multiple messages per loop iteration:</p> <pre><code>while (true) {\n    // Process all available messages\n    while (true) {\n        var msg = try chnls.waitReceive(0);  // No wait\n        if (msg == null) break;\n        defer ampe.put(&amp;msg);\n        handleMessage(msg);\n    }\n\n    // Then wait for more\n    var msg = try chnls.waitReceive(tofu.waitReceive_SEC_TIMEOUT);\n    if (msg == null) continue;\n    defer ampe.put(&amp;msg);\n    handleMessage(msg);\n}\n</code></pre>"},{"location":"mds/advanced-topics/#debugging","title":"Debugging","text":""},{"location":"mds/advanced-topics/#message-dumps","title":"Message Dumps","text":"<p>BinaryHeader has a dump method:</p> <pre><code>msg.?.bhdr.dumpMeta(\"received: \");\n// Prints channel, opCode, status, message_id\n</code></pre>"},{"location":"mds/advanced-topics/#status-names","title":"Status Names","text":"<p>Convert status to readable name:</p> <pre><code>const sts = tofu.status.raw_to_status(msg.?.bhdr.status);\nstd.debug.print(\"Status: {}\\n\", .{sts});\n</code></pre>"},{"location":"mds/advanced-topics/#common-issues","title":"Common Issues","text":"Symptom Likely cause <code>waitReceive</code> returns null Timeout, no messages Got my message back Check origin and status <code>channel_closed</code> unexpected Peer disconnected or network failure <code>pool_empty</code> frequent Return messages faster, increase pool Wrong channel in response Channel reuse - track carefully"},{"location":"mds/advanced-topics/#cleanup","title":"Cleanup","text":"<p>Proper shutdown:</p> <pre><code>// Stop accepting new work\nrunning = false;\n\n// Close all channels gracefully\nfor (active_channels.items) |ch| {\n    var bye: ?*Message = try ampe.get(.always);\n    bye.?.bhdr.proto.opCode = .ByeSignal;  // Fast close\n    bye.?.bhdr.channel_number = ch;\n    _ = try chnls.post(&amp;bye);\n}\n\n// Drain remaining messages\nwhile (true) {\n    var msg = try chnls.waitReceive(tofu.waitReceive_SEC_TIMEOUT);\n    if (msg == null) break;\n    ampe.put(&amp;msg);\n}\n\n// Destroy in reverse order\ntofu.DestroyChannels(ampe, chnls);\nrtr.destroy();\n</code></pre>"},{"location":"mds/allocator/","title":"Allocator","text":"<p>Zig takes pride in its allocators; they are its \"signature feature,\" or, as one might say, the \"spice of life\".</p> <p>The \"allocator-passing idiom\" in Zig refers to the explicit handling of memory allocation by passing an allocator as a parameter to functions and data structures, empowering the caller to control the allocation strategy at every level of the program.</p> <p>Tofu's relationship with Allocators is similar to Henry Ford's famous quote about car color:</p> <p>\"Customers can have any color they want, so long as it is black.\"</p> <p>Similarly, allocators for Tofu can be anything, provided they are 'GPA compatible'.</p> <p>Allocator names in Zig change often. This reminds me of an old Unix joke:</p> <p>\"Unix is an operating system where nobody knows what the print command is called today\"</p> <p>I'll use GPA (General Purpose Allocator) because I expect that the name GPA will persist in common use.</p> <p> 'GPA compatible' means:</p> <ul> <li>It is thread-safe.</li> <li>Its life cycle is the same as the life cycle of the process.</li> <li>The memory it releases truly allows for further reuse of that released memory.</li> </ul> <p>For example, <code>std.heap.c_allocator</code> satisfies these requirements, but <code>std.heap.ArenaAllocator</code> does not.</p> <p>How many unnecessary memories one Allocator brings back  ...</p>"},{"location":"mds/ampe/","title":"Ampe","text":"<p>Ampe or engine is the \"holder\" (owner) and allocator of all tofu resources</p> <ul> <li>ChannelGroups</li> <li>Messages</li> </ul> <p>Consider it the GPA of tofu. </p>"},{"location":"mds/ampe/#ampe-creation","title":"Ampe creation","text":"Example of Ampe creation<pre><code>pub fn createDestroyAmpe(gpa: Allocator) !void {\n    // Create engine implementation object\n    const rtr: *Reactor = try Reactor.Create(gpa, DefaultOptions);\n\n    // Destroy it after return or on error\n    defer rtr.*.Destroy();\n\n    // Create ampe interface\n    const ampe: Ampe = try rtr.*.ampe();\n\n    _ = ampe;\n\n    // No need to destroy ampe itself.\n    // It is an interface provided by Reactor.\n    // It will be destroyed via  rtr.*.Destroy().\n}\n</code></pre> <p>Note</p> <p>You can create multiple engines per process.</p>"},{"location":"mds/ampe/#interface","title":"Interface","text":"<p>Ampe is represented by the following interface: </p> Brief version of the Interface<pre><code>pub const Ampe = struct {\n    pub fn create(ampe: Ampe) status.AmpeError!ChannelGroup {...}\n    pub fn destroy(ampe: Ampe, chnls: ChannelGroup) status.AmpeError!void {...}\n\n    pub fn get(ampe: Ampe, strategy: AllocationStrategy) status.AmpeError!?*message.Message {...}\n    pub fn put(ampe: Ampe, msg: *?*message.Message) void {...}\n\n    pub fn getAllocator(ampe: Ampe) Allocator {...}\n</code></pre> <p>Just a reminder: all methods are thread-safe.</p> <p>The first two methods, create/destroy, manage a ChannelGroup. You don't need to know what that is yet; just make a note of it.</p> <p>The next two methods require additional explanation, so let's move on to the Message Pool.</p>"},{"location":"mds/ampe/#message-pool","title":"Message Pool","text":"<p>Ampe supports a Message Pool mechanism to improve system performance.</p> <p>The get operation retrieves an existing message from the pool or creates a new one.  The choice is determined by the strategy: AllocationStrategy parameter: <pre><code>pub const AllocationStrategy = enum {\n    poolOnly, // Tries to get a message from the pool. Returns null if the pool is empty.\n    always,   // Gets a message from the pool or creates a new one if the pool is empty.\n};\n</code></pre></p> <p>null isn't error</p> <p>Returned by get null is absolutely valid value, null returned if the pool is empty and the strategy is poolOnly. </p> <p>get returns error if</p> <ul> <li>allocation failed</li> <li>engine performs shutdown</li> </ul> <p>Opposite put operation returns message to the pool and sets it's value to null. If engine performs shutdown or pool is full, message will be destroyed, means all allocated memory silently will be released.</p> <pre><code>    var msg: ?*Message = try ampe.get(tofu.AllocationStrategy.poolOnly);\n    defer ampe.put(&amp;msg);\n</code></pre> <p>Because null returned by get is valid value , it's also valid value for put: if msg == null, put does nothing.</p> <p>NAQ: *?*message.Message - WTH???</p> <p>*?* (address of optional pointer) idiom allows to prevent reusing of released or moved to other thread objects(structs). In our case - Messages.</p> <p><code>ampe.put(&amp;msg)</code>:</p> <ul> <li>returns msg to the pool</li> <li>set msg to null</li> </ul> <p>As result:</p> <ul> <li>every further put will be successful</li> <li>every further attempt to use msg without check will fail</li> </ul> <p>You will see usage of *?* in different places during our journey.</p>"},{"location":"mds/ampe/#pool-configuration","title":"Pool configuration","text":"<p>Pool configuration is determined by  <pre><code>pub const Options = struct {\n    initialPoolMsgs: ?u16 = null,\n    maxPoolMsgs: ?u16 = null,\n};\n</code></pre> initialPoolMsgs - is the number of messages in the pool created during initialization of engine</p> <p>maxPoolMsgs - is the maximal number of the messages </p> <p>Do you remember ? </p> <p>If ... pool is full, message will be destroyed</p> <p>means if number of the messages in the pool == maxPoolMsgs, message will be destroyed.</p> <p>Tofu provides default pool configuration: Just example of configuration, it isn't recommendation<pre><code>    pub const DefaultOptions: Options = .{\n        .initialPoolMsgs = 16,\n        .maxPoolMsgs = 64,\n    };\n</code></pre></p> <p>Pool configuration is used during creation of engine: <pre><code>    // Create engine implementation object with default pool configuration \n    var rtr: *Reactor = try Reactor.Create(gpa, DefaultOptions);\n</code></pre></p> <p>Just clarification - you don't deal with pool destroy, it will be destroyed during destroy of engine. </p>"},{"location":"mds/ampe/#allocator","title":"Allocator","text":"<p>Tofu's relationship with Allocators is similar to Henry Ford's famous quote about car color:</p> <p>\"Customers can have any color they want, so long as it is black.\"</p> <p>Similarly, allocators for Tofu can be anything, provided they are 'GPA compatible'.</p> <p>Allocator names in Zig change often. This reminds me of an old Unix joke:</p> <p>\"Unix is an operating system where nobody knows what the print command is called today\"</p> <p>I'll use GPA (General Purpose Allocator) because I expect that the name GPA will persist in common use.</p> <p> 'GPA compatible' means:</p> <ul> <li>It is thread-safe.</li> <li>Its life cycle is the same as the life cycle of the process.</li> <li>The memory it releases truly allows for further reuse of that released memory.</li> </ul> <p>For example, <code>std.heap.c_allocator</code> satisfies these requirements, but <code>std.heap.ArenaAllocator</code> does not.</p> <p>t's no surprise that ampe.getAllocator() returns GPA compatible allocator used during ampe's creation. </p>"},{"location":"mds/appendable/","title":"Appendable","text":"<p>The body buffer type used in messages. Manages a growable byte buffer.</p>"},{"location":"mds/appendable/#what-it-is","title":"What It Is","text":"<p><code>Appendable</code> is a dynamically growable byte buffer. Messages use it for the body field:</p> <pre><code>pub const Message = struct {\n    bhdr: BinaryHeader = .{},\n    thdrs: TextHeaders = .{},\n    body: Appendable = .{},   // &lt;-- This\n    // ...\n};\n</code></pre> <p>You don't create Appendable directly. tofu creates and manages it. You just use it.</p>"},{"location":"mds/appendable/#reading-data","title":"Reading Data","text":"<p>Get the current content:</p> <pre><code>const data = msg.?.body.body();  // Returns ?[]const u8\n</code></pre> <p>Returns <code>null</code> if:</p> <ul> <li>Buffer not allocated</li> <li>Buffer is empty (length = 0)</li> </ul> <p>Safe pattern:</p> <pre><code>if (msg.?.body.body()) |data| {\n    // data is []const u8\n    processData(data);\n} else {\n    // No body data\n}\n</code></pre>"},{"location":"mds/appendable/#writing-data","title":"Writing Data","text":"<p>Add bytes to the buffer:</p> <pre><code>try msg.?.body.append(my_data);  // Grows automatically if needed\n</code></pre> <p>Replace all content:</p> <pre><code>try msg.?.body.copy(new_data);   // Resets then appends\n</code></pre> <p>Clear the buffer:</p> <pre><code>msg.?.body.reset();  // Sets length to 0, keeps memory allocated\n</code></pre>"},{"location":"mds/appendable/#methods-summary","title":"Methods Summary","text":"Method Returns Description <code>body()</code> <code>?[]const u8</code> Current data slice, or null if empty <code>append(data)</code> <code>!void</code> Add bytes, auto-grows buffer <code>copy(data)</code> <code>!void</code> Replace content (reset + append) <code>reset()</code> <code>void</code> Clear length to 0, keep memory"},{"location":"mds/appendable/#size-limit","title":"Size Limit","text":"<p>64 KiB - 1 maximum</p> <p>Body content is limited to 65535 bytes (64 KiB - 1). For larger data, use streaming with the <code>more</code> flag.</p>"},{"location":"mds/appendable/#memory-management","title":"Memory Management","text":"<p>tofu handles all memory:</p> <ul> <li>Buffer is pre-allocated when message is created</li> <li><code>append()</code> grows buffer automatically if needed</li> <li><code>reset()</code> clears without freeing (efficient for reuse)</li> <li>Buffer is freed when message returns to pool</li> </ul> <p>You never need to call <code>init()</code> or <code>deinit()</code>.</p>"},{"location":"mds/appendable/#common-patterns","title":"Common Patterns","text":""},{"location":"mds/appendable/#check-before-read","title":"Check before read","text":"<pre><code>var msg: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;msg);\n\nif (msg.?.body.body()) |data| {\n    // Process data\n} else {\n    // Empty body - handle accordingly\n}\n</code></pre>"},{"location":"mds/appendable/#build-response-in-place","title":"Build response in place","text":"<pre><code>// Reuse received message for response\nmsg.?.bhdr.proto.opCode = .Response;\nmsg.?.body.reset();                    // Clear old content\ntry msg.?.body.append(\"result: \");     // Add new content\ntry msg.?.body.append(result_data);\n_ = try chnls.post(&amp;msg);\n</code></pre>"},{"location":"mds/appendable/#accumulate-streamed-data","title":"Accumulate streamed data","text":"<pre><code>var buffer = std.ArrayList(u8).init(allocator);\ndefer buffer.deinit();\n\nwhile (true) {\n    var msg: ?*Message = try chnls.waitReceive(timeout);\n    defer ampe.put(&amp;msg);\n\n    if (msg.?.body.body()) |chunk| {\n        try buffer.appendSlice(chunk);\n    }\n\n    if (!msg.?.hasMore()) break;\n}\n// buffer.items contains all accumulated data\n</code></pre>"},{"location":"mds/channel-group/","title":"ChannelGroup","text":"<p>ChannelGroup provides full-duplex, asynchronous message exchange between peers. </p> NAQ: Why \"peers\" instead of \"client/server\"? <p>Tofu uses client and server terms to describe the initial handshake. After the handshake, both sides are called peers because they have equal  functionality and roles.</p> <p>Simplest description of ChannelGroup you can get from its name - Group Of Channels .</p>"},{"location":"mds/channel-group/#channel","title":"Channel","text":"<p>Think of a channel as a virtual connection/socket.</p> <p>There are two kinds of channels:</p> <ul> <li>Listener \u2013 Analog of a listener socket.</li> <li>IO \u2013 Analog of client socket or accepted server socket.</li> </ul> NAQ: Why not just Socket ? <p>You cannot send messages to an unconnected socket, but it ok with channel.</p> <p>Channels are identified by a channel number in the range [1-65534].</p> <p>Two channel number values are reserved:</p> <ul> <li>0 \u2013 Unassigned channel number</li> <li>65535 \u2013 Tofu internal channel number</li> </ul> <p>Channel numbers are unique within the engine that created them, from creation until closure.</p> <p>Warn</p> <p>Another engine in the same process or an engine in a different process may assign the same channel number simultaneously.</p> <p>Every channel has 3 internal states:</p> <ul> <li>opened - engine assigned channel number</li> <li>ready<ul> <li>IO channel - ready for send/receive messages</li> <li>Listener channel - ready for accept incoming connections</li> </ul> </li> <li>closed</li> </ul>"},{"location":"mds/channel-group/#channelgroup-createdestroy","title":"ChannelGroup create/destroy","text":"<p>Let's create and destroy a ChannelGroup\u2014still without fully understanding what it is.</p> <pre><code>    const rtr: *Reactor = try Reactor.Create(gpa, DefaultOptions);\n    defer rtr.*.Destroy();\n\n    const ampe: Ampe = try rtr.*.ampe();\n\n    const chnls: ChannelGroup = try ampe.create();\n\n    defer { \n        _ = ampe.destroy(chnls) catch | err | {\n            std.log.err(\"destroy channel group failed with error {any}\", .{err});\n        };\n    }\n</code></pre> <p>There are two ways to release resources (messages, channels etc.) of ChannelGroup</p> <ul> <li>explicit - via  ampe.destroy(...) [PREFERRED]</li> <li>implicit - during destroy of engine - rtr.*.Destroy() [FOR SIMPLE GO/NO GO]</li> </ul> <p>Warn</p> <p>ampe.destroy(chngrp) cannot be used directly in defer because defer does not allow try or error unions.  </p>"},{"location":"mds/channel-group/#channelgroup-interface","title":"ChannelGroup interface","text":"<pre><code>/// Defines the ChannelGroup interface for async message passing.\n/// Supports two-way message exchange between peers.\npub const ChannelGroup = struct {\n\n    /// Submits a message for async processing:\n    /// - most cases: send to peer\n    /// - others: internal network related processing\n    ///\n    /// On success:\n    /// - Sets `msg.*` to null (prevents reuse).\n    /// - Returns `BinaryHeader` for tracking.\n    ///\n    /// On error:\n    /// - Returns an error.\n    /// - If the engine cannot use the message (internal failure),\n    ///   also sets `msg.*` to null.\n    ///\n    /// Thread-safe.\n    pub fn post(\n        chnls: ChannelGroup,\n        msg: *?*message.Message,\n    ) status.AmpeError!message.BinaryHeader {...}\n\n    /// Waits for the next message from the internal queue.\n    ///\n    /// Timeout is in nanoseconds. Returns `null` if no message arrives in time.\n    ///\n    /// Message sources:\n    /// - Remote peer (via `post` on their side).\n    /// - Application (via `updateReceiver` on this ChannelGroup).\n    /// - Ampe (status/control messages).\n    ///\n    /// Check `BinaryHeader` to identify the source.\n    ///\n    /// On error: stop using this ChannelGroup and call `ampe.destroy` on it.\n    ///\n    /// Call in a loop from **one thread only**.\n    pub fn waitReceive(\n        chnls: ChannelGroup,\n        timeout_ns: u64,\n    ) status.AmpeError!?*message.Message {...}\n\n    /// Adds a message to the internal queue for `waitReceive`.\n    ///\n    /// If `msg.*` is not null:\n    /// - Engine sets status to `'receiver_update'`.\n    /// - Sets `msg.*` to null after success.\n    /// - No need for `channel_number` or similar fields.\n    ///\n    /// If `msg.*` is null:\n    /// - Creates a `'receiver_update'` Signal and adds it.\n    ///\n    /// Returns error if shutting down.\n    ///\n    /// Use from another thread to:\n    /// - Wake the receiver (`msg.*` = null).\n    /// - Send info/commands/notifications.\n    ///\n    /// FIFO order only. No priority queues.\n    ///\n    /// Thread-safe.\n    pub fn updateReceiver(\n        chnls: ChannelGroup,\n        update: *?*message.Message,\n    ) status.AmpeError!void {...}\n}\n</code></pre> NAQ: No methods use channel numbers. How to handle channels? <p>You also won't see IP addresses or port numbers. All this info is in the messages.</p> <p>Without details about Message, it is hard to explain how to use this interface. A full description will come later.</p>"},{"location":"mds/coding-style/","title":"Coding style","text":""},{"location":"mds/coding-style/#big-endian-imports-vs-little-endian-imports","title":"Big-endian imports vs Little-endian imports","text":"<p>There are two \"parties\" in Zig about where imports should be placed.</p> <p>Big-endian - imports are placed at the top of the file, before the code.</p> <p>Little-endian - imports are placed at the bottom of the file, after the code.</p> <p>I belong to the LE party. At least, tofu sources use LE imports.</p> <p>But in examples, I am using BE just for your convenience.</p>"},{"location":"mds/coding-style/#type-inference","title":"Type inference","text":"<p>Type inference is convenient for the developer:</p> <ul> <li>when working with comptime-generated code</li> <li>when the IDE displays the actual types</li> </ul> <p>It is not convenient for the reader:</p> <ul> <li>when looking at small examples or snippets</li> <li>when reading code in a browser or editor without type hints</li> </ul> <p>That\u2019s why in examples \u2014 and increasingly in my own projects \u2014 I try to avoid type inference.</p>"},{"location":"mds/coding-style/#automatic-dereference-for-the-operator-on-single-pointers","title":"Automatic dereference for the <code>.</code> operator on single pointers","text":"<p>I am slowly moving toward always dereference explicitly.</p>"},{"location":"mds/error-handling/","title":"Error Handling","text":"<p>tofu reports errors through messages. Check origin first, then status.</p>"},{"location":"mds/error-handling/#the-origin-first-rule","title":"The Origin-First Rule","text":"<p>Every received message: check origin before anything else.</p> <pre><code>var msg: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;msg);\n\nif (msg.?.isFromEngine()) {\n    // Status notification from tofu\n    handleEngineMessage(msg);\n} else {\n    // Message from peer\n    handlePeerMessage(msg);\n}\n</code></pre> <p>Always check origin first</p> <p>Engine messages look like regular messages but mean something different. A \"Request\" from engine is not a request - it's your failed request returned.</p>"},{"location":"mds/error-handling/#engine-messages","title":"Engine Messages","text":"<p>When <code>origin == engine</code>, the message is a notification from tofu.</p> Status Meaning What to do <code>pool_empty</code> Message pool is low Return messages faster <code>channel_closed</code> Channel was closed Remove from tracking <code>connect_failed</code> Connection failed Retry or report error <code>send_failed</code> Send operation failed Handle or retry <code>recv_failed</code> Receive operation failed Handle failure <code>peer_disconnected</code> Peer closed connection Clean up <code>invalid_address</code> Bad address format Fix address <pre><code>fn handleEngineMessage(msg: *Message) void {\n    const sts = tofu.status.raw_to_status(msg.bhdr.status);\n    const ch = msg.bhdr.channel_number;\n\n    switch (sts) {\n        .pool_empty =&gt; {\n            // Pool needs messages - this message itself helps\n        },\n        .channel_closed =&gt; {\n            removeChannel(ch);\n        },\n        .connect_failed =&gt; {\n            // Your HelloRequest failed\n            handleConnectFailure(ch);\n        },\n        .send_failed, .recv_failed =&gt; {\n            // Communication error on this channel\n            handleChannelError(ch);\n        },\n        .peer_disconnected =&gt; {\n            removeChannel(ch);\n        },\n        else =&gt; {\n            // Log unexpected status\n        },\n    }\n}\n</code></pre>"},{"location":"mds/error-handling/#connection-errors","title":"Connection Errors","text":"<p>When HelloRequest fails, you get it back with error status.</p> <pre><code>var helloReq: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;helloReq);\n\ntry addr.format(helloReq.?);\nconst bhdr = try chnls.post(&amp;helloReq);\n\nvar resp: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;resp);\n\nif (resp.?.isFromEngine()) {\n    const sts = tofu.status.raw_to_status(resp.?.bhdr.status);\n    switch (sts) {\n        .connect_failed =&gt; {\n            // Server not reachable or refused connection\n        },\n        .invalid_address =&gt; {\n            // Address format wrong\n        },\n        .uds_path_not_found =&gt; {\n            // Unix socket file doesn't exist\n        },\n        else =&gt; {},\n    }\n    return error.ConnectionFailed;\n}\n\n// Success - resp is HelloResponse from server\n</code></pre> NAQ: How do I retry a failed connection? <p>Send a new HelloRequest. tofu doesn't auto-retry. <pre><code>var attempts: u8 = 0;\nwhile (attempts &lt; 5) {\n    // ... send HelloRequest ...\n    if (connected) break;\n    attempts += 1;\n    std.Thread.sleep(std.time.ns_per_s);\n}\n</code></pre></p>"},{"location":"mds/error-handling/#listener-errors","title":"Listener Errors","text":"<p>WelcomeRequest can fail if address is in use or invalid.</p> <pre><code>var welcomeReq: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;welcomeReq);\n\ntry addr.format(welcomeReq.?);\n_ = try chnls.post(&amp;welcomeReq);\n\nvar resp: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;resp);\n\nif (resp.?.bhdr.status != 0) {\n    const sts = tofu.status.raw_to_status(resp.?.bhdr.status);\n    switch (sts) {\n        .address_in_use =&gt; {\n            // Port already bound\n        },\n        .invalid_address =&gt; {\n            // Bad IP or path\n        },\n        else =&gt; {},\n    }\n    return error.ListenerFailed;\n}\n\n// Listener ready\n</code></pre>"},{"location":"mds/error-handling/#send-errors","title":"Send Errors","text":"<p>If send fails after connection, you get your message back.</p> <pre><code>var req: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;req);\n\nreq.?.bhdr.proto.opCode = .Request;\nreq.?.bhdr.channel_number = server_ch;\ntry req.?.body.append(data);\n\n_ = try chnls.post(&amp;req);\n\nvar resp: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;resp);\n\nif (resp.?.isFromEngine()) {\n    if (resp.?.bhdr.channel_number == server_ch) {\n        // Our request failed\n        const sts = tofu.status.raw_to_status(resp.?.bhdr.status);\n        switch (sts) {\n            .send_failed =&gt; {\n                // Network error during send\n            },\n            .channel_closed =&gt; {\n                // Channel died\n            },\n            else =&gt; {},\n        }\n    }\n}\n</code></pre>"},{"location":"mds/error-handling/#channel-closed","title":"Channel Closed","text":"<p>You get <code>channel_closed</code> when:</p> <ul> <li>You sent ByeRequest and got ByeResponse</li> <li>You sent ByeSignal</li> <li>Peer sent ByeRequest/ByeSignal</li> <li>Network connection dropped</li> </ul> <pre><code>if (msg.?.isFromEngine()) {\n    const sts = tofu.status.raw_to_status(msg.?.bhdr.status);\n    if (sts == .channel_closed) {\n        const ch = msg.?.bhdr.channel_number;\n\n        // Remove from your tracking\n        _ = clients.remove(ch);\n        _ = pending_requests.remove(ch);\n\n        // If this was an important connection, maybe reconnect\n        if (ch == main_server_ch) {\n            scheduleReconnect();\n        }\n    }\n}\n</code></pre>"},{"location":"mds/error-handling/#pool-empty","title":"Pool Empty","text":"<p>tofu sends <code>pool_empty</code> when the message pool is low.</p> <pre><code>if (sts == .pool_empty) {\n    // The signal message itself goes back to pool via defer\n    // This immediately helps\n\n    // If you have cached messages, return them\n    returnCachedMessages();\n\n    // Don't allocate more unless necessary\n}\n</code></pre> <p>pool_empty is a warning, not an error</p> <p>You can continue operating. Just return messages promptly. The signal message you received helps when you return it.</p>"},{"location":"mds/error-handling/#timeout-handling","title":"Timeout Handling","text":"<p><code>waitReceive()</code> returns null on timeout.</p> <pre><code>var msg: ?*Message = try chnls.waitReceive(5 * tofu.waitReceive_SEC_TIMEOUT);\n\nif (msg == null) {\n    // Nothing received in 5 seconds\n    // This is not an error - just no messages\n\n    // Good time for housekeeping\n    checkPendingTimeouts();\n    continue;\n}\n</code></pre>"},{"location":"mds/error-handling/#error-recovery-pattern","title":"Error Recovery Pattern","text":"<p>A robust receive loop:</p> <pre><code>while (running) {\n    var msg: ?*Message = try chnls.waitReceive(tofu.waitReceive_SEC_TIMEOUT);\n\n    if (msg == null) {\n        // Timeout - housekeeping\n        checkTimeouts();\n        continue;\n    }\n\n    defer ampe.put(&amp;msg);\n\n    // Engine messages first\n    if (msg.?.isFromEngine()) {\n        const sts = tofu.status.raw_to_status(msg.?.bhdr.status);\n        const ch = msg.?.bhdr.channel_number;\n\n        switch (sts) {\n            .pool_empty =&gt; {\n                // Signal goes back to pool via defer\n            },\n            .channel_closed =&gt; {\n                cleanupChannel(ch);\n            },\n            .connect_failed =&gt; {\n                if (shouldRetry(ch)) {\n                    scheduleReconnect(ch);\n                } else {\n                    reportError(ch, sts);\n                }\n            },\n            .send_failed, .recv_failed =&gt; {\n                // Message in body is the failed message\n                handleFailedMessage(msg);\n            },\n            else =&gt; {\n                logUnexpectedStatus(sts);\n            },\n        }\n        continue;\n    }\n\n    // Application messages\n    handlePeerMessage(msg);\n}\n</code></pre>"},{"location":"mds/error-handling/#converting-status-to-error","title":"Converting Status to Error","text":"<p>Use <code>raw_to_error</code> when you need to propagate:</p> <pre><code>const sts = msg.?.bhdr.status;\n\nif (sts != 0) {\n    return tofu.status.raw_to_error(sts);\n    // Returns AmpeError.ConnectFailed, AmpeError.SendFailed, etc.\n}\n</code></pre>"},{"location":"mds/error-handling/#summary","title":"Summary","text":"Check What it means <code>msg == null</code> Timeout, no message <code>msg.?.isFromEngine()</code> Status notification from tofu <code>msg.?.bhdr.status != 0</code> Error or status code <code>msg.?.isFromApplication()</code> Regular message from peer Common errors Cause <code>connect_failed</code> Server not reachable <code>channel_closed</code> Connection ended <code>send_failed</code> Network error <code>pool_empty</code> Return messages faster <code>invalid_address</code> Bad address format"},{"location":"mds/features/","title":"Features","text":"<ul> <li>Message-Based: Uses discrete messages for communication.</li> <li>Asynchronous: Enables non-blocking message exchanges.</li> <li>Duplex: Supports two-way communication.</li> <li>Peer-to-Peer: Allows equal roles after connection establishment.</li> <li>Stream oriented transport - TCP/IP and Unix Domain Sockets</li> <li>Multithread-friendly - All APIs are safe for concurrent access.</li> <li>Memory management for messages - Internal message pool</li> <li>Backpressure management - Allows to control receive of messages</li> <li>Customizable application flows - Allows to build various application flows not restricted to request/response or pub/sub</li> <li>Simplest API - You don't have to bother with or know the \"guts\" of socket interfaces</li> <li>DIY - No enforced authentication or serialization; provides features to design and implement your own.</li> <li>Callback enabled - This will be explained later. </li> </ul>"},{"location":"mds/for-tests/","title":"Test Helpers","text":"<p>tofu provides helpers for writing tests.</p>"},{"location":"mds/for-tests/#free-tcp-port","title":"Free TCP Port","text":"<p>Find an available TCP port to avoid \"address already in use\" errors.</p> <pre><code>const port = try tofu.FindFreeTcpPort();\n\nvar addr: Address = .{\n    .tcp_server_addr = address.TCPServerAddress.init(\"127.0.0.1\", port)\n};\n</code></pre> <p>Each call returns a different port.</p>"},{"location":"mds/for-tests/#temporary-uds-path","title":"Temporary UDS Path","text":"<p>Generate a unique Unix socket path for testing.</p> <pre><code>var tup: tofu.TempUdsPath = .{};\nconst path = try tup.buildPath(allocator);\n\nvar addr: Address = .{\n    .uds_server_addr = address.UDSServerAddress.init(path)\n};\n</code></pre> <p>The path is in a temp directory and won't conflict with other tests.</p>"},{"location":"mds/for-tests/#why-use-these","title":"Why Use These","text":"Problem Helper Port already in use <code>FindFreeTcpPort()</code> Socket file exists <code>TempUdsPath.buildPath()</code> Tests run in parallel Both helpers return unique values <p>Use in all tests</p> <p>Hard-coded ports and paths cause flaky tests. Always use these helpers.</p>"},{"location":"mds/for-tests/#example-test-setup","title":"Example: Test Setup","text":"<pre><code>const std = @import(\"std\");\nconst tofu = @import(\"tofu\");\nconst address = tofu.address;\nconst Address = address.Address;\n\ntest \"client-server communication\" {\n    const allocator = std.testing.allocator;\n\n    // Get unique port\n    const port = try tofu.FindFreeTcpPort();\n\n    // Server address\n    var srvAddr: Address = .{\n        .tcp_server_addr = address.TCPServerAddress.init(\"127.0.0.1\", port)\n    };\n\n    // Client address (same port)\n    var cltAddr: Address = .{\n        .tcp_client_addr = address.TCPClientAddress.init(\"127.0.0.1\", port)\n    };\n\n    // ... test code ...\n}\n\ntest \"uds communication\" {\n    const allocator = std.testing.allocator;\n\n    // Get unique socket path\n    var tup: tofu.TempUdsPath = .{};\n    const path = try tup.buildPath(allocator);\n\n    var srvAddr: Address = .{\n        .uds_server_addr = address.UDSServerAddress.init(path)\n    };\n\n    var cltAddr: Address = .{\n        .uds_client_addr = address.UDSClientAddress.init(path)\n    };\n\n    // ... test code ...\n}\n</code></pre>"},{"location":"mds/imports/","title":"Imports","text":"<p>All examples assume that the snippet below is added to your code.</p> <pre><code>const std = @import(\"std\");\nconst log = std.log;\nconst Allocator = std.mem.Allocator;\nconst assert = std.debug.assert;\n\nconst testing = std.testing;\n\n// Import of module 'tofu'\npub const tofu = @import(\"tofu\");\n\n// Reactor: The single-threaded, event-driven implementation\n// of the Ampe interface. It utilizes the Reactor pattern to multiplex\n// non-blocking socket I/O via an internal poll-style loop.\npub const Reactor = tofu.Reactor;\n\npub const Ampe = tofu.Ampe;\n\n// Contains settings for the internal message pool.\npub const Options = tofu.Options;\n\n// The default configuration options for the pool.\npub const DefaultOptions = tofu.DefaultOptions;\n\n// A grouping mechanism for managing a collection of related channels.\npub const ChannelGroup = tofu.ChannelGroup;\n\npub const message = tofu.message;\n\n// The core Message structure processed by the engine.\npub const Message = tofu.Message;\n\n// Meta-data for the Message.\n// Used internally by the engine for routing and by the application for context.\npub const BinaryHeader = message.BinaryHeader;\n\npub const status = tofu.status;\n// An enum representation of the status byte\n// (part of BinaryHeader) for clear status tracking.\npub const AmpeStatus = status.AmpeStatus;\n// An error type corresponding to the status above,\n// used for conveying failure states.\npub const AmpeError = status.AmpeError;\n\n// Helpers - for convenient injection of socket addresses\n// to the message.\npub const address = tofu.address;\npub const Address = address.Address;\n</code></pre> <p>And don't forget to assign suitable allocator, e.g.: <pre><code>    var dbalctr = std.heap.DebugAllocator(.{}).init;\n    defer {\n        const deinit_status = dbalctr.deinit();\n        // fail test; can't try in defer as defer is executed after we return\n        if (deinit_status == .leak) {\n            std.log.err(\"memory leak detected\", .{});\n        }\n    }\n\n    const gpa: Allocator = dbalctr.allocator();\n</code></pre></p>"},{"location":"mds/installation/","title":"Installation","text":"<p>Add tofu to build.zig.zon: <pre><code>zig fetch --save git+https://github.com/g41797/tofu\n</code></pre></p> <p>Add tofu to build.zig:</p> Add dependency<pre><code>    const tofu: *build.Dependency = b.dependency(\"tofu\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n</code></pre> <p>For any xyz_mod module that uses tofu, add the following code<pre><code>    xyz_mod.addImport(\"tofu\", tofu.module(\"tofu\"));\n</code></pre> Import tofu<pre><code>pub const tofu = @import(\"tofu\");\n</code></pre></p>"},{"location":"mds/key-ingredients/","title":"Ingredients","text":"<p>Tofu ingredients:</p> <ul> <li>Ampe \u2014 the Async Message Passing Engine (we call it the engine).</li> <li>ChannelGroup</li> <li>Message</li> <li>Errors and Statuses</li> <li>Addresses</li> <li>Test Helpers</li> </ul> <p>Each ingredient depends on the others, so it\u2019s hard to explain one without understanding the rest. Because of that, the short descriptions below give only the basic idea.</p> <p>The examples later will help you understand how tofu really works.</p>"},{"location":"mds/key-ingredients/#separation-of-concerns","title":"Separation of Concerns","text":""},{"location":"mds/key-ingredients/#logical-separation","title":"Logical Separation","text":"<p>The Engine owns all resources in Tofu software. It allocates and destroys Message(s) and ChannelGroup(s).</p> <p>The ChannelGroup handles async, two-way exchange of Messages.</p> <p>The Message does two things:</p> <ul> <li>Holds business data and metadata.</li> <li>Works as a command for Tofu.</li> </ul>"},{"location":"mds/key-ingredients/#physical-separation","title":"Physical Separation","text":"<p>The Engine name shows the real work it does. Every engine runs one internal thread with a poll loop. This loop handles all socket operations.</p> <p>The Ampe interface is implemented by the Reactor structure.</p> <p>All ChannelGroups share one internal socket to talk to the engine thread.</p> <p>Each ChannelGroup uses an internal queue for messages (from engine or application).</p> <p>The ChannelGroup is a thin layer. It forwards messages between application and engine thread.</p> <p>I hope Errors and Statuses don't need explanation.</p> <p>Addresses are helpers for adding network information(ports, addresses, etc.) to Message.</p> <p>Test Helpers create network information for safe testing.</p>"},{"location":"mds/key-ingredients/#tofu-based-communication-flow","title":"Tofu-based Communication Flow","text":"<p>The steps below show how communication works between network participants, called peers:</p> <ul> <li>Initialization: The peer creates a Reactor to get the Ampe interface.</li> <li>Channel Setup: The peer creates a ChannelGroup to manage channels (connections to other peers).</li> <li>Core Loop: In the main application loop, the peer:</li> <li>Sends: Gets Messages from Ampe, fills data, enqueues via ChannelGroup.</li> <li>Receives: Gets and processes incoming messages from other peers.</li> </ul> <p>This is a simple overview. Later sections show full logic and message lifecycle.</p>"},{"location":"mds/mantra/","title":"Mantra","text":"<p>Connect your developers. Then connect your applications.</p> <p>This tofu mantra is a paraphrase of Conway's Law.</p> <p>tofu \"expects\" that development starts with a conversation (connection) similar to the one shown below.</p> <p>Context:</p> <ul> <li>Two developers are discussing the message flow for a new Print Server.</li> <li>The first one is the Spool Server developer (S).</li> <li>The second one develops the RIP Worker Process (R).</li> <li>Don\u2019t worry \u2014 RIP means Raster Image Processing, not what you might think.</li> <li>Some terms may be unknown \u2014 that\u2019s fine. These two know exactly what they mean.</li> </ul> <p>This dialog is shown without the usual jokes or side comments common in real programmer discussions \u2014 just the technical part.</p> <pre><code>S: I don't know the addresses of the workers, so you should connect to me.\n\nR: I'll send a HelloRequest, because the worker can process only specific PDL types,\n   the PDL header will contain either PS or PDF.\n\nS: Do I need to send you a HelloResponse?\n\nR: No, just start sending me messages with PDL data.\n\nS: As signals?\n\nR: No, as multi-requests \u2014 each with a message ID equal to the job ID.\n\nS: You forgot the Job Ticket.\n\nR: Right. The first request should have a JobTicket header (JDF or PPD) and the\n   ticket data in the body. The following requests will have the PDL header\n   (PDF or PS) with the related content.\n\nS: But JDF is usually used only for PDF...\n\nR: Yes, but let's keep it flexible.\n\nS: Can you process several jobs simultaneously?\n\nR: It depends on licensing. Anyway, if I can, I'll send another HelloRequest \u2014\n   working one job per channel looks cleaner.\n\nS: I need a progress indicator.\n\nR: No problem. I'll send signals with the same message ID \u2014 the Progress header\n   will show the range [N:M] for page numbers.\n\nS: On job finish, send me a Response with the same message ID and processing status.\n   Also include the Progress header.\n\nR: Why should I send an obsolete message? Are you expecting a graceful close?\n\nS: Of course.\n\nR: Then I'll send a ByeRequest with the same information, and you'll send me a\n   ByeResponse. After that connection will be automatically aborted.\n\nS: That's enough for today. Send me a short text file with this protocol \u2014\n   I'll save it in Git.\n\nR: Deal. How about a cup of coffee?\n</code></pre> <p>I hope you got the point without long smart descriptions or advertising.</p>"},{"location":"mds/message-flows/","title":"Message Flows","text":"<p>tofu is async. Understanding the message flow helps you write correct code.</p>"},{"location":"mds/message-flows/#the-two-queues","title":"The Two Queues","text":"<p>tofu uses two internal queues:</p> <pre><code>Your Code                    tofu Engine                    Network\n    \u2502                            \u2502                             \u2502\n    \u251c\u2500\u2500post()\u2500\u2500\u25ba  [Send Queue]  \u2500\u253c\u2500\u2500\u25ba socket.write() \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\n    \u2502                            \u2502                             \u2502\n    \u25c4\u2500\u2500waitReceive()\u2500\u2500 [Recv Queue] \u25c4\u2500\u2500 socket.read() \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502                            \u2502                             \u2502\n</code></pre> <ul> <li>Send Queue: Messages waiting to be sent</li> <li>Recv Queue: Messages received and waiting for you</li> </ul>"},{"location":"mds/message-flows/#post-is-not-send","title":"post() Is Not send()","text":"<p><code>post()</code> puts a message in the send queue. It returns immediately.</p> <pre><code>const bhdr = try chnls.post(&amp;msg);\n// Message is in queue. Not sent yet.\n// bhdr contains the assigned channel and message_id\n</code></pre> <p>What post() returns</p> <p>The BinaryHeader with assigned values:</p> <ul> <li><code>channel_number</code> - assigned channel (for HelloRequest/WelcomeRequest)</li> <li><code>message_id</code> - assigned ID (if you left it at 0)</li> </ul> <p>The actual send happens on tofu's internal thread. You find out the result via <code>waitReceive()</code>.</p>"},{"location":"mds/message-flows/#async-completion","title":"Async Completion","text":"<p>Every operation completes asynchronously via <code>waitReceive()</code>.</p>"},{"location":"mds/message-flows/#welcomerequest-flow","title":"WelcomeRequest flow","text":"<pre><code>You                          tofu                         OS\n \u2502                            \u2502                            \u2502\n \u251c\u2500post(WelcomeRequest)\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                            \u2502\n \u2502  returns channel_number    \u2502                            \u2502\n \u2502                            \u251c\u2500\u2500create socket\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502\n \u2502                            \u251c\u2500\u2500bind()\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502\n \u2502                            \u251c\u2500\u2500listen()\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502\n \u2502                            \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500success\u2500\u2500\u2524\n \u2502\u25c4\u2500\u2500waitReceive()\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                            \u2502\n \u2502  WelcomeResponse           \u2502                            \u2502\n \u2502  status=0 (success)        \u2502                            \u2502\n</code></pre>"},{"location":"mds/message-flows/#hellorequest-flow","title":"HelloRequest flow","text":"<pre><code>Client                       tofu                        Server\n \u2502                            \u2502                            \u2502\n \u251c\u2500post(HelloRequest)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                            \u2502\n \u2502  returns channel_number    \u2502                            \u2502\n \u2502                            \u251c\u2500\u2500connect()\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502\n \u2502                            \u251c\u2500\u2500send(HelloRequest)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502\n \u2502                            \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500HelloRequest\u2500\u2500\u2500\u2500\u2500\u2524\n \u2502                            \u2502                            \u251c\u2500waitReceive()\n \u2502                            \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500HelloResponse\u2500\u2500\u2500\u2500\u2524\n \u2502\u25c4\u2500\u2500waitReceive()\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                            \u2502\n \u2502  HelloResponse             \u2502                            \u2502\n</code></pre>"},{"location":"mds/message-flows/#failure-paths","title":"Failure Paths","text":"<p>When something fails, you get the original message back with error status.</p>"},{"location":"mds/message-flows/#connection-failure","title":"Connection failure","text":"<pre><code>var helloReq: ?*Message = try ampe.get(.always);\ntry addr.format(helloReq.?);\n_ = try chnls.post(&amp;helloReq);\n\nvar resp: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;resp);\n\nif (resp.?.isFromEngine()) {\n    // Connection failed - this is your HelloRequest returned\n    const sts = tofu.status.raw_to_status(resp.?.bhdr.status);\n    // sts could be: connect_failed, invalid_address, etc.\n}\n</code></pre> <p>Check origin first</p> <ul> <li><code>origin == application</code> \u2192 message from peer</li> <li><code>origin == engine</code> \u2192 status notification from tofu</li> </ul>"},{"location":"mds/message-flows/#send-failure","title":"Send failure","text":"<p>If the network fails after connection, you get your message back:</p> <pre><code>_ = try chnls.post(&amp;request);\n\nvar resp: ?*Message = try chnls.waitReceive(timeout);\n\nif (resp.?.isFromEngine() and resp.?.bhdr.status != 0) {\n    // This is your request, returned with error\n    const sts = tofu.status.raw_to_status(resp.?.bhdr.status);\n    // sts could be: send_failed, channel_closed, peer_disconnected\n}\n</code></pre>"},{"location":"mds/message-flows/#message-ownership","title":"Message Ownership","text":"<p>Messages move between you and tofu.</p>"},{"location":"mds/message-flows/#after-post","title":"After post()","text":"<pre><code>var msg: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;msg);  // Safe - put() handles null\n\n// ... fill message ...\n\n_ = try chnls.post(&amp;msg);\n// msg is now null - tofu owns it\n// defer will call put(null) which is a no-op\n</code></pre>"},{"location":"mds/message-flows/#after-waitreceive","title":"After waitReceive()","text":"<pre><code>var resp: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;resp);  // You must return it\n\n// You own the message until you put() it\n</code></pre> <p>defer handles both cases</p> <p>Always use <code>defer ampe.put(&amp;msg)</code> right after <code>get()</code>. It works whether you post (msg becomes null) or keep the message.</p>"},{"location":"mds/message-flows/#pool-empty-notification","title":"Pool Empty Notification","text":"<p>When the pool runs low, tofu sends a signal:</p> <pre><code>var msg: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;msg);\n\nif (msg.?.isFromEngine()) {\n    const sts = tofu.status.raw_to_status(msg.?.bhdr.status);\n    if (sts == .pool_empty) {\n        // Pool needs more messages\n        // The signal message itself goes back to pool via defer\n    }\n}\n</code></pre> NAQ: What should I do when pool is empty? <p>Return messages to pool faster. The <code>pool_empty</code> signal message itself goes back to pool when you <code>put()</code> it, which helps immediately.</p>"},{"location":"mds/message-flows/#channel-closed-notification","title":"Channel Closed Notification","text":"<p>When a channel closes (by you or peer), tofu notifies:</p> <pre><code>if (msg.?.isFromEngine()) {\n    const sts = tofu.status.raw_to_status(msg.?.bhdr.status);\n    if (sts == .channel_closed) {\n        const closed_ch = msg.?.bhdr.channel_number;\n        // Remove this channel from your tracking\n    }\n}\n</code></pre> <p>You get <code>channel_closed</code> for:</p> <ul> <li>ByeRequest/ByeResponse completion</li> <li>ByeSignal</li> <li>Peer disconnect</li> <li>Network failure</li> </ul>"},{"location":"mds/message-flows/#timeout-handling","title":"Timeout Handling","text":"<p><code>waitReceive()</code> can timeout:</p> <pre><code>var msg: ?*Message = try chnls.waitReceive(5 * tofu.waitReceive_SEC_TIMEOUT);\n\nif (msg == null) {\n    // Timeout - nothing received within 5 seconds\n}\n</code></pre> <p>Constants:</p> <ul> <li><code>waitReceive_INFINITE_TIMEOUT</code> - wait forever</li> <li><code>waitReceive_SEC_TIMEOUT</code> - 1 second</li> <li>Multiply for longer timeouts</li> </ul>"},{"location":"mds/message-flows/#main-loop-pattern","title":"Main Loop Pattern","text":"<p>A typical receive loop:</p> <pre><code>while (running) {\n    var msg: ?*Message = try chnls.waitReceive(tofu.waitReceive_SEC_TIMEOUT);\n\n    if (msg == null) {\n        // Timeout - do housekeeping, check shutdown flag\n        continue;\n    }\n\n    defer ampe.put(&amp;msg);\n\n    // Check origin first\n    if (msg.?.isFromEngine()) {\n        const sts = tofu.status.raw_to_status(msg.?.bhdr.status);\n        switch (sts) {\n            .pool_empty =&gt; continue,\n            .channel_closed =&gt; {\n                removeChannel(msg.?.bhdr.channel_number);\n                continue;\n            },\n            else =&gt; {\n                handleError(msg);\n                continue;\n            },\n        }\n    }\n\n    // Application message from peer\n    switch (msg.?.bhdr.proto.opCode) {\n        .HelloRequest =&gt; handleNewConnection(msg, chnls),\n        .Request =&gt; handleRequest(msg, chnls),\n        .Signal =&gt; handleSignal(msg),\n        .ByeRequest =&gt; handleClose(msg, chnls),\n        else =&gt; {},\n    }\n}\n</code></pre>"},{"location":"mds/message-flows/#summary","title":"Summary","text":"What you do What happens <code>post(&amp;msg)</code> Message goes to send queue, msg becomes null <code>waitReceive()</code> Returns next message from recv queue (or null on timeout) Success You get the expected response from peer Failure You get your message back with error status, origin=engine"},{"location":"mds/message/","title":"Message","text":"<p>A tofu message has three parts. Only the first is required.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  BinaryHeader   \u2502  \u2190 Always present (routing, type, status)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  TextHeaders    \u2502  \u2190 Optional (key-value metadata)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Body           \u2502  \u2190 Optional (your data)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"mds/message/#binaryheader","title":"BinaryHeader","text":"<p>The fixed-size header that tofu uses for routing and processing.</p> BinaryHeader structure<pre><code>pub const BinaryHeader = packed struct {\n    channel_number: u16 = 0,    // Which channel this message belongs to\n    proto: ProtoFields = .{},   // Operation type, origin, more flag\n    status: u8 = 0,             // 0 = success, else error code\n    message_id: u64 = 0,        // Your correlation ID\n    // (internal length fields omitted)\n};\n</code></pre>"},{"location":"mds/message/#channel_number","title":"channel_number","text":"<p>Identifies which channel this message belongs to.</p> Value Meaning <code>0</code> Not assigned yet (used for HelloRequest, WelcomeRequest) <code>1-65534</code> Valid assigned channel <code>65535</code> Reserved for tofu internal use <p>Only tofu assigns channel numbers</p> <p>You create messages with channel 0. tofu assigns a real number during <code>post()</code>. Save the returned number for future use.</p>"},{"location":"mds/message/#proto-protofields","title":"proto (ProtoFields)","text":"<p>Contains the operation type and flags.</p> ProtoFields structure<pre><code>pub const ProtoFields = packed struct(u8) {\n    opCode: OpCode,           // 4 bits: what type of message\n    origin: OriginFlag,       // 1 bit: from you or from tofu?\n    more: MoreMessagesFlag,   // 1 bit: more coming?\n    // (internal bits omitted)\n};\n</code></pre>"},{"location":"mds/message/#status","title":"status","text":"<p>The result code. Zero means success.</p> <pre><code>if (msg.?.bhdr.status == 0) {\n    // Success\n} else {\n    // Check what went wrong\n    const sts = status.raw_to_status(msg.?.bhdr.status);\n}\n</code></pre> <p>See Errors and Statuses for the full list.</p>"},{"location":"mds/message/#message_id","title":"message_id","text":"<p>Your correlation ID. tofu preserves it but doesn't interpret it.</p> <p>Use it to:</p> <ul> <li>Match responses to requests</li> <li>Track jobs across multiple messages</li> <li>Correlate progress updates with their job</li> </ul> <pre><code>// Send request with job ID\nrequest.?.bhdr.message_id = job_id;\n_ = try chnls.post(&amp;request);\n\n// Later, match response\nif (response.?.bhdr.message_id == job_id) {\n    // This is the response to our request\n}\n</code></pre> NAQ: What if I don't set message_id? <p>If you leave it at 0, tofu assigns a sequential process-unique number during <code>post()</code>. The assigned value is returned in the BinaryHeader from <code>post()</code>.</p>"},{"location":"mds/message/#opcode","title":"OpCode","text":"<p>The operation type. This tells tofu (and your peer) what the message means.</p> All OpCodes<pre><code>pub const OpCode = enum(u4) {\n    Request = 0,           // Ask peer for something\n    Response = 1,          // Answer to a request\n    Signal = 2,            // One-way notification\n    HelloRequest = 3,      // Client: \"I want to connect\"\n    HelloResponse = 4,     // Server: \"Connection accepted\"\n    ByeRequest = 5,        // \"Let's close gracefully\"\n    ByeResponse = 6,       // \"OK, closing\"\n    ByeSignal = 7,         // \"Close NOW\" (no response)\n    WelcomeRequest = 8,    // Server: \"Start listening\"\n    WelcomeResponse = 9,   // tofu: \"Listener ready\"\n};\n</code></pre>"},{"location":"mds/message/#grouping-by-purpose","title":"Grouping by purpose","text":"<p>Setup messages:</p> OpCode Who sends Purpose WelcomeRequest Server app Start listening for connections WelcomeResponse tofu Confirm listener is ready HelloRequest Client app Connect to a server HelloResponse Server app Accept the connection <p>Data messages (after connection):</p> OpCode Who sends Purpose Request Either peer Ask for something Response Either peer Answer a request Signal Either peer One-way notification <p>Close messages:</p> OpCode Who sends Purpose ByeRequest Either peer Start graceful close ByeResponse Either peer Acknowledge close ByeSignal Either peer Close immediately"},{"location":"mds/message/#setting-opcode","title":"Setting OpCode","text":"<pre><code>// For regular messages\nmsg.?.bhdr.proto.opCode = .Request;\n\n// For connection messages, use address helpers (they set opCode automatically)\nvar addr: Address = .{ .tcp_client_addr = address.TCPClientAddress.init(\"127.0.0.1\", 7099) };\ntry addr.format(msg.?);  // Sets opCode to .HelloRequest\n</code></pre>"},{"location":"mds/message/#origin-flag","title":"Origin Flag","text":"<p>Tells you where the message came from.</p> <pre><code>pub const OriginFlag = enum(u1) {\n    application = 0,  // From your code or peer's code\n    engine = 1,       // From tofu itself\n};\n</code></pre> <p>Why this matters:</p> <p>When you receive a message via <code>waitReceive()</code>, check origin first:</p> <pre><code>var msg = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;msg);\n\nif (msg.?.isFromEngine()) {\n    // This is a status notification from tofu\n    // Check status field for what happened\n    const sts = status.raw_to_status(msg.?.bhdr.status);\n    switch (sts) {\n        .pool_empty =&gt; { /* pool needs messages */ },\n        .channel_closed =&gt; { /* channel died */ },\n        else =&gt; {},\n    }\n} else {\n    // This is a message from your peer\n    // Process normally\n}\n</code></pre> <p>Always check origin first</p> <p>Engine messages mean something happened internally (pool empty, channel closed, send failed). Application messages are from your peer.</p>"},{"location":"mds/message/#more-flag","title":"More Flag","text":"<p>For streaming multiple messages as one logical unit.</p> <pre><code>pub const MoreMessagesFlag = enum(u1) {\n    last = 0,  // This is the final message\n    more = 1,  // More messages coming with same message_id\n};\n</code></pre> <p>Example: Sending a file in chunks</p> <pre><code>const job_id: u64 = getNextJobId();\n\nwhile (hasMoreChunks()) {\n    var msg = try ampe.get(.always);\n    defer ampe.put(&amp;msg);\n\n    msg.?.bhdr.proto.opCode = .Request;\n    msg.?.bhdr.channel_number = peer_channel;\n    msg.?.bhdr.message_id = job_id;  // Same for all chunks\n    msg.?.bhdr.proto.more = if (hasMoreChunks()) .more else .last;\n\n    try msg.?.body.append(getNextChunk());\n    _ = try chnls.post(&amp;msg);\n}\n</code></pre> <p>The receiver knows the stream is complete when <code>more == .last</code>.</p>"},{"location":"mds/message/#textheaders","title":"TextHeaders","text":"<p>Key-value pairs for structured metadata. Like HTTP headers.</p> Adding a header<pre><code>try msg.?.thdrs.append(\"Content-Type\", \"application/json\");\ntry msg.?.thdrs.append(\"Job-ID\", \"12345\");\n</code></pre> Reading headers<pre><code>var it = msg.?.thdrs.hiter();\nwhile (it.next()) |header| {\n    // header.name, header.value\n}\n</code></pre>"},{"location":"mds/message/#required-headers","title":"Required headers","text":"<p>Some messages require specific headers:</p> Message Required Header Example HelloRequest <code>~connect_to</code> <code>tcp\\|127.0.0.1\\|7099</code> WelcomeRequest <code>~listen_on</code> <code>tcp\\|0.0.0.0\\|7099</code> <p>Use address helpers</p> <p>Don't build these headers manually. Use the address helpers: <pre><code>var addr: Address = .{ .tcp_client_addr = address.TCPClientAddress.init(\"127.0.0.1\", 7099) };\ntry addr.format(msg.?);  // Adds the header for you\n</code></pre></p>"},{"location":"mds/message/#body","title":"Body","text":"<p>Binary payload for your application data.</p> Writing to body<pre><code>try msg.?.body.append(my_data);\n</code></pre> Reading body<pre><code>const data = msg.?.body.body().?;\nconst length = msg.?.actual_body_len();\n</code></pre> <p>The body can hold any binary data. tofu doesn't interpret it.</p> <p>Size limit: 64 KiB - 1</p> <p>Body and TextHeaders share the same size limit: 65535 bytes (64 KiB - 1). For larger data, use streaming with the <code>more</code> flag.</p>"},{"location":"mds/message/#creating-messages","title":"Creating Messages","text":""},{"location":"mds/message/#get-from-pool","title":"Get from pool","text":"<pre><code>var msg = try ampe.get(.always);\ndefer ampe.put(&amp;msg);  // Always use defer\n</code></pre>"},{"location":"mds/message/#set-up-for-sending","title":"Set up for sending","text":"Regular Request<pre><code>msg.?.bhdr.proto.opCode = .Request;\nmsg.?.bhdr.channel_number = peer_channel;\nmsg.?.bhdr.message_id = my_job_id;\ntry msg.?.body.append(my_data);\n</code></pre> HelloRequest (connecting)<pre><code>var addr: Address = .{ .tcp_client_addr = address.TCPClientAddress.init(\"127.0.0.1\", 7099) };\ntry addr.format(msg.?);  // Sets opCode and adds address header\n</code></pre> WelcomeRequest (listening)<pre><code>var addr: Address = .{ .tcp_server_addr = address.TCPServerAddress.init(\"0.0.0.0\", 7099) };\ntry addr.format(msg.?);  // Sets opCode and adds address header\n</code></pre>"},{"location":"mds/message/#submit-for-processing","title":"Submit for processing","text":"<pre><code>const bhdr = try chnls.post(&amp;msg);\n// msg is now null (tofu took it)\n// bhdr contains assigned channel_number and message_id\n</code></pre>"},{"location":"mds/message/#message-lifecycle","title":"Message Lifecycle","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         YOUR CODE                                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  1. msg = ampe.get(.always)     \u2190 Get from pool                  \u2502\n\u2502  2. Fill message (opCode, channel, body)                         \u2502\n\u2502  3. bhdr = chnls.post(&amp;msg)     \u2190 Submit (msg becomes null)      \u2502\n\u2502  4. resp = chnls.waitReceive()  \u2190 Wait for result                \u2502\n\u2502  5. ampe.put(&amp;resp)             \u2190 Return to pool                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Memory rules</p> <ol> <li>Always <code>defer ampe.put(&amp;msg)</code> right after getting a message</li> <li>After <code>post()</code>, msg becomes null (tofu owns it)</li> <li>defer is still safe (put ignores null)</li> <li>Always return received messages to pool</li> </ol>"},{"location":"mds/message/#quick-reference","title":"Quick Reference","text":""},{"location":"mds/message/#check-message-type","title":"Check message type","text":"<pre><code>switch (msg.?.bhdr.proto.opCode) {\n    .HelloRequest =&gt; { /* new connection */ },\n    .Request =&gt; { /* peer wants something */ },\n    .Signal =&gt; { /* notification */ },\n    // ...\n}\n</code></pre>"},{"location":"mds/message/#check-origin","title":"Check origin","text":"<pre><code>if (msg.?.isFromEngine()) {\n    // From tofu (status notification)\n} else {\n    // From peer (application message)\n}\n</code></pre>"},{"location":"mds/message/#check-if-streaming","title":"Check if streaming","text":"<pre><code>if (msg.?.hasMore()) {\n    // More messages coming with same message_id\n}\n</code></pre>"},{"location":"mds/message/#get-helper-methods","title":"Get helper methods","text":"<pre><code>msg.?.bhdr.proto.getType()  // MessageType: .welcome, .hello, .regular, .bye\nmsg.?.bhdr.proto.getRole()  // MessageRole: .request, .response, .signal\n</code></pre>"},{"location":"mds/naq/","title":"NAQ","text":"What's NAQ? <p>I always wondered why even if the program is not used by anyone, there is still a FAQ section. Even if a question was asked once, why 'frequently'? That's why I use a more honest name: NAQ - Never Asked Questions. I ask myself. I answer myself. You didn't ask. Not even about NAQ.</p> <p>You will see 'NAQ' sections in different places throughout this documentation. I hope they will help clarify the content of the documentation.</p>"},{"location":"mds/overview/","title":"Overview","text":"<p>tofu is a protocol and an asynchronous Zig messaging library used to:</p> <ul> <li>Build custom communication flows.</li> <li>Create non-blocking systems.</li> <li>Enable peer-to-peer messaging between applications.</li> </ul> <p>tofu is a completely new project. It is not a port of old code, and it does not use any C libraries. It is built 100% in native Zig. The core functionality uses only the standard library.</p>"},{"location":"mds/overview/#why-tofu","title":"Why tofu?","text":"<p>As a food, tofu is simple and doesn\u2019t have much flavor on its own. With tofu cubes, you can:</p> <ul> <li>Eat them plain as an easy snack.</li> <li>Add some spice to make them better.</li> <li>Cook up something really tasty.</li> </ul> <p>As a protocol, tofu uses messages like cubes. By \"cooking\" these messages together, you can grow your project:</p> <ul> <li>Start with minimal setups.</li> <li>Build complex flows.</li> <li>Create full distributed applications.</li> </ul> <p>Remember</p> <p>tofu is as good as you are a cook.</p>"},{"location":"mds/overview/#a-bit-of-history","title":"A Bit of History","text":"<p>tofu did not come from nowhere.</p> <p>The journey began in 2008 when I first built a similar system. I maintained and ran that system for many years in high-stakes environments. It powered everything from basic IPC to complex data transfers in a custom distributed file system.</p> <p>I left that project a few years ago, but I haven't heard any complaints yet \u2014 the systems are still running strong.</p> <p>Corporate lawyers can stay calm: I didn't take any code. I only took the \"smell.\" (See the precedent case about paying for a smell).</p> <p>By \"smell,\" I mean the core philosophy:</p> <ul> <li>The Message is the API: The data itself defines the connection.</li> <li>Gradual Evolution: Start with something simple and grow it into a powerful system over time.</li> <li>The Mantra: \"Connect your developers. Then connect your applications.\"</li> </ul>"},{"location":"mds/overview/#credits","title":"Credits","text":"<ul> <li>Karl Seguin \u2014 for introducing me to Zig networking</li> <li>Franck Blettner \u2014 for creating the template repository for documentation sites, which this documentation is based on </li> <li>Zig Community Forums (in order of my registration) - for your help and patience with my posts<ul> <li>Zig on Reddit</li> <li>Zig on Discord</li> <li>Zig on Discourse</li> </ul> </li> </ul>"},{"location":"mds/overview/#last-but-not-least","title":"Last but not least","text":"<p>\u2b50\ufe0f Like, share, and don\u2019t forget to subscribe to the channel !</p>"},{"location":"mds/patterns/","title":"Patterns","text":"<p>Common patterns for tofu applications.</p>"},{"location":"mds/patterns/#requestresponse","title":"Request/Response","text":"<p>The basic pattern. Client sends Request, server sends Response.</p> <pre><code>// Client\nvar req: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;req);\n\nreq.?.bhdr.proto.opCode = .Request;\nreq.?.bhdr.channel_number = server_ch;\nreq.?.bhdr.message_id = job_id;\ntry req.?.body.append(request_data);\n\n_ = try chnls.post(&amp;req);\n\n// Wait for response\nvar resp: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;resp);\n\nif (resp.?.bhdr.message_id == job_id) {\n    // This is our response\n}\n</code></pre> <pre><code>// Server\nvar msg: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;msg);\n\nif (msg.?.bhdr.proto.opCode == .Request) {\n    // Process request\n    const result = process(msg.?.body.body().?);\n\n    // Reuse message for response\n    msg.?.bhdr.proto.opCode = .Response;\n    msg.?.body.clear();\n    try msg.?.body.append(result);\n\n    _ = try chnls.post(&amp;msg);\n}\n</code></pre>"},{"location":"mds/patterns/#correlation","title":"Correlation","text":"<p>Use <code>message_id</code> to match responses to requests.</p> <pre><code>// Track pending requests\nvar pending = std.AutoHashMap(u64, RequestInfo).init(allocator);\ndefer pending.deinit();\n\n// Send request\nvar req: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;req);\n\nreq.?.bhdr.proto.opCode = .Request;\nreq.?.bhdr.channel_number = server_ch;\nreq.?.bhdr.message_id = nextJobId();\n\ntry pending.put(req.?.bhdr.message_id, .{ .sent_at = now() });\n\n_ = try chnls.post(&amp;req);\n\n// Later, match response\nvar resp: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;resp);\n\nif (pending.get(resp.?.bhdr.message_id)) |info| {\n    // Found the matching request\n    _ = pending.remove(resp.?.bhdr.message_id);\n    handleResponse(resp, info);\n}\n</code></pre> <p>tofu assigns message_id if you don't</p> <p>If you leave <code>message_id</code> at 0, tofu assigns a unique value during <code>post()</code>. The assigned value is in the returned BinaryHeader.</p>"},{"location":"mds/patterns/#streaming-client-to-server","title":"Streaming (Client to Server)","text":"<p>Send multiple messages as one logical request. Use the <code>more</code> flag.</p> <pre><code>// Client: send file in chunks\nconst job_id = nextJobId();\nvar chunk_index: usize = 0;\n\nwhile (chunk_index &lt; chunks.len) {\n    var msg: ?*Message = try ampe.get(.always);\n    defer ampe.put(&amp;msg);\n\n    msg.?.bhdr.proto.opCode = .Request;\n    msg.?.bhdr.channel_number = server_ch;\n    msg.?.bhdr.message_id = job_id;  // Same for all chunks\n\n    // Set more flag\n    const is_last = (chunk_index == chunks.len - 1);\n    msg.?.bhdr.proto.more = if (is_last) .last else .more;\n\n    try msg.?.body.append(chunks[chunk_index]);\n    _ = try chnls.post(&amp;msg);\n\n    chunk_index += 1;\n}\n\n// Wait for single response\nvar resp: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;resp);\n</code></pre> <pre><code>// Server: receive streamed request\nvar buffer = std.ArrayList(u8).init(allocator);\ndefer buffer.deinit();\n\nwhile (true) {\n    var msg: ?*Message = try chnls.waitReceive(timeout);\n    defer ampe.put(&amp;msg);\n\n    if (msg.?.bhdr.proto.opCode == .Request) {\n        try buffer.appendSlice(msg.?.body.body().?);\n\n        if (!msg.?.hasMore()) {\n            // Last chunk - process complete data\n            const result = process(buffer.items);\n\n            // Send response\n            msg.?.bhdr.proto.opCode = .Response;\n            msg.?.body.clear();\n            try msg.?.body.append(result);\n            _ = try chnls.post(&amp;msg);\n            break;\n        }\n    }\n}\n</code></pre>"},{"location":"mds/patterns/#streaming-server-to-client","title":"Streaming (Server to Client)","text":"<p>Server sends multiple response messages for one request.</p> <pre><code>// Server: stream response\nvar msg: ?*Message = try chnls.waitReceive(timeout);\nconst client_ch = msg.?.bhdr.channel_number;\nconst job_id = msg.?.bhdr.message_id;\nampe.put(&amp;msg);\n\n// Send multiple response chunks\nvar chunk_index: usize = 0;\nwhile (chunk_index &lt; result_chunks.len) {\n    var resp: ?*Message = try ampe.get(.always);\n    defer ampe.put(&amp;resp);\n\n    resp.?.bhdr.proto.opCode = .Response;\n    resp.?.bhdr.channel_number = client_ch;\n    resp.?.bhdr.message_id = job_id;\n\n    const is_last = (chunk_index == result_chunks.len - 1);\n    resp.?.bhdr.proto.more = if (is_last) .last else .more;\n\n    try resp.?.body.append(result_chunks[chunk_index]);\n    _ = try chnls.post(&amp;resp);\n\n    chunk_index += 1;\n}\n</code></pre> <pre><code>// Client: receive streamed response\nvar buffer = std.ArrayList(u8).init(allocator);\ndefer buffer.deinit();\n\nwhile (true) {\n    var resp: ?*Message = try chnls.waitReceive(timeout);\n    defer ampe.put(&amp;resp);\n\n    if (resp.?.bhdr.message_id == job_id) {\n        try buffer.appendSlice(resp.?.body.body().?);\n\n        if (!resp.?.hasMore()) {\n            // Complete response received\n            break;\n        }\n    }\n}\n</code></pre>"},{"location":"mds/patterns/#progress-updates","title":"Progress Updates","text":"<p>Use Signal for one-way notifications during long operations.</p> <pre><code>// Server: send progress while processing\nfn processWithProgress(chnls: ChannelGroup, ampe: Ampe, client_ch: u16, job_id: u64, data: []const u8) !void {\n    const total_steps = 10;\n\n    for (0..total_steps) |step| {\n        // Do work\n        doStep(step, data);\n\n        // Send progress signal\n        var sig: ?*Message = try ampe.get(.always);\n        defer ampe.put(&amp;sig);\n\n        sig.?.bhdr.proto.opCode = .Signal;\n        sig.?.bhdr.channel_number = client_ch;\n        sig.?.bhdr.message_id = job_id;\n\n        // Progress in body (your format)\n        const progress = @as(u8, @intCast((step + 1) * 100 / total_steps));\n        try sig.?.body.append(progress);\n\n        _ = try chnls.post(&amp;sig);\n    }\n\n    // Send final response\n    var resp: ?*Message = try ampe.get(.always);\n    defer ampe.put(&amp;resp);\n\n    resp.?.bhdr.proto.opCode = .Response;\n    resp.?.bhdr.channel_number = client_ch;\n    resp.?.bhdr.message_id = job_id;\n    try resp.?.body.append(\"done\");\n\n    _ = try chnls.post(&amp;resp);\n}\n</code></pre> <pre><code>// Client: receive progress and final response\nwhile (true) {\n    var msg: ?*Message = try chnls.waitReceive(timeout);\n    defer ampe.put(&amp;msg);\n\n    if (msg.?.bhdr.message_id != job_id) continue;\n\n    switch (msg.?.bhdr.proto.opCode) {\n        .Signal =&gt; {\n            const progress = msg.?.body.body().?[0];\n            std.debug.print(\"Progress: {}%\\n\", .{progress});\n        },\n        .Response =&gt; {\n            std.debug.print(\"Complete!\\n\", .{});\n            break;\n        },\n        else =&gt; {},\n    }\n}\n</code></pre> NAQ: Why Signal instead of Response for progress? <p>Response means \"answer to your request\". Signal means \"notification\". Progress is a notification, not an answer. The answer comes at the end.</p>"},{"location":"mds/patterns/#bidirectional-communication","title":"Bidirectional Communication","text":"<p>After connection, either peer can send Request/Response/Signal.</p> <pre><code>// Peer A sends request to Peer B\nvar reqToB: ?*Message = try ampe.get(.always);\nreqToB.?.bhdr.proto.opCode = .Request;\nreqToB.?.bhdr.channel_number = peerB_ch;\n_ = try chnls.post(&amp;reqToB);\n\n// Peer B sends request to Peer A (at the same time)\nvar reqToA: ?*Message = try ampe.get(.always);\nreqToA.?.bhdr.proto.opCode = .Request;\nreqToA.?.bhdr.channel_number = peerA_ch;\n_ = try chnls.post(&amp;reqToA);\n\n// Both receive each other's requests via waitReceive()\n</code></pre> <p>Peer symmetry</p> <p>After HelloRequest/HelloResponse, both sides are equal peers. Either can initiate requests. Your protocol decides who does what.</p> Bidirectional streaming <p>You saw client streaming (multiple requests \u2192 one response) and server streaming (one request \u2192 multiple responses).</p> <p>Both peers are symmetric. Both can use the <code>more</code> flag. Both can stream simultaneously.</p> <p>Bidirectional streaming? Combine what you learned. Good exercise for you.</p>"},{"location":"mds/patterns/#heartbeat","title":"Heartbeat","text":"<p>Keep connection alive with periodic signals.</p> <pre><code>// Sender thread\nfn heartbeatLoop(chnls: ChannelGroup, ampe: Ampe, peer_ch: u16) void {\n    while (running) {\n        var hb: ?*Message = ampe.get(.always) catch continue;\n        defer ampe.put(&amp;hb);\n\n        hb.?.bhdr.proto.opCode = .Signal;\n        hb.?.bhdr.channel_number = peer_ch;\n        // Empty body = heartbeat\n\n        _ = chnls.post(&amp;hb) catch break;\n\n        std.Thread.sleep(30 * std.time.ns_per_s);\n    }\n}\n</code></pre> <pre><code>// Receiver: detect missing heartbeat\nvar last_seen = std.time.timestamp();\n\nwhile (true) {\n    var msg: ?*Message = try chnls.waitReceive(10 * tofu.waitReceive_SEC_TIMEOUT);\n\n    if (msg == null) {\n        // Timeout\n        if (std.time.timestamp() - last_seen &gt; 60) {\n            // No message for 60 seconds - peer dead?\n            break;\n        }\n        continue;\n    }\n\n    defer ampe.put(&amp;msg);\n    last_seen = std.time.timestamp();\n\n    // Process message...\n}\n</code></pre>"},{"location":"mds/patterns/#multiple-clients","title":"Multiple Clients","text":"<p>Server tracks each client by channel number.</p> <pre><code>const ClientInfo = struct {\n    channel: u16,\n    connected_at: i64,\n    // ... your data ...\n};\n\nvar clients = std.AutoHashMap(u16, ClientInfo).init(allocator);\ndefer clients.deinit();\n\nwhile (true) {\n    var msg: ?*Message = try chnls.waitReceive(timeout);\n    defer ampe.put(&amp;msg);\n\n    const ch = msg.?.bhdr.channel_number;\n\n    // Handle engine notifications\n    if (msg.?.isFromEngine()) {\n        const sts = tofu.status.raw_to_status(msg.?.bhdr.status);\n        if (sts == .channel_closed) {\n            _ = clients.remove(ch);\n        }\n        continue;\n    }\n\n    switch (msg.?.bhdr.proto.opCode) {\n        .HelloRequest =&gt; {\n            // New client\n            try clients.put(ch, .{\n                .channel = ch,\n                .connected_at = std.time.timestamp(),\n            });\n\n            msg.?.bhdr.proto.opCode = .HelloResponse;\n            _ = try chnls.post(&amp;msg);\n        },\n        .Request =&gt; {\n            if (clients.get(ch)) |client| {\n                // Known client\n                handleRequest(msg, client);\n            }\n        },\n        else =&gt; {},\n    }\n}\n</code></pre>"},{"location":"mds/patterns/#transport-agnostic-code","title":"Transport-Agnostic Code","text":"<p>Write code that works with any transport (TCP, UDS) by accepting <code>*Address</code> as parameter.</p> <pre><code>// Same function works for TCP and UDS\npub fn startListener(ampe: Ampe, chnls: ChannelGroup, addr: *Address) !u16 {\n    var msg: ?*Message = try ampe.get(.always);\n    defer ampe.put(&amp;msg);\n\n    try addr.format(msg.?);  // Works with any address type\n\n    const bhdr = try chnls.post(&amp;msg);\n    const listener_ch = bhdr.channel_number;\n\n    var resp: ?*Message = try chnls.waitReceive(tofu.waitReceive_INFINITE_TIMEOUT);\n    defer ampe.put(&amp;resp);\n\n    if (resp.?.bhdr.status != 0) {\n        return error.ListenerFailed;\n    }\n\n    return listener_ch;\n}\n\n// Usage\nvar tcp_addr: Address = .{ .tcp_server_addr = address.TCPServerAddress.init(\"0.0.0.0\", 8080) };\nvar uds_addr: Address = .{ .uds_server_addr = address.UDSServerAddress.init(\"/tmp/myapp.sock\") };\n\nconst tcp_ch = try startListener(ampe, chnls, &amp;tcp_addr);\nconst uds_ch = try startListener(ampe, chnls, &amp;uds_addr);\n</code></pre>"},{"location":"mds/patterns/#summary","title":"Summary","text":"Pattern Messages Used Use Case Request/Response Request \u2192 Response Single question/answer Streaming (client) Request (more=1) ... Request (more=0) \u2192 Response Upload file in chunks Streaming (server) Request \u2192 Response (more=1) ... Response (more=0) Download file in chunks Streaming (bidi) Both use <code>more</code> flag simultaneously Real-time data exchange Progress Request \u2192 Signal ... Signal \u2192 Response Long operation with updates Heartbeat Signal (periodic) Keep-alive Bidirectional Request \u2194 Request Both sides initiate"},{"location":"mds/protocol-operations/","title":"Protocol Operations","text":"<p>tofu has 10 operations. Each operation is a specific message type.</p>"},{"location":"mds/protocol-operations/#terminology","title":"Terminology","text":"Term What it is OpCode The 4-bit identifier for an operation Message Type The domain: <code>welcome</code>, <code>hello</code>, <code>regular</code>, <code>bye</code> Message Role The pattern: <code>request</code>, <code>response</code>, <code>signal</code> <p>An operation = type + role. Example: <code>HelloRequest</code> = hello type + request role.</p>"},{"location":"mds/protocol-operations/#all-operations","title":"All Operations","text":"<pre><code>pub const OpCode = enum(u4) {\n    Request = 0,\n    Response = 1,\n    Signal = 2,\n    HelloRequest = 3,\n    HelloResponse = 4,\n    ByeRequest = 5,\n    ByeResponse = 6,\n    ByeSignal = 7,\n    WelcomeRequest = 8,\n    WelcomeResponse = 9,\n};\n</code></pre>"},{"location":"mds/protocol-operations/#setup-operations","title":"Setup Operations","text":"<p>These operations establish connections. They happen before regular data exchange.</p>"},{"location":"mds/protocol-operations/#welcomerequest-opcode-8","title":"WelcomeRequest (OpCode 8)","text":"<p>Server sends this to start listening.</p> Aspect Value Transferred? No. Local only (app \u2194 tofu). Channel Created with 0. tofu assigns a listener channel. Direction Server app \u2192 tofu Response WelcomeResponse <pre><code>var msg = try ampe.get(.always);\ndefer ampe.put(&amp;msg);\n\nvar addr: Address = .{ .tcp_server_addr = address.TCPServerAddress.init(\"0.0.0.0\", 7099) };\ntry addr.format(msg.?);\n\nconst bhdr = try chnls.post(&amp;msg);\nconst listener_ch = bhdr.channel_number;  // Save this\n</code></pre> NAQ: Why is WelcomeRequest not transferred? <p>It's a local setup command. You tell your local tofu \"start listening\". No network involved yet. The listener channel accepts future connections.</p>"},{"location":"mds/protocol-operations/#welcomeresponse-opcode-9","title":"WelcomeResponse (OpCode 9)","text":"<p>tofu sends this to confirm listener is ready.</p> Aspect Value Transferred? No. Local only. Channel Same listener channel from WelcomeRequest. Direction tofu \u2192 server app Received via <code>waitReceive()</code> <pre><code>var resp = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;resp);\n\nif (resp.?.bhdr.proto.opCode == .WelcomeResponse) {\n    // Listener is ready\n    if (resp.?.bhdr.status != 0) {\n        // Failed to start listener\n    }\n}\n</code></pre>"},{"location":"mds/protocol-operations/#hellorequest-opcode-3","title":"HelloRequest (OpCode 3)","text":"<p>Client sends this to connect to a server.</p> Aspect Value Transferred? Yes. Goes over network. Channel Client creates with 0. tofu assigns on both sides. Direction Client app \u2192 network \u2192 server app Response HelloResponse (or ByeSignal on reject) <p>Client side: <pre><code>var msg = try ampe.get(.always);\ndefer ampe.put(&amp;msg);\n\nvar addr: Address = .{ .tcp_client_addr = address.TCPClientAddress.init(\"127.0.0.1\", 7099) };\ntry addr.format(msg.?);\n\nconst bhdr = try chnls.post(&amp;msg);\nconst peer_ch = bhdr.channel_number;  // Save this for all future messages\n</code></pre></p> <p>Server side (receives HelloRequest): <pre><code>var req = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;req);\n\nif (req.?.bhdr.proto.opCode == .HelloRequest) {\n    const client_ch = req.?.bhdr.channel_number;  // Server's local channel for this client\n    // Decide: accept or reject?\n}\n</code></pre></p> NAQ: Why do client and server have different channel numbers? <p>Each side has its own channel table. tofu maps between them automatically. Client's channel 7 might be server's channel 12. You don't need to care.</p>"},{"location":"mds/protocol-operations/#helloresponse-opcode-4","title":"HelloResponse (OpCode 4)","text":"<p>Server sends this to accept a connection.</p> Aspect Value Transferred? Yes. Goes over network. Channel Server uses its local channel for this client. Direction Server app \u2192 network \u2192 client app Effect Connection established. Both sides are now peers. <p>After HelloResponse</p> <p>Both sides become equal peers. Either can send Request, Response, or Signal. The original client/server distinction is gone.</p> <p>Server sends: <pre><code>var resp = try ampe.get(.always);\ndefer ampe.put(&amp;resp);\n\nresp.?.bhdr.proto.opCode = .HelloResponse;\nresp.?.bhdr.channel_number = client_ch;  // From HelloRequest\n_ = try chnls.post(&amp;resp);\n</code></pre></p> <p>Client receives: <pre><code>var resp = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;resp);\n\nif (resp.?.bhdr.proto.opCode == .HelloResponse) {\n    // Connected. Use peer_ch for all communication.\n}\n</code></pre></p>"},{"location":"mds/protocol-operations/#data-operations","title":"Data Operations","text":"<p>After connection, peers exchange data using these operations.</p>"},{"location":"mds/protocol-operations/#request-opcode-0","title":"Request (OpCode 0)","text":"<p>Ask the peer for something. Expects a Response.</p> Aspect Value Transferred? Yes Channel Existing peer channel Direction Either peer \u2192 other peer Response Usually Response (app decides) Streaming Supports <code>more</code> flag for multi-message requests <pre><code>var msg = try ampe.get(.always);\ndefer ampe.put(&amp;msg);\n\nmsg.?.bhdr.proto.opCode = .Request;\nmsg.?.bhdr.channel_number = peer_ch;\nmsg.?.bhdr.message_id = job_id;\ntry msg.?.body.append(request_data);\n\n_ = try chnls.post(&amp;msg);\n</code></pre>"},{"location":"mds/protocol-operations/#response-opcode-1","title":"Response (OpCode 1)","text":"<p>Answer to a Request.</p> Aspect Value Transferred? Yes Channel Existing peer channel Direction Either peer \u2192 other peer Correlation Use same <code>message_id</code> as Request Streaming Supports <code>more</code> flag for multi-message responses <pre><code>var msg = try ampe.get(.always);\ndefer ampe.put(&amp;msg);\n\nmsg.?.bhdr.proto.opCode = .Response;\nmsg.?.bhdr.channel_number = requester_ch;\nmsg.?.bhdr.message_id = request.?.bhdr.message_id;  // Same ID\ntry msg.?.body.append(response_data);\n\n_ = try chnls.post(&amp;msg);\n</code></pre>"},{"location":"mds/protocol-operations/#signal-opcode-2","title":"Signal (OpCode 2)","text":"<p>One-way notification. No response expected.</p> Aspect Value Transferred? Yes Channel Existing peer channel Direction Either peer \u2192 other peer Response None expected Use cases Progress updates, events, notifications <pre><code>var msg = try ampe.get(.always);\ndefer ampe.put(&amp;msg);\n\nmsg.?.bhdr.proto.opCode = .Signal;\nmsg.?.bhdr.channel_number = peer_ch;\nmsg.?.bhdr.message_id = job_id;  // To correlate with a job\ntry msg.?.body.append(progress_data);\n\n_ = try chnls.post(&amp;msg);\n</code></pre> NAQ: When should I use Signal vs Request? <p>Use Signal when you don't need a response. Progress updates, heartbeats, events. Use Request when you expect the peer to send something back.</p>"},{"location":"mds/protocol-operations/#close-operations","title":"Close Operations","text":"<p>These operations end connections.</p>"},{"location":"mds/protocol-operations/#byerequest-opcode-5","title":"ByeRequest (OpCode 5)","text":"<p>Start a graceful close. Waits for pending messages to send.</p> Aspect Value Transferred? Yes Channel Channel to close Direction Either peer \u2192 other peer Response ByeResponse Behavior Queued after pending messages <pre><code>var msg = try ampe.get(.always);\ndefer ampe.put(&amp;msg);\n\nmsg.?.bhdr.proto.opCode = .ByeRequest;\nmsg.?.bhdr.channel_number = peer_ch;\n\n_ = try chnls.post(&amp;msg);\n// Wait for ByeResponse\n</code></pre>"},{"location":"mds/protocol-operations/#byeresponse-opcode-6","title":"ByeResponse (OpCode 6)","text":"<p>Acknowledge graceful close.</p> Aspect Value Transferred? Yes Channel Same channel as ByeRequest Direction Responder \u2192 initiator Effect Channel closed on both sides <pre><code>// Received ByeRequest\nvar resp = try ampe.get(.always);\ndefer ampe.put(&amp;resp);\n\nresp.?.bhdr.proto.opCode = .ByeResponse;\nresp.?.bhdr.channel_number = requester_ch;\n\n_ = try chnls.post(&amp;resp);\n// Channel closes after send\n</code></pre>"},{"location":"mds/protocol-operations/#byesignal-opcode-7","title":"ByeSignal (OpCode 7)","text":"<p>Abruptive close</p> <p>ByeSignal discards pending messages and closes the socket immediately. Use only when you need to abort, not for normal shutdown.</p> <p>Close immediately. No response. Discards pending messages.</p> Aspect Value Transferred? No. Local only. Channel Channel to abort Direction App \u2192 local tofu Response None (channel_closed from engine) Behavior Inserted at head of queue. Aborts socket. <pre><code>var msg = try ampe.get(.always);\ndefer ampe.put(&amp;msg);\n\nmsg.?.bhdr.proto.opCode = .ByeSignal;\nmsg.?.bhdr.channel_number = peer_ch;\n\n_ = try chnls.post(&amp;msg);\n// Channel closes immediately\n// Receive channel_closed from engine\n</code></pre> NAQ: When should I use ByeSignal vs ByeRequest? <p>ByeRequest: Graceful. Finishes pending work. Use for normal shutdown. ByeSignal: Immediate. Discards pending messages. Use for errors, timeouts, rejection.</p>"},{"location":"mds/protocol-operations/#quick-reference","title":"Quick Reference","text":"OpCode Name Transferred Direction Purpose 8 WelcomeRequest No App \u2192 tofu Start listener 9 WelcomeResponse No tofu \u2192 App Confirm listener 3 HelloRequest Yes Client \u2192 Server Connect 4 HelloResponse Yes Server \u2192 Client Accept connection 0 Request Yes Peer \u2194 Peer Ask for something 1 Response Yes Peer \u2194 Peer Answer request 2 Signal Yes Peer \u2194 Peer One-way notification 5 ByeRequest Yes Peer \u2194 Peer Graceful close 6 ByeResponse Yes Peer \u2194 Peer Acknowledge close 7 ByeSignal No App \u2192 tofu Immediate close"},{"location":"mds/sockets101/","title":"Sockets 101","text":"NAQ: Why \u201c101\u201d? <p>It\u2019s 100% built by AI \u2014 and 1% by the project\u2019s author.</p> <p>Because tofu uses sockets under the hood, you still need to understand:</p> <ul> <li>the addressing scheme</li> <li>the correct order of creating sockets</li> <li>the difference between client and server sides</li> <li>socket tuning</li> </ul>"},{"location":"mds/sockets101/#what-is-a-socket","title":"What is a Socket?","text":"<p>A socket is a software endpoint. It lets two programs communicate. This can be on the same computer or across a network.</p>"},{"location":"mds/sockets101/#stream-oriented-sockets","title":"Stream-Oriented Sockets","text":"<p>These use a reliable, ordered, connection-based protocol. TCP (Transmission Control Protocol) is the main example. Data is sent as a continuous stream of bytes. It guarantees all data arrives correctly.</p>"},{"location":"mds/sockets101/#socket-families-protocols","title":"Socket Families (Protocols)","text":"<p>Sockets use different communication protocol families.</p>"},{"location":"mds/sockets101/#1-tcpip-sockets","title":"1. TCP/IP Sockets","text":"<p>For network communication. Uses IP addresses to identify machines. TCP/IP is the foundation of the internet.</p>"},{"location":"mds/sockets101/#2-unix-domain-sockets-uds","title":"2. Unix Domain Sockets (UDS)","text":"<p>For local communication only. Works on the same computer. No network hardware needed. Often faster than TCP/IP for local processes.</p>"},{"location":"mds/sockets101/#socket-operations","title":"Socket Operations","text":"<p>Sockets follow this lifecycle.</p>"},{"location":"mds/sockets101/#1-create","title":"1. Create","text":"<p>First step: create the socket. This reserves system resources. Gives you a handle (file descriptor) for later use.</p>"},{"location":"mds/sockets101/#2-client-connect","title":"2. Client: Connect","text":"<p>Client uses connect(). Links its socket to the server's address. If successful, communication stream opens.</p>"},{"location":"mds/sockets101/#3-server-listen-and-accept","title":"3. Server: Listen and Accept","text":"<p>Server waits for client connections.</p> <ul> <li>Bind: Attach socket to specific local address.</li> <li>Listen: Wait for incoming connection requests.</li> <li>Accept: When client connects, accept() returns.<ul> <li>Creates a second, new socket.</li> <li>Original socket stays as listener.</li> <li>New socket handles data with that client.</li> </ul> </li> </ul>"},{"location":"mds/sockets101/#4-disconnect-close","title":"4. Disconnect (Close)","text":"<p>Communication ends when socket closes.</p> <ul> <li>Graceful close: Clean shutdown, data sent completely.</li> <li>Non-graceful close: Sudden close, data may be lost.</li> </ul>"},{"location":"mds/sockets101/#addresses-tcpip","title":"Addresses - TCP/IP","text":"<p>TCP/IP addresses combine IP address + port number.</p>"},{"location":"mds/sockets101/#server-address-bind","title":"Server Address (Bind)","text":"<p>Server binds to local IP address. Uses fixed port number (22, 80, 443).</p> <p>Specific Adapter: 192.168.1.10:80 - Only accepts connections to that IP.</p> <p>All Adapters (Wildcard): 0.0.0.0:8080 - Listens on all network cards on port 8080.</p>"},{"location":"mds/sockets101/#client-address-connect","title":"Client Address (Connect)","text":"<p>Client uses server's IP or hostname + port. Client gets temporary ephemeral port automatically.</p> <p>Example: Client connects to 192.168.1.10:80 Client local: 10.0.0.5:54321 (ephemeral port)</p>"},{"location":"mds/sockets101/#addresses-unix-domain-sockets-uds","title":"Addresses - Unix Domain Sockets (UDS)","text":"<p>No IP addresses or ports.</p> <p>Uses file system path instead. Example: /tmp/service.sock</p> <p>Server binds to path. Client connects to same path.</p>"},{"location":"mds/sockets101/#how-linux-tracks-sockets","title":"How Linux Tracks Sockets","text":""},{"location":"mds/sockets101/#file-descriptor-fd-socket-handle","title":"File Descriptor (FD) = Socket Handle","text":"<p>Every socket gets a small number (FD). Like an ID for your program. Example: socket_fd = 5</p> <p>Use it to read/write/close: send(5, ...), close(5)</p>"},{"location":"mds/sockets101/#fd-is-unique-only-inside-one-process","title":"FD is unique only inside one process","text":"<p>Process A: FD=3 Process B: FD=3 (different socket) OS uses (PID + FD) to identify real socket.</p>"},{"location":"mds/sockets101/#socket-tuning-with-options","title":"Socket tuning with options","text":""},{"location":"mds/sockets101/#reuse-port-quickly-so_reuseaddr-option","title":"Reuse Port Quickly - SO_REUSEADDR option","text":"<p>When TCP connection closes, socket enters TIME_WAIT state. Lasts 1-4 minutes.</p> <p>During TIME_WAIT: - System blocks new program from using same port.</p> <p>Problems: - Cannot restart server fast. - Testing slow (start/stop many times).</p> <p>SO_REUSEADDR fixes this.</p> <p>tofu sets SO_REUSEADDR on all listening sockets.</p> <p>Result: Every new tofu TCP server uses same port immediately.</p>"},{"location":"mds/sockets101/#socket-closing-modes-so_linger-option","title":"Socket closing modes - SO_LINGER option","text":"<p>Normal socket close:</p> <ul> <li>close() returns right away</li> <li>System sends remaining data in background (graceful close)</li> </ul> <p>SO_LINGER changes this.</p> <p>tofu uses only non-graceful (hard) close:</p> <ul> <li>close() returns immediately</li> <li>Connection closes instantly (reset)</li> <li>All unsent data discarded</li> </ul> <p>To shut down gracefully, use these tofu features instead:</p> <ul> <li>ByeRequest from peer A to peer B</li> <li>ByeResponse from peer B back to peer A</li> <li>After that, peer B\u2019s engine closes the socket immediately (not gracefully)</li> <li>Finally, both peers get a channel_closed status from their own engine.</li> </ul>"},{"location":"mds/statuses/","title":"Errors and Statuses","text":"<p>Tofu defines own error set: Partial tofu error set<pre><code>pub const AmpeError = error{\n    NotImplementedYet,\n    WrongConfiguration,\n    NotAllowed,\n    NullMessage,\n    ............\n    PoolEmpty,\n    AllocationFailed,\n    ............\n    ShutdownStarted,\n    ProcessingFailed, \n    UnknownError,\n};\n</code></pre> There is also enumerator for statuses: Partial tofu statuses<pre><code>pub const AmpeStatus = enum(u8) {\n    success = 0,\n    not_implemented_yet,\n    wrong_configuration,\n    not_allowed,\n    null_message,\n    ............\n    pool_empty,\n    allocation_failed,\n    ............\n    shutdown_started,\n    ............\n    processing_failed,\n    unknown_error,\n};\n</code></pre></p> <p>Every AmpeError has corresponding AmpeStatus enumerator (except 'success').</p> <p>Errors and Statuses have self-described names which I hope means I don\u2019t have to describe each one separately.</p> <p>To jump ahead a bit, this system allows errors to be transmitted as part of Message, using just 1 byte (u8).</p> <p>You can use helper function <code>status.raw_to_error(rs: u8) AmpeError!void</code> in order to convert byte to corresponding error.</p> <p>Not every non-zero status means an error right away. It depends on the situation. For example, 'channel_closed'</p> <ul> <li>is not an error if you requested to close the channel</li> <li>it is an error if it happens in the middle of communication</li> </ul>"},{"location":"mds/thinking-in-messages/","title":"Thinking in Messages","text":"<p>Read this first. The rest of the docs assume you understand this.</p>"},{"location":"mds/thinking-in-messages/#traditional-vs-tofu","title":"Traditional vs tofu","text":"<p>Traditional socket programming looks like this:</p> <pre><code>1. Create socket\n2. Connect to server\n3. Send data\n4. Receive response\n5. Close socket\n</code></pre> <p>tofu works differently:</p> <pre><code>1. Send HelloRequest (tofu connects for you)\n2. Send Request (tofu sends for you)\n3. Receive Response (tofu receives for you)\n4. Send ByeRequest (tofu closes for you)\n</code></pre> <p>You don't manage sockets. You send messages. tofu does the socket work.</p>"},{"location":"mds/thinking-in-messages/#messages-are-operations","title":"Messages Are Operations","text":"NAQ: Why does this matter? <p>If you think \"connect first, THEN send message\" - you'll fight tofu. If you think \"send a message that means 'connect'\" - you'll work with tofu. Same result. Different approach. The second one is easier.</p> <p>Traditional approach (wrong for tofu): <pre><code>socket = connect(address);\nsend(socket, data);\n</code></pre></p> <p>tofu approach (correct): <pre><code>// HelloRequest means \"connect to this address\"\n// You don't connect first. The message IS the connection request.\nconst bhdr = try chnls.post(&amp;helloRequest);\n</code></pre></p> <p>The HelloRequest doesn't just carry data. It IS the operation. tofu sees it and thinks: \"User wants to connect. Let me handle that.\"</p>"},{"location":"mds/thinking-in-messages/#intent-vs-implementation","title":"Intent vs Implementation","text":"<p>tofu separates what you want from how it happens.</p> You decide tofu handles \"I want to listen for connections\" Socket creation, binding, accepting \"I want to connect to server X\" Socket creation, DNS lookup, TCP handshake \"I want to send this data\" Serialization, write operations \"I want to close this connection\" Graceful shutdown, socket cleanup <p>You express intent through messages. tofu handles implementation.</p>"},{"location":"mds/thinking-in-messages/#the-four-message-operations","title":"The Four Message Operations","text":"<p>Every tofu operation maps to a message:</p> Intent Message Start listening WelcomeRequest Connect to peer HelloRequest Send data Request / Response / Signal Close connection ByeRequest or ByeSignal <p>There's no <code>connect()</code> function</p> <p>tofu doesn't have a connect function. You send a HelloRequest that contains the server address. tofu sees it, connects, and sends the message. One operation, not two.</p>"},{"location":"mds/thinking-in-messages/#the-basic-pattern","title":"The Basic Pattern","text":"<p>Almost everything follows this flow:</p> <pre><code>// 1. Get a message\nvar msg = try ampe.get(.always);\ndefer ampe.put(&amp;msg);\n\n// 2. Fill it in (set opCode, channel, data)\nmsg.?.bhdr.proto.opCode = .Request;\nmsg.?.bhdr.channel_number = peer_channel;\ntry msg.?.body.append(my_data);\n\n// 3. Submit it\nconst bhdr = try chnls.post(&amp;msg);\n\n// 4. Wait for result\nvar response = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;response);\n</code></pre> <p>Four APIs. That's all you need:</p> <ul> <li><code>ampe.get()</code> \u2014 get a message to work with</li> <li><code>ampe.put()</code> \u2014 return a message when done</li> <li><code>chnls.post()</code> \u2014 submit a message for processing</li> <li><code>chnls.waitReceive()</code> \u2014 receive incoming messages</li> </ul>"},{"location":"mds/thinking-in-messages/#peer-symmetry","title":"Peer Symmetry","text":"<p>Here's something that surprises people coming from traditional client/server.</p> <p>Before connection: <pre><code>Server: Waiting for clients (has WelcomeRequest)\nClient: Wants to connect (sends HelloRequest)\n</code></pre></p> <p>After connection: <pre><code>Peer A and Peer B\nBoth can send Request, Response, Signal\nBoth can initiate close\nNo more \"client\" or \"server\"\n</code></pre></p> <p>Once HelloRequest/HelloResponse completes, both sides are equal. Either can send any message type. Either can close the connection.</p> NAQ: But my server needs to send jobs to workers... <p>That's fine. Your protocol decides who sends what. tofu just gives you symmetric capabilities.</p> <p>The \"server\" can send Requests asking the \"client\" to do work. The \"client\" can send Signals with progress updates. Roles are your design choice, not a tofu constraint.</p>"},{"location":"mds/thinking-in-messages/#channels-virtual-connections","title":"Channels = Virtual Connections","text":"<p>A channel is tofu's abstraction for a connection.</p> <p>Two types:</p> <ul> <li>Listener channel \u2014 like a server socket, accepts incoming connections</li> <li>IO channel \u2014 like a connected socket, sends and receives messages</li> </ul> <p>Channel numbers:</p> <ul> <li><code>0</code> = not assigned yet (you use this for HelloRequest, WelcomeRequest)</li> <li><code>1-65534</code> = valid channels (assigned by tofu)</li> <li><code>65535</code> = reserved (don't use)</li> </ul> <p>Only tofu assigns channel numbers</p> <p>You create messages with channel 0. tofu assigns a real number during <code>post()</code>. Save it. You need it for all future messages to this peer.</p> <pre><code>// You send HelloRequest with channel 0\nmsg.?.bhdr.channel_number = 0;  // Not assigned yet\n\n// tofu assigns a channel and returns it\nconst bhdr = try chnls.post(&amp;msg);\nconst my_channel = bhdr.channel_number;  // Now assigned (e.g., 7)\n\n// Use this channel for all future messages to this peer\n</code></pre>"},{"location":"mds/thinking-in-messages/#async-by-default","title":"Async by Default","text":"<p>post() \u2260 sent</p> <p><code>post()</code> means \"submitted for processing\". The actual send happens later on tofu's internal thread.</p> <pre><code>const bhdr = try chnls.post(&amp;msg);\n// Message is queued. Not sent yet.\n// tofu will send it on its internal thread.\n// Success or failure comes via waitReceive.\n</code></pre> <p>Everything happens asynchronously:</p> <ul> <li>You post a message</li> <li>tofu processes it (connect, send, whatever)</li> <li>Results come back via <code>waitReceive()</code></li> </ul> <p>This is why the pattern is always: post \u2192 waitReceive.</p>"},{"location":"mds/thinking-in-messages/#example-server-setup","title":"Example: Server Setup","text":"<p>Here's how \"start listening\" works with tofu:</p> Server becomes available<pre><code>// Get message\nvar welcomeReq = try ampe.get(.always);\ndefer ampe.put(&amp;welcomeReq);\n\n// Set up WelcomeRequest with listen address\nvar addr: Address = .{ .tcp_server_addr = address.TCPServerAddress.init(\"0.0.0.0\", 7099) };\ntry addr.format(welcomeReq.?);\n\n// Submit it \u2014 tofu creates the listener\nconst bhdr = try chnls.post(&amp;welcomeReq);\nconst listener_channel = bhdr.channel_number;\n\n// Wait for confirmation\nvar welcomeResp = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;welcomeResp);\n\n// Now listening on listener_channel\n</code></pre> <p>You didn't call <code>bind()</code> or <code>listen()</code>. You sent a WelcomeRequest that means \"please start listening\". tofu did the rest.</p>"},{"location":"mds/thinking-in-messages/#example-client-connection","title":"Example: Client Connection","text":"<p>Here's how \"connect to server\" works:</p> Client connects<pre><code>// Get message\nvar helloReq = try ampe.get(.always);\ndefer ampe.put(&amp;helloReq);\n\n// Set up HelloRequest with server address\nvar addr: Address = .{ .tcp_client_addr = address.TCPClientAddress.init(\"127.0.0.1\", 7099) };\ntry addr.format(helloReq.?);\n\n// Submit it \u2014 tofu connects and sends\nconst bhdr = try chnls.post(&amp;helloReq);\nconst server_channel = bhdr.channel_number;  // Save this!\n\n// Wait for server response\nvar helloResp = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;helloResp);\n\n// Now connected. Use server_channel for all communication.\n</code></pre> <p>You didn't call <code>connect()</code>. You sent a HelloRequest that contains the server address. tofu connected and sent it.</p>"},{"location":"mds/thinking-in-messages/#summary","title":"Summary","text":"Traditional tofu Connect, then send Send (it connects) Manage sockets Manage messages Client vs Server Peer vs Peer Synchronous steps Async post \u2192 waitReceive Multiple APIs for different things Four APIs for everything"},{"location":"mds/thinking-in-messages/#whats-next","title":"What's Next","text":"<p>Now you're ready to learn the details:</p> <ul> <li>Message \u2014 The structure of a tofu message</li> <li>Address \u2014 How to specify connection addresses</li> <li>ChannelGroup \u2014 Managing multiple channels</li> </ul> <p>Messages are operations. tofu does the network work.</p>"},{"location":"mds/your-first-client/","title":"Your First Client","text":"<p>A client does three things:</p> <ol> <li>Connect to server (HelloRequest)</li> <li>Exchange messages</li> <li>Close connection (ByeRequest)</li> </ol>"},{"location":"mds/your-first-client/#step-1-create-the-engine","title":"Step 1: Create the Engine","text":"<p>Same as server - create engine and interfaces.</p> <pre><code>const std = @import(\"std\");\nconst tofu = @import(\"tofu\");\n\nconst Reactor = tofu.Reactor;\nconst Ampe = tofu.Ampe;\nconst ChannelGroup = tofu.ChannelGroup;\nconst Message = tofu.Message;\nconst Address = tofu.address.Address;\nconst address = tofu.address;\n\npub fn main() !void {\n    var alc: std.heap.DebugAllocator(.{}) = .init;\n    defer _ = alc.deinit();\n    const allocator = alc.allocator();\n\n    var rtr: *Reactor = try Reactor.create(allocator, tofu.DefaultOptions);\n    defer rtr.destroy();\n\n    const ampe: Ampe = try rtr.ampe();\n    const chnls: ChannelGroup = try ampe.create();\n    defer tofu.DestroyChannels(ampe, chnls);\n}\n</code></pre>"},{"location":"mds/your-first-client/#step-2-connect-to-server","title":"Step 2: Connect to Server","text":"<p>Send HelloRequest. tofu connects and sends it. Wait for HelloResponse.</p> <pre><code>// Get message\nvar helloReq: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;helloReq);\n\n// Set up server address\nvar addr: Address = .{\n    .tcp_client_addr = address.TCPClientAddress.init(\"127.0.0.1\", 7099)\n};\ntry addr.format(helloReq.?);\n\n// Submit - tofu connects and sends\nconst bhdr = try chnls.post(&amp;helloReq);\nconst server_ch = bhdr.channel_number;  // Save this!\n\n// Wait for response\nvar helloResp: ?*Message = try chnls.waitReceive(tofu.waitReceive_INFINITE_TIMEOUT);\ndefer ampe.put(&amp;helloResp);\n\n// Check what we got\nif (helloResp.?.isFromEngine()) {\n    // Connection failed\n    const sts = tofu.status.raw_to_status(helloResp.?.bhdr.status);\n    std.debug.print(\"Connect failed: {}\\n\", .{sts});\n    return error.ConnectFailed;\n}\n\nif (helloResp.?.bhdr.proto.opCode == .HelloResponse) {\n    // Connected! server_ch is ready for use\n}\n</code></pre> <p>Save the server channel</p> <p><code>server_ch</code> returned from <code>post()</code> is your handle to the server. Use it for all future messages to this server.</p>"},{"location":"mds/your-first-client/#step-3-send-requests","title":"Step 3: Send Requests","text":"<p>After connection, send requests and receive responses.</p> <pre><code>// Get message\nvar req: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;req);\n\n// Set up request\nreq.?.bhdr.proto.opCode = .Request;\nreq.?.bhdr.channel_number = server_ch;  // The channel from step 2\nreq.?.bhdr.message_id = 1;  // Your job ID\n\n// Add data\ntry req.?.body.append(\"Hello, server!\");\n\n// Send\n_ = try chnls.post(&amp;req);\n\n// Wait for response\nvar resp: ?*Message = try chnls.waitReceive(tofu.waitReceive_INFINITE_TIMEOUT);\ndefer ampe.put(&amp;resp);\n\n// Check response\nif (resp.?.bhdr.proto.opCode == .Response) {\n    if (resp.?.bhdr.message_id == 1) {\n        // This is the response to our request\n        const data = resp.?.body.body().?;\n        // ... process response ...\n    }\n}\n</code></pre> NAQ: What if the response takes too long? <p>Use a timeout instead of infinite wait: <pre><code>var resp = try chnls.waitReceive(5 * tofu.waitReceive_SEC_TIMEOUT);\nif (resp == null) {\n    // Timeout - no response within 5 seconds\n}\n</code></pre></p>"},{"location":"mds/your-first-client/#step-4-close-connection","title":"Step 4: Close Connection","text":"<p>Graceful close with ByeRequest/ByeResponse.</p> <pre><code>// Get message\nvar bye: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;bye);\n\n// Set up ByeRequest\nbye.?.bhdr.proto.opCode = .ByeRequest;\nbye.?.bhdr.channel_number = server_ch;\n\n// Send\n_ = try chnls.post(&amp;bye);\n\n// Wait for ByeResponse\nvar byeResp: ?*Message = try chnls.waitReceive(tofu.waitReceive_INFINITE_TIMEOUT);\ndefer ampe.put(&amp;byeResp);\n\n// Channel is now closed\n</code></pre>"},{"location":"mds/your-first-client/#handling-connection-failures","title":"Handling Connection Failures","text":"<p>Connections can fail. Check the status.</p> <pre><code>var resp: ?*Message = try chnls.waitReceive(tofu.waitReceive_INFINITE_TIMEOUT);\ndefer ampe.put(&amp;resp);\n\nif (resp.?.isFromEngine()) {\n    const sts = tofu.status.raw_to_status(resp.?.bhdr.status);\n    switch (sts) {\n        .connect_failed =&gt; {\n            // Server not reachable\n        },\n        .channel_closed =&gt; {\n            // Server closed the connection\n        },\n        .send_failed =&gt; {\n            // Message could not be sent\n        },\n        else =&gt; {},\n    }\n}\n</code></pre> <p>Reconnection is manual</p> <p>tofu does not auto-reconnect. If connection fails, send a new HelloRequest.</p>"},{"location":"mds/your-first-client/#complete-example","title":"Complete Example","text":"<pre><code>const std = @import(\"std\");\nconst tofu = @import(\"tofu\");\n\nconst Reactor = tofu.Reactor;\nconst Ampe = tofu.Ampe;\nconst ChannelGroup = tofu.ChannelGroup;\nconst Message = tofu.Message;\nconst Address = tofu.address.Address;\nconst address = tofu.address;\nconst status = tofu.status;\n\npub fn runClient(gpa: std.mem.Allocator, host: []const u8, port: u16) !void {\n    // Create engine\n    var rtr: *Reactor = try Reactor.create(gpa, tofu.DefaultOptions);\n    defer rtr.destroy();\n\n    const ampe: Ampe = try rtr.ampe();\n    const chnls: ChannelGroup = try ampe.create();\n    defer tofu.DestroyChannels(ampe, chnls);\n\n    // Connect\n    var helloReq: ?*Message = try ampe.get(.always);\n    defer ampe.put(&amp;helloReq);\n\n    var addr: Address = .{\n        .tcp_client_addr = address.TCPClientAddress.init(host, port)\n    };\n    try addr.format(helloReq.?);\n\n    const bhdr = try chnls.post(&amp;helloReq);\n    const server_ch = bhdr.channel_number;\n\n    var helloResp: ?*Message = try chnls.waitReceive(tofu.waitReceive_INFINITE_TIMEOUT);\n    defer ampe.put(&amp;helloResp);\n\n    if (helloResp.?.isFromEngine()) {\n        return error.ConnectFailed;\n    }\n\n    std.debug.print(\"Connected to server\\n\", .{});\n\n    // Send request\n    var req: ?*Message = try ampe.get(.always);\n    defer ampe.put(&amp;req);\n\n    req.?.bhdr.proto.opCode = .Request;\n    req.?.bhdr.channel_number = server_ch;\n    try req.?.body.append(\"ping\");\n\n    _ = try chnls.post(&amp;req);\n\n    // Receive response\n    var resp: ?*Message = try chnls.waitReceive(tofu.waitReceive_INFINITE_TIMEOUT);\n    defer ampe.put(&amp;resp);\n\n    std.debug.print(\"Got response: {s}\\n\", .{resp.?.body.body().?});\n\n    // Close\n    var bye: ?*Message = try ampe.get(.always);\n    defer ampe.put(&amp;bye);\n\n    bye.?.bhdr.proto.opCode = .ByeRequest;\n    bye.?.bhdr.channel_number = server_ch;\n\n    _ = try chnls.post(&amp;bye);\n\n    var byeResp: ?*Message = try chnls.waitReceive(tofu.waitReceive_INFINITE_TIMEOUT);\n    defer ampe.put(&amp;byeResp);\n\n    std.debug.print(\"Disconnected\\n\", .{});\n}\n</code></pre>"},{"location":"mds/your-first-client/#key-points","title":"Key Points","text":"Step Message What happens Connect HelloRequest \u2192 HelloResponse tofu creates socket, connects, sends Send data Request \u2192 Response Your application logic Close ByeRequest \u2192 ByeResponse Graceful channel close"},{"location":"mds/your-first-client/#common-patterns","title":"Common Patterns","text":""},{"location":"mds/your-first-client/#retry-on-failure","title":"Retry on failure","text":"<pre><code>var connected = false;\nvar attempts: u8 = 0;\n\nwhile (!connected and attempts &lt; 5) {\n    var helloReq: ?*Message = try ampe.get(.always);\n    defer ampe.put(&amp;helloReq);\n\n    try addr.format(helloReq.?);\n    const bhdr = try chnls.post(&amp;helloReq);\n\n    var resp: ?*Message = try chnls.waitReceive(3 * tofu.waitReceive_SEC_TIMEOUT);\n    defer ampe.put(&amp;resp);\n\n    if (resp != null and resp.?.bhdr.proto.opCode == .HelloResponse) {\n        connected = true;\n        server_ch = bhdr.channel_number;\n    } else {\n        attempts += 1;\n        std.Thread.sleep(std.time.ns_per_s);\n    }\n}\n</code></pre>"},{"location":"mds/your-first-client/#next","title":"Next","text":"<p>See Message Flows for async completion details.</p>"},{"location":"mds/your-first-server/","title":"Your First Server","text":"<p>A server does three things:</p> <ol> <li>Start a listener (WelcomeRequest)</li> <li>Accept connections (receive HelloRequest, send HelloResponse)</li> <li>Exchange messages with clients</li> </ol>"},{"location":"mds/your-first-server/#step-1-create-the-engine","title":"Step 1: Create the Engine","text":"<p>Before anything, create the tofu engine and get interfaces.</p> <pre><code>const std = @import(\"std\");\nconst tofu = @import(\"tofu\");\n\nconst Reactor = tofu.Reactor;\nconst Ampe = tofu.Ampe;\nconst ChannelGroup = tofu.ChannelGroup;\nconst Message = tofu.Message;\nconst Address = tofu.address.Address;\nconst address = tofu.address;\n\npub fn main() !void {\n    var alc: std.heap.DebugAllocator(.{}) = .init;\n    defer _ = alc.deinit();\n    const allocator = alc.allocator();\n\n    // Create the engine\n    var rtr: *Reactor = try Reactor.create(allocator, tofu.DefaultOptions);\n    defer rtr.destroy();\n\n    // Get the ampe interface (message pool + channel factory)\n    const ampe: Ampe = try rtr.ampe();\n\n    // Create a channel group (handles multiple channels)\n    const chnls: ChannelGroup = try ampe.create();\n    defer tofu.DestroyChannels(ampe, chnls);\n\n    // Now ready to use tofu\n}\n</code></pre>"},{"location":"mds/your-first-server/#step-2-start-the-listener","title":"Step 2: Start the Listener","text":"<p>Send a WelcomeRequest to start listening.</p> <pre><code>// Get a message from pool\nvar welcomeReq: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;welcomeReq);\n\n// Set up the listen address\nvar addr: Address = .{\n    .tcp_server_addr = address.TCPServerAddress.init(\"0.0.0.0\", 7099)\n};\ntry addr.format(welcomeReq.?);\n\n// Submit - tofu creates the listener socket\nconst bhdr = try chnls.post(&amp;welcomeReq);\nconst listener_ch = bhdr.channel_number;\n\n// Wait for confirmation\nvar welcomeResp: ?*Message = try chnls.waitReceive(tofu.waitReceive_INFINITE_TIMEOUT);\ndefer ampe.put(&amp;welcomeResp);\n\n// Check status\nif (welcomeResp.?.bhdr.status != 0) {\n    // Failed to start listener\n    return error.ListenerFailed;\n}\n\n// Listener is ready on listener_ch\n</code></pre> <p>Save the listener channel</p> <p>You need <code>listener_ch</code> to identify messages related to the listener. New client connections arrive on different channels.</p>"},{"location":"mds/your-first-server/#step-3-accept-connections","title":"Step 3: Accept Connections","text":"<p>Wait for HelloRequest from clients, send HelloResponse to accept.</p> <pre><code>while (true) {\n    var msg: ?*Message = try chnls.waitReceive(tofu.waitReceive_INFINITE_TIMEOUT);\n    defer ampe.put(&amp;msg);\n\n    // Check origin first\n    if (msg.?.isFromEngine()) {\n        // Status notification from tofu\n        continue;\n    }\n\n    switch (msg.?.bhdr.proto.opCode) {\n        .HelloRequest =&gt; {\n            // New client connected\n            const client_ch = msg.?.bhdr.channel_number;\n\n            // Accept by sending HelloResponse\n            msg.?.bhdr.proto.opCode = .HelloResponse;\n            _ = try chnls.post(&amp;msg);\n\n            // Now client_ch is ready for data exchange\n        },\n        .Request =&gt; {\n            // Client sent a request - handle it\n            const ch = msg.?.bhdr.channel_number;\n            // ... process request ...\n        },\n        .ByeRequest =&gt; {\n            // Client wants to close\n            msg.?.bhdr.proto.opCode = .ByeResponse;\n            _ = try chnls.post(&amp;msg);\n        },\n        else =&gt; {},\n    }\n}\n</code></pre> NAQ: How do I reject a connection? <p>Send ByeSignal instead of HelloResponse: <pre><code>msg.?.bhdr.proto.opCode = .ByeSignal;\n_ = try chnls.post(&amp;msg);\n</code></pre> This closes the channel immediately.</p>"},{"location":"mds/your-first-server/#step-4-handle-requests","title":"Step 4: Handle Requests","text":"<p>Process incoming requests and send responses.</p> <pre><code>.Request =&gt; {\n    const client_ch = msg.?.bhdr.channel_number;\n    const job_id = msg.?.bhdr.message_id;\n\n    // Read request body\n    const request_data = msg.?.body.body().?;\n\n    // Process (your logic here)\n    const result = processRequest(request_data);\n\n    // Reuse message for response\n    msg.?.bhdr.proto.opCode = .Response;\n    // channel_number and message_id stay the same\n    msg.?.body.clear();\n    try msg.?.body.append(result);\n\n    _ = try chnls.post(&amp;msg);\n},\n</code></pre> <p>Reuse messages</p> <p>You can reuse the received message for the response. Just change the opCode and body. Channel and message_id stay the same.</p>"},{"location":"mds/your-first-server/#complete-example","title":"Complete Example","text":"<pre><code>const std = @import(\"std\");\nconst tofu = @import(\"tofu\");\n\nconst Reactor = tofu.Reactor;\nconst Ampe = tofu.Ampe;\nconst ChannelGroup = tofu.ChannelGroup;\nconst Message = tofu.Message;\nconst Address = tofu.address.Address;\nconst address = tofu.address;\n\npub fn runServer(gpa: std.mem.Allocator, port: u16) !void {\n    // Create engine\n    var rtr: *Reactor = try Reactor.create(gpa, tofu.DefaultOptions);\n    defer rtr.destroy();\n\n    const ampe: Ampe = try rtr.ampe();\n    const chnls: ChannelGroup = try ampe.create();\n    defer tofu.DestroyChannels(ampe, chnls);\n\n    // Start listener\n    var welcomeReq: ?*Message = try ampe.get(.always);\n    defer ampe.put(&amp;welcomeReq);\n\n    var addr: Address = .{\n        .tcp_server_addr = address.TCPServerAddress.init(\"0.0.0.0\", port)\n    };\n    try addr.format(welcomeReq.?);\n\n    _ = try chnls.post(&amp;welcomeReq);\n\n    var welcomeResp: ?*Message = try chnls.waitReceive(tofu.waitReceive_INFINITE_TIMEOUT);\n    defer ampe.put(&amp;welcomeResp);\n\n    if (welcomeResp.?.bhdr.status != 0) {\n        return error.ListenerFailed;\n    }\n\n    std.debug.print(\"Server listening on port {d}\\n\", .{port});\n\n    // Main loop\n    while (true) {\n        var msg: ?*Message = try chnls.waitReceive(tofu.waitReceive_INFINITE_TIMEOUT);\n        defer ampe.put(&amp;msg);\n\n        if (msg.?.isFromEngine()) {\n            continue;\n        }\n\n        switch (msg.?.bhdr.proto.opCode) {\n            .HelloRequest =&gt; {\n                // Accept connection\n                msg.?.bhdr.proto.opCode = .HelloResponse;\n                _ = try chnls.post(&amp;msg);\n            },\n            .Request =&gt; {\n                // Echo back\n                msg.?.bhdr.proto.opCode = .Response;\n                _ = try chnls.post(&amp;msg);\n            },\n            .ByeRequest =&gt; {\n                msg.?.bhdr.proto.opCode = .ByeResponse;\n                _ = try chnls.post(&amp;msg);\n            },\n            else =&gt; {},\n        }\n    }\n}\n</code></pre>"},{"location":"mds/your-first-server/#key-points","title":"Key Points","text":"Step Message What happens Start listener WelcomeRequest \u2192 WelcomeResponse tofu creates socket, binds, listens Accept client HelloRequest \u2192 HelloResponse New channel for this client Handle request Request \u2192 Response Your application logic Close ByeRequest \u2192 ByeResponse Graceful channel close"},{"location":"mds/your-first-server/#next","title":"Next","text":"<p>See Your First Client for the client side.</p>"}]}