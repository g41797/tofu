{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"\"Before machines can work, people must talk.\"    Get Started GitHub Repository"},{"location":"blog/","title":"Blog","text":""},{"location":"mds/aigenerated/","title":"About AI Generated Documents","text":"<p>99.99% of the code was written manually, without AI.</p> <p>AI\u2011generated docs were created later, after the main development, as part of a post\u2011mortem review. They were added to the site to make the project easier to understand and port to other languages.</p> <p>AI Generated</p> <p>Verify all code and instructions before implementation.</p>"},{"location":"mds/aigenerated/#links","title":"Links","text":"<ul> <li>GitHub</li> <li>Documentation</li> </ul>"},{"location":"mds/allocator/","title":"Allocator","text":"<p>Zig takes pride in its allocators; they are its \"signature feature,\" or, as one might say, the \"spice of life\".</p> <p>The \"allocator-passing idiom\" in Zig refers to the explicit handling of memory allocation by passing an allocator as a parameter to functions and data structures, empowering the caller to control the allocation strategy at every level of the program.</p> <p>Tofu's relationship with Allocators is similar to Henry Ford's famous quote about car color:</p> <p>\"Customers can have any color they want, so long as it is black.\"</p> <p>Similarly, allocators for Tofu can be anything, provided they are 'GPA compatible'.</p> <p>Allocator names in Zig change often. This reminds me of an old Unix joke:</p> <p>\"Unix is an operating system where nobody knows what the print command is called today\"</p> <p>I'll use GPA (General Purpose Allocator) because I expect that the name GPA will persist in common use.</p> <p> 'GPA compatible' means:</p> <ul> <li>It is thread-safe.</li> <li>Its life cycle is the same as the life cycle of the process.</li> <li>The memory it releases truly allows for further reuse of that released memory.</li> </ul> <p>For example, <code>std.heap.c_allocator</code> satisfies these requirements, but <code>std.heap.ArenaAllocator</code> does not.</p> <p>How many unnecessary memories one Allocator brings back :disappointed: ...</p>"},{"location":"mds/ampe/","title":"Ampe","text":"<p>Ampe or engine is the \"holder\" (owner) and allocator of all tofu resources</p> <ul> <li>ChannelGroups</li> <li>Messages</li> </ul> <p>Consider it the GPA of tofu. </p> <p>What are the differences between protocol and implementation?</p>"},{"location":"mds/ampe/#ampe-creation","title":"Ampe creation","text":"Example of Ampe creation<pre><code>pub fn createDestroyAmpe(gpa: Allocator) !void {\n    // Create engine implementation object\n    const rtr: *Reactor = try Reactor.Create(gpa, DefaultOptions);\n\n    // Destroy it after return or on error\n    defer rtr.*.Destroy();\n\n    // Create ampe interface\n    const ampe: Ampe = try rtr.*.ampe();\n\n    _ = ampe;\n\n    // No need to destroy ampe itself.\n    // It is an interface provided by Reactor.\n    // It will be destroyed via  rtr.*.Destroy().\n}\n</code></pre> <p>where</p> <ul> <li>gpa is GPA Compatible Allocator</li> <li>DefaultOptions </li> </ul> <p>Note</p> <p>You can create multiple engines per process.</p>"},{"location":"mds/ampe/#interface","title":"Interface","text":"<p>Ampe is represented by the following interface: </p> Brief version of the Interface<pre><code>pub const Ampe = struct {\n    pub fn create(ampe: Ampe) status.AmpeError!ChannelGroup {...}\n    pub fn destroy(ampe: Ampe, chnls: ChannelGroup) status.AmpeError!void {...}\n\n    pub fn get(ampe: Ampe, strategy: AllocationStrategy) status.AmpeError!?*message.Message {...}\n    pub fn put(ampe: Ampe, msg: *?*message.Message) void {...}\n\n    pub fn getAllocator(ampe: Ampe) Allocator {...}\n</code></pre> <p>Just a reminder: all methods are thread-safe.</p> <p>The first two methods, create/destroy, manage a ChannelGroup. You don't need to know what that is yet; just make a note of it.</p> <p>The next two methods require additional explanation, so let's move on to the Message Pool.</p>"},{"location":"mds/ampe/#message-pool","title":"Message Pool","text":"<p>Ampe supports a Message Pool mechanism to improve system performance.</p> <p>The get operation retrieves an existing message from the pool or creates a new one.  The choice is determined by the strategy: AllocationStrategy parameter: <pre><code>pub const AllocationStrategy = enum {\n    poolOnly, // Tries to get a message from the pool. Returns null if the pool is empty.\n    always,   // Gets a message from the pool or creates a new one if the pool is empty.\n};\n</code></pre></p> <p>null isn't error</p> <p>Returned by get null is absolutely valid value, null returned if the pool is empty and the strategy is poolOnly. </p> <p>get returns error if</p> <ul> <li>allocation failed</li> <li>engine performs shutdown</li> </ul> <p>Opposite put operation returns message to the pool and sets it's value to null. If engine performs shutdown or pool is full, message will be destroyed, means all allocated memory silently will be released.</p> <pre><code>    var msg: ?*Message = try ampe.get(tofu.AllocationStrategy.poolOnly);\n    defer ampe.put(&amp;msg);\n</code></pre> <p>Because null returned by get is valid value , it's also valid value for put: if msg == null, put does nothing.</p> <p>NAQ: *?*message.Message - WTH???</p> <p>*?* (address of optional pointer) idiom allows to prevent reusing of released or moved to other thread objects(structs). In our case - Messages.</p> <p><code>ampe.put(&amp;msg)</code>:</p> <ul> <li>returns msg to the pool</li> <li>set msg to null</li> </ul> <p>As result:</p> <ul> <li>every further put will be successful</li> <li>every further attempt to use msg without check will fail</li> </ul> <p>You will see usage of *?* in different places during our journey.</p>"},{"location":"mds/ampe/#pool-configuration","title":"Pool configuration","text":"<p>Pool configuration is determined by  <pre><code>pub const Options = struct {\n    initialPoolMsgs: ?u16 = null,\n    maxPoolMsgs: ?u16 = null,\n};\n</code></pre> initialPoolMsgs - is the number of messages in the pool created during initialization of engine</p> <p>maxPoolMsgs - is the maximal number of the messages </p> <p>Do you remember ? </p> <p>If ... pool is full, message will be destroyed</p> <p>means if number of the messages in the pool == maxPoolMsgs, message will be destroyed.</p> <p>Tofu provides default pool configuration: Just example of configuration, it isn't recommendation<pre><code>    pub const DefaultOptions: Options = .{\n        .initialPoolMsgs = 16,\n        .maxPoolMsgs = 64,\n    };\n</code></pre></p> <p>Pool configuration is used during creation of engine: <pre><code>    // Create engine implementation object with default pool configuration \n    var rtr: *Reactor = try Reactor.Create(gpa, DefaultOptions);\n</code></pre></p> <p>Just clarification - you don't deal with pool destroy, it will be destroyed during destroy of engine. </p>"},{"location":"mds/ampe/#errors-and-statuses","title":"Errors and Statuses","text":"<p>Tofu defines own error set: Partial tofu error set<pre><code>pub const AmpeError = error{\n    NotImplementedYet,\n    WrongConfiguration,\n    NotAllowed,\n    NullMessage,\n    ............\n    PoolEmpty,\n    AllocationFailed,\n    ............\n    ShutdownStarted,\n    ProcessingFailed, \n    UnknownError,\n};\n</code></pre> There is also enumerator for statuses: Partial tofu statuses<pre><code>pub const AmpeStatus = enum(u8) {\n    success = 0,\n    not_implemented_yet,\n    wrong_configuration,\n    not_allowed,\n    null_message,\n    ............\n    pool_empty,\n    allocation_failed,\n    ............\n    shutdown_started,\n    ............\n    processing_failed,\n    unknown_error,\n};\n</code></pre></p> <p>Every AmpeError has corresponding AmpeStatus enumerator (except 'success').</p> <p>Errors and Statuses have self-described names which I hope means I don\u2019t have to describe each one separately.</p> <p>To jump ahead a bit, this system allows errors to be transmitted as part of Message,  using just 1 byte (u8).</p> <p>You can use helper function <code>status.raw_to_error(rs: u8) AmpeError!void</code> in order to convert byte to corresponding error.</p> <p>Not every non-zero status means an error right away. It depends on the situation. For example, 'channel_closed'</p> <ul> <li>is not an error if you requested to close the channel  </li> <li>it is an error if it happens in the middle of communication</li> </ul>"},{"location":"mds/channel-group/","title":"ChannelGroup","text":"<p>ChannelGroup provides full-duplex, asynchronous message exchange between peers. </p> NAQ: Why \"peers\" instead of \"client/server\"? <p>Tofu uses client and server terms to describe the initial handshake. After the handshake, both sides are called peers because they have equal  functionality and roles.</p> <p>Simplest description of ChannelGroup you can get from its name - Group Of Channels :smile:.</p>"},{"location":"mds/channel-group/#channelgroup-createdestroy","title":"ChannelGroup create/destroy","text":"<p>Let's create and destroy a ChannelGroup\u2014still without fully understanding what it is.</p> <pre><code>    const rtr: *Reactor = try Reactor.Create(gpa, DefaultOptions);\n    defer rtr.*.Destroy();\n\n    const ampe: Ampe = try rtr.*.ampe();\n\n    const chnls: ChannelGroup = try ampe.create();\n\n    defer { \n        _ = ampe.destroy(chnls) catch | err | {\n            std.log.err(\"destroy channel group failed with error {any}\", .{err});\n        };\n    }\n</code></pre> <p>There are two ways to release resources (messages, channels etc.) of ChannelGroup</p> <ul> <li>explicit - via  ampe.destroy(...) [PREFERRED]</li> <li>implicit - during destroy of engine - rtr.*.Destroy() [FOR SIMPLE GO/NO GO]</li> </ul> <p>Warn</p> <p>ampe.destroy(chngrp) cannot be used directly in defer because defer does not allow try or error unions.  </p>"},{"location":"mds/channel-group/#channelgroup-interface","title":"ChannelGroup interface","text":"<pre><code>/// Defines the ChannelGroup interface for async message passing.\n/// Supports two-way message exchange between peers.\npub const ChannelGroup = struct {\n\n    /// Submits a message for async processing:\n    /// - most cases: send to peer\n    /// - others: internal network related processing\n    ///\n    /// On success:\n    /// - Sets `msg.*` to null (prevents reuse).\n    /// - Returns `BinaryHeader` for tracking.\n    ///\n    /// On error:\n    /// - Returns an error.\n    /// - If the engine cannot use the message (internal failure),\n    ///   also sets `msg.*` to null.\n    ///\n    /// Thread-safe.\n    pub fn enqueueToPeer(\n        chnls: ChannelGroup,\n        msg: *?*message.Message,\n    ) status.AmpeError!message.BinaryHeader {...}\n\n    /// Waits for the next message from the internal queue.\n    ///\n    /// Timeout is in nanoseconds. Returns `null` if no message arrives in time.\n    ///\n    /// Message sources:\n    /// - Remote peer (via `enqueueToPeer` on their side).\n    /// - Application (via `updateReceiver` on this ChannelGroup).\n    /// - Ampe (status/control messages).\n    ///\n    /// Check `BinaryHeader` to identify the source.\n    ///\n    /// On error: stop using this ChannelGroup and call `ampe.destroy` on it.\n    ///\n    /// Call in a loop from **one thread only**.\n    pub fn waitReceive(\n        chnls: ChannelGroup,\n        timeout_ns: u64,\n    ) status.AmpeError!?*message.Message {...}\n\n    /// Adds a message to the internal queue for `waitReceive`.\n    ///\n    /// If `msg.*` is not null:\n    /// - Engine sets status to `'receiver_update'`.\n    /// - Sets `msg.*` to null after success.\n    /// - No need for `channel_number` or similar fields.\n    ///\n    /// If `msg.*` is null:\n    /// - Creates a `'receiver_update'` Signal and adds it.\n    ///\n    /// Returns error if shutting down.\n    ///\n    /// Use from another thread to:\n    /// - Wake the receiver (`msg.*` = null).\n    /// - Send info/commands/notifications.\n    ///\n    /// FIFO order only. No priority queues.\n    ///\n    /// Thread-safe.\n    pub fn updateReceiver(\n        chnls: ChannelGroup,\n        update: *?*message.Message,\n    ) status.AmpeError!void {...}\n}\n</code></pre> <p>Caller of every function/method has \"non-formal\" role:</p> <ul> <li>enqueueToPeer caller \u2192 Producer</li> <li>waitReceive caller \u2192 Consumer</li> <li>updateReceiver caller \u2192 Notifier</li> </ul> NAQ: No methods use channel numbers. How to handle channels? <p>You also won't see IP addresses or port numbers. All this info is in the messages.</p> <p>Without details about Message, it is hard to explain how to use this interface. A full description will come later.</p>"},{"location":"mds/coding-style/","title":"Coding style","text":""},{"location":"mds/coding-style/#big-endian-imports-vs-little-endian-imports","title":"Big-endian imports vs Little-endian imports","text":"<p>There are two \"parties\" in Zig about where imports should be placed.</p> <p>Big-endian - imports are placed at the top of the file, before the code.</p> <p>Little-endian - imports are placed at the bottom of the file, after the code.</p> <p>I belong to the LE party. At least, tofu sources use LE imports.</p> <p>But in examples, I am using BE just for your convenience.</p>"},{"location":"mds/coding-style/#type-inference","title":"Type inference","text":"<p>Type inference is convenient for the developer:</p> <ul> <li>when working with comptime-generated code</li> <li>when the IDE displays the actual types</li> </ul> <p>It is not convenient for the reader:</p> <ul> <li>when looking at small examples or snippets</li> <li>when reading code in a browser or editor without type hints</li> </ul> <p>That\u2019s why in examples \u2014 and increasingly in my own projects \u2014 I try to avoid type inference.</p>"},{"location":"mds/coding-style/#automatic-dereference-for-the-operator-on-single-pointers","title":"Automatic dereference for the <code>.</code> operator on single pointers","text":"<p>I am slowly moving toward always dereference explicitly.</p>"},{"location":"mds/configurators/","title":"Configurators","text":""},{"location":"mds/conversation/","title":"Conversation","text":""},{"location":"mds/conversation/#context","title":"Context","text":"<p>This document captures a technical conversation between two developers designing a Print Server system using the tofu messaging framework.  This exemplifies tofu's core philosophy: development starts with a conversation between developers, not with API specifications.</p> <p>Participants:</p> <ul> <li>S (Spool Server Developer): Manages print job queue and distribution</li> <li>R (RIP Worker Process Developer): Performs Raster Image Processing on print jobs</li> </ul>"},{"location":"mds/conversation/#the-conversation","title":"The Conversation","text":"<p>This is the technical conversation that defines the entire protocol. Notice how natural message flow emerges from developer discussion rather than formal API design.</p> <pre><code>S: I don't know the addresses of the workers, so you should connect to me.\n\nR: I'll send a HelloRequest, because the worker can process only specific PDL types,\n   the PDL header will contain either PS or PDF.\n\nS: Do I need to send you a HelloResponse?\n\nR: No, just start sending me messages with PDL data.\n\nS: As signals?\n\nR: No, as multi-requests \u2014 each with a message ID equal to the job ID.\n\nS: You forgot the Job Ticket.\n\nR: Right. The first request should have a JobTicket header (JDF or PPD) and the\n   ticket data in the body. The following requests will have the PDL header\n   (PDF or PS) with the related content.\n\nS: But JDF is usually used only for PDF...\n\nR: Yes, but let's keep it flexible.\n\nS: Can you process several jobs simultaneously?\n\nR: It depends on licensing. Anyway, if I can, I'll send another HelloRequest \u2014\n   working one job per channel looks cleaner.\n\nS: I need a progress indicator.\n\nR: No problem. I'll send signals with the same message ID \u2014 the Progress header\n   will show the range [N:M] for page numbers.\n\nS: On job finish, send me a Response with the same message ID and processing status.\n   Also include the Progress header.\n\nR: Why should I send an obsolete message? Are you expecting a graceful close?\n\nS: Of course.\n\nR: Then I'll send a ByeRequest with the same information, and you'll send me a\n   ByeResponse. After that, I'll abort the connection immediately.\n\nS: That's enough for today. Send me a short text file with this protocol \u2014\n   I'll save it in Git.\n\nR: Deal. How about a cup of coffee?\n</code></pre>"},{"location":"mds/conversation/#protocol-analysis","title":"Protocol Analysis","text":""},{"location":"mds/conversation/#key-decisions-made","title":"Key Decisions Made","text":"Decision Rationale R connects to S S doesn't know worker addresses upfront PDL type in HelloRequest Workers are specialized (PS or PDF only) No HelloResponse Streamlined - S just starts sending jobs Multi-requests with job_id All chunks of one job share same message_id JobTicket first, then PDL Job metadata separate from actual data One job per channel Clean separation, easier state management Progress as signals One-way updates, no response needed ByeRequest for completion Graceful close with final status"},{"location":"mds/conversation/#message-types-defined","title":"Message Types Defined","text":"<ol> <li>HelloRequest - Worker announces capabilities (PDL: PS or PDF)</li> <li>JobTicket Request - First request with job metadata (JDF/PPD)</li> <li>PDL Data Requests - Subsequent requests with actual print data</li> <li>Progress Signals - Status updates during processing</li> <li>ByeRequest - Job completion with final status</li> <li>ByeResponse - Server acknowledges completion</li> </ol>"},{"location":"mds/conversation/#communication-diagrams","title":"Communication Diagrams","text":""},{"location":"mds/conversation/#diagram-1-connection-establishment","title":"Diagram 1: Connection Establishment","text":"<pre><code>sequenceDiagram\n    participant S as Spool Server\n    participant R as RIP Worker\n\n    Note over S: Server starts listening\n    S-&gt;&gt;S: WelcomeRequest (TCP, port)\n    Note over S: Listening on port\n\n    Note over R: Worker knows server address\n    R-&gt;&gt;S: HelloRequest (ch=0)&lt;br/&gt;PDL: PS or PDF\n    Note over R,S: No HelloResponse!&lt;br/&gt;S just starts sending jobs\n\n    Note over S,R: Connection established&lt;br/&gt;Channel assigned (e.g., ch=123)</code></pre> <p>Key Points:</p> <ul> <li>S (Server) creates listener via WelcomeRequest</li> <li>R (Worker) connects and sends HelloRequest with PDL capability</li> <li>No HelloResponse - streamlined connection</li> <li>Channel number assigned for this connection</li> </ul>"},{"location":"mds/conversation/#diagram-2-single-job-processing-flow","title":"Diagram 2: Single Job Processing Flow","text":"<pre><code>sequenceDiagram\n    participant S as Spool Server\n    participant R as RIP Worker\n\n    Note over S: Job arrives (job_id=1001)\n\n    S-&gt;&gt;R: Request (ch=123, mid=1001, more=expected)&lt;br/&gt;JobTicket: JDF&lt;br/&gt;Body: [job ticket data]\n    Note over R: Parse job ticket&lt;br/&gt;Prepare for PDL data\n\n    S-&gt;&gt;R: Request (ch=123, mid=1001, more=expected)&lt;br/&gt;PDL: PDF&lt;br/&gt;Body: [PDF chunk 1]\n    Note over R: Process chunk 1\n\n    S-&gt;&gt;R: Request (ch=123, mid=1001, more=expected)&lt;br/&gt;PDL: PDF&lt;br/&gt;Body: [PDF chunk 2]\n    Note over R: Process chunk 2\n\n    R-&gt;&gt;S: Signal (ch=123, mid=1001)&lt;br/&gt;Progress: [2:10]\n    Note over S: Worker processed 2 of 10 pages\n\n    S-&gt;&gt;R: Request (ch=123, mid=1001, more=last)&lt;br/&gt;PDL: PDF&lt;br/&gt;Body: [PDF chunk 3 - final]\n    Note over R: Process final chunk\n\n    R-&gt;&gt;S: Signal (ch=123, mid=1001)&lt;br/&gt;Progress: [10:10]\n    Note over S: All pages processed\n\n    R-&gt;&gt;S: ByeRequest (ch=123, mid=1001)&lt;br/&gt;Status: Success&lt;br/&gt;Progress: [10:10]\n    S-&gt;&gt;R: ByeResponse (ch=123, mid=1001)\n\n    Note over R: Abort connection&lt;br/&gt;Job complete</code></pre> <p>Key Points:</p> <ul> <li>All messages for one job use same message_id (job_id)</li> <li>First request: JobTicket header + ticket data</li> <li>Subsequent requests: PDL header + PDL data chunks</li> <li><code>more</code> flag: <code>.expected</code> until last chunk (<code>.last</code>)</li> <li>Progress signals: Fire-and-forget updates [current:total]</li> <li>ByeRequest/ByeResponse: Graceful close with final status</li> </ul>"},{"location":"mds/conversation/#diagram-3-multi-job-processing-multiple-channels","title":"Diagram 3: Multi-Job Processing (Multiple Channels)","text":"<pre><code>sequenceDiagram\n    participant S as Spool Server\n    participant R as RIP Worker\n\n    Note over R: Worker can handle multiple jobs&lt;br/&gt;(licensing permits)\n\n    R-&gt;&gt;S: HelloRequest (ch=0)&lt;br/&gt;PDL: PDF\n    Note over S,R: Channel 123 assigned\n\n    S-&gt;&gt;R: Request (ch=123, mid=1001)&lt;br/&gt;JobTicket: JDF&lt;br/&gt;[Job 1 ticket]\n    S-&gt;&gt;R: Request (ch=123, mid=1001)&lt;br/&gt;PDL: PDF&lt;br/&gt;[Job 1 data...]\n\n    Note over R: Job 1 processing started\n\n    R-&gt;&gt;S: HelloRequest (ch=0)&lt;br/&gt;PDL: PDF\n    Note over S,R: Channel 456 assigned&lt;br/&gt;(new channel for new job)\n\n    S-&gt;&gt;R: Request (ch=456, mid=2002)&lt;br/&gt;JobTicket: JDF&lt;br/&gt;[Job 2 ticket]\n    S-&gt;&gt;R: Request (ch=456, mid=2002)&lt;br/&gt;PDL: PDF&lt;br/&gt;[Job 2 data...]\n\n    Note over R: Job 2 processing started&lt;br/&gt;Jobs run in parallel\n\n    R-&gt;&gt;S: Signal (ch=123, mid=1001)&lt;br/&gt;Progress: [5:10]\n    Note over S: Job 1 progress update\n\n    R-&gt;&gt;S: Signal (ch=456, mid=2002)&lt;br/&gt;Progress: [3:8]\n    Note over S: Job 2 progress update\n\n    R-&gt;&gt;S: ByeRequest (ch=123, mid=1001)&lt;br/&gt;Status: Success\n    S-&gt;&gt;R: ByeResponse (ch=123, mid=1001)\n    Note over R: Job 1 complete, ch=123 closed\n\n    R-&gt;&gt;S: ByeRequest (ch=456, mid=2002)&lt;br/&gt;Status: Success\n    S-&gt;&gt;R: ByeResponse (ch=456, mid=2002)\n    Note over R: Job 2 complete, ch=456 closed</code></pre> <p>Key Points:</p> <ul> <li>Worker sends multiple HelloRequests for parallel jobs</li> <li>Each job gets its own channel (clean separation)</li> <li>Channel 123 handles job_id=1001</li> <li>Channel 456 handles job_id=2002</li> <li>Jobs processed independently</li> <li>Each channel closed via ByeRequest/ByeResponse</li> </ul>"},{"location":"mds/conversation/#diagram-4-complete-lifecycle-with-error-handling","title":"Diagram 4: Complete Lifecycle with Error Handling","text":"<pre><code>sequenceDiagram\n    participant S as Spool Server\n    participant R as RIP Worker\n\n    Note over S: Server startup\n    S-&gt;&gt;S: WelcomeRequest (TCP:9000)\n    Note over S: Listening on port 9000\n\n    Note over R: Worker startup\n    R-&gt;&gt;S: HelloRequest (ch=0)&lt;br/&gt;PDL: PS\n    Note over S,R: Channel 101 assigned\n\n    rect rgb(200, 255, 200)\n        Note over S,R: SUCCESSFUL JOB\n        S-&gt;&gt;R: Request (ch=101, mid=5001)&lt;br/&gt;JobTicket: PPD&lt;br/&gt;[PostScript job ticket]\n        S-&gt;&gt;R: Request (ch=101, mid=5001)&lt;br/&gt;PDL: PS&lt;br/&gt;[PostScript data]\n        R-&gt;&gt;S: Signal (ch=101, mid=5001)&lt;br/&gt;Progress: [1:1]\n        R-&gt;&gt;S: ByeRequest (ch=101, mid=5001)&lt;br/&gt;Status: Success&lt;br/&gt;Progress: [1:1]\n        S-&gt;&gt;R: ByeResponse (ch=101, mid=5001)\n        Note over R: Close channel 101\n    end\n\n    Note over R: Ready for next job\n    R-&gt;&gt;S: HelloRequest (ch=0)&lt;br/&gt;PDL: PS\n    Note over S,R: Channel 102 assigned\n\n    rect rgb(255, 200, 200)\n        Note over S,R: FAILED JOB\n        S-&gt;&gt;R: Request (ch=102, mid=5002)&lt;br/&gt;JobTicket: PPD&lt;br/&gt;[Job ticket]\n        S-&gt;&gt;R: Request (ch=102, mid=5002)&lt;br/&gt;PDL: PS&lt;br/&gt;[Corrupted data]\n        Note over R: Error: Invalid PostScript\n        R-&gt;&gt;S: ByeRequest (ch=102, mid=5002)&lt;br/&gt;Status: ProcessingFailed&lt;br/&gt;Progress: [0:5]\n        S-&gt;&gt;R: ByeResponse (ch=102, mid=5002)\n        Note over R: Close channel 102\n    end\n\n    Note over R: Worker continues running\n    R-&gt;&gt;S: HelloRequest (ch=0)&lt;br/&gt;PDL: PDF\n    Note over S,R: Channel 103 assigned&lt;br/&gt;(ready for next job)</code></pre> <p>Key Points:</p> <ul> <li>Worker lifecycle spans multiple jobs</li> <li>Successful job: Status=Success in ByeRequest</li> <li>Failed job: Status=ProcessingFailed (or other error)</li> <li>Progress header shows how far processing got</li> <li>Worker remains connected, ready for next job</li> <li>Each job gets fresh channel via new HelloRequest</li> </ul>"},{"location":"mds/conversation/#diagram-5-message-structure-details","title":"Diagram 5: Message Structure Details","text":"<pre><code>graph TD\n    subgraph \"HelloRequest Message\"\n        H1[BinaryHeader&lt;br/&gt;ch=0, mtype=hello&lt;br/&gt;role=request]\n        H2[TextHeader&lt;br/&gt;PDL: PS or PDF]\n        H3[Body: empty]\n    end\n\n    subgraph \"JobTicket Request\"\n        J1[BinaryHeader&lt;br/&gt;ch=123, mtype=regular&lt;br/&gt;role=request&lt;br/&gt;mid=1001, more=expected]\n        J2[TextHeader&lt;br/&gt;JobTicket: JDF or PPD]\n        J3[Body: job ticket data]\n    end\n\n    subgraph \"PDL Data Request\"\n        P1[BinaryHeader&lt;br/&gt;ch=123, mtype=regular&lt;br/&gt;role=request&lt;br/&gt;mid=1001, more=expected/last]\n        P2[TextHeader&lt;br/&gt;PDL: PDF or PS]\n        P3[Body: PDL data chunk]\n    end\n\n    subgraph \"Progress Signal\"\n        G1[BinaryHeader&lt;br/&gt;ch=123, mtype=regular&lt;br/&gt;role=signal&lt;br/&gt;mid=1001]\n        G2[TextHeader&lt;br/&gt;Progress: N:M]\n        G3[Body: empty or details]\n    end\n\n    subgraph \"ByeRequest Message\"\n        B1[BinaryHeader&lt;br/&gt;ch=123, mtype=bye&lt;br/&gt;role=request&lt;br/&gt;mid=1001]\n        B2[TextHeader&lt;br/&gt;Progress: N:M&lt;br/&gt;Status: app-specific]\n        B3[Body: final status data]\n    end</code></pre>"},{"location":"mds/conversation/#protocol-summary","title":"Protocol Summary","text":""},{"location":"mds/conversation/#message-flow-patterns","title":"Message Flow Patterns","text":"<p>Pattern 1: Connection <pre><code>Worker \u2192 Server: HelloRequest (PDL capability)\n[No response - Server just starts sending]\n</code></pre></p> <p>Pattern 2: Job Submission (Multi-Request) <pre><code>Server \u2192 Worker: Request (JobTicket + ticket data, mid=job_id, more=expected)\nServer \u2192 Worker: Request (PDL + data chunk 1, mid=job_id, more=expected)\nServer \u2192 Worker: Request (PDL + data chunk 2, mid=job_id, more=expected)\n...\nServer \u2192 Worker: Request (PDL + data chunk N, mid=job_id, more=last)\n</code></pre></p> <p>Pattern 3: Progress Updates (Signals) <pre><code>Worker \u2192 Server: Signal (Progress: [current:total], mid=job_id)\nWorker \u2192 Server: Signal (Progress: [current:total], mid=job_id)\n...\n</code></pre></p> <p>Pattern 4: Job Completion (Graceful Close) <pre><code>Worker \u2192 Server: ByeRequest (Status + Progress, mid=job_id)\nServer \u2192 Worker: ByeResponse (mid=job_id)\n[Worker closes connection]\n</code></pre></p>"},{"location":"mds/conversation/#headers-dictionary","title":"Headers Dictionary","text":""},{"location":"mds/conversation/#headers-used-in-this-protocol","title":"Headers Used in This Protocol","text":"Header Values Usage Message Types PDL <code>PS</code>, <code>PDF</code> Page Description Language type HelloRequest, PDL Requests JobTicket <code>JDF</code>, <code>PPD</code> Job ticket format First Request per job Progress <code>[N:M]</code> Current page : Total pages Signals, ByeRequest Status Application-defined Job processing result ByeRequest (in body or header)"},{"location":"mds/conversation/#message-id-strategy","title":"Message ID Strategy","text":"<ul> <li>message_id = job_id for all messages related to one job</li> <li>Enables correlation: all chunks, progress updates, and completion share same ID</li> <li>Example: Job 1001 uses mid=1001 throughout its lifecycle</li> </ul>"},{"location":"mds/conversation/#design-insights","title":"Design Insights","text":""},{"location":"mds/conversation/#why-this-conversation-matters","title":"Why This Conversation Matters","text":"<p>This conversation demonstrates tofu's core philosophy:</p> <ol> <li> <p>Natural Protocol Evolution:</p> <ul> <li>Started with basic connection (\"you should connect to me\")</li> <li>Evolved through discussion (multi-requests, job tickets, progress)</li> <li>Refined with experience (\"JDF is usually only for PDF\" \u2192 \"let's keep it flexible\")</li> </ul> </li> <li> <p>Developer-Driven Design:</p> <ul> <li>No formal specification written first</li> <li>Protocol emerged from understanding requirements</li> <li>Both developers contributed to shape the flow</li> </ul> </li> <li> <p>Flexibility Over Rigidity:</p> <ul> <li>\"Let's keep it flexible\" - design for change</li> <li>Multi-channel support added mid-conversation</li> <li>Progress updates added when need identified</li> </ul> </li> <li> <p>Message-as-Cube Approach:</p> <ul> <li>Each message type is a building block</li> <li>Combine HelloRequest + JobTicket + PDL Requests + Signals + ByeRequest</li> <li>Result: Complete print job processing workflow</li> </ul> </li> </ol>"},{"location":"mds/conversation/#translation-to-code","title":"Translation to Code","text":"<p>After this conversation, developers can:</p> <ol> <li> <p>Write Protocol Documentation: (Simple text file for Git)    <pre><code>PROTOCOL: Spool Server \u2194 RIP Worker\n\n1. Worker \u2192 Server: HelloRequest, PDL: PS|PDF\n2. Server \u2192 Worker: Multi-requests (job_id)\n    - First: JobTicket: JDF|PPD, body: ticket\n    - Rest: PDL: PS|PDF, body: data chunks\n3. Worker \u2192 Server: Signals, Progress: [N:M]\n4. Worker \u2192 Server: ByeRequest, Status + Progress\n5. Server \u2192 Worker: ByeResponse\n</code></pre></p> </li> <li> <p>Implement Using Tofu:</p> <ul> <li>Use tofu's Message structure</li> <li>Configure TCP server/client</li> <li>Implement message handlers</li> <li>No complex code generation needed</li> </ul> </li> <li> <p>Iterate Quickly:</p> <ul> <li>Test with real data</li> <li>Adjust headers as needed</li> <li>Add new message types if requirements change</li> </ul> </li> </ol>"},{"location":"mds/conversation/#comparison-with-traditional-approaches","title":"Comparison with Traditional Approaches","text":""},{"location":"mds/conversation/#api-first-grpc-rest-approach","title":"API-First (gRPC, REST) Approach","text":"<pre><code>// Would require formal IDL\nservice PrintServer {\n  rpc SubmitJob(JobRequest) returns (JobResponse);\n  rpc StreamPDL(stream PDLChunk) returns (stream Progress);\n  rpc GetStatus(JobID) returns (JobStatus);\n}\n\nmessage JobRequest {\n  string job_ticket_format = 1;  // JDF or PPD\n  bytes job_ticket = 2;\n  string pdl_type = 3;           // PS or PDF\n}\n\nmessage PDLChunk {\n  int64 job_id = 1;\n  bytes data = 2;\n  bool is_last = 3;\n}\n\n// ... more formal definitions\n</code></pre> <p>Problems:</p> <ul> <li>Requires IDL file before coding</li> <li>Code generation step needed</li> <li>Changes require regeneration</li> <li>Versioning complexity</li> <li>Lost flexibility</li> </ul>"},{"location":"mds/conversation/#tofu-message-first-approach","title":"Tofu (Message-First) Approach","text":"<pre><code>Conversation \u2192 Text Protocol \u2192 Implementation\n- No IDL needed\n- No code generation\n- Direct implementation\n- Easy to change\n- Full flexibility\n</code></pre> <p>Advantages:</p> <ul> <li>Start coding immediately after conversation</li> <li>Protocol is the documentation</li> <li>Changes are simple (add headers, adjust messages)</li> <li>Natural evolution based on real usage</li> </ul>"},{"location":"mds/conversation/#lessons-for-protocol-design","title":"Lessons for Protocol Design","text":""},{"location":"mds/conversation/#from-this-conversation","title":"From This Conversation","text":"<ol> <li> <p>Start with Connection Pattern:</p> <ul> <li>Who connects to whom?</li> <li>What capabilities need to be announced?</li> </ul> </li> <li> <p>Identify Message Roles:</p> <ul> <li>Requests that expect responses</li> <li>Signals for one-way notifications</li> <li>Multi-message sequences (job chunks)</li> </ul> </li> <li> <p>Use Headers for Metadata:</p> <ul> <li>PDL type (PS/PDF)</li> <li>Job ticket format (JDF/PPD)</li> <li>Progress indicators ([N:M])</li> </ul> </li> <li> <p>Leverage Message ID:</p> <ul> <li>Correlation across multi-message flows</li> <li>Business transaction ID (job_id = message_id)</li> </ul> </li> <li> <p>Design for Lifecycle:</p> <ul> <li>Connection establishment (Hello)</li> <li>Data exchange (Requests/Signals)</li> <li>Graceful termination (Bye)</li> </ul> </li> <li> <p>Plan for Scale:</p> <ul> <li>Multiple channels for parallel processing</li> <li>Clean separation (one job per channel)</li> </ul> </li> </ol>"},{"location":"mds/conversation/#next-steps-for-developers","title":"Next Steps for Developers","text":"<p>After this conversation, S and R would:</p> <ol> <li> <p>Write Brief Protocol Doc: (Save in Git)</p> <ul> <li>Copy conversation or summary</li> <li>Add message format details</li> <li>Document headers</li> </ul> </li> <li> <p>Create Test Scenarios:</p> <ul> <li>Single job end-to-end</li> <li>Multi-job parallel processing</li> <li>Error handling (corrupted PDL)</li> </ul> </li> <li> <p>Implement Incrementally:</p> <ul> <li>Basic connection first</li> <li>Single job flow</li> <li>Progress updates</li> <li>Multi-job support</li> </ul> </li> <li> <p>Iterate Based on Reality:</p> <ul> <li>Discover edge cases</li> <li>Adjust message flow</li> <li>Add new headers as needed</li> </ul> </li> </ol>"},{"location":"mds/conversation/#conclusion","title":"Conclusion","text":"<p>This conversation exemplifies tofu's philosophy:</p> <p>\"Connect your developers. Then connect your applications.\"</p> <p>The protocol emerged naturally from:</p> <ul> <li>Understanding requirements (print job processing)</li> <li>Developer expertise (PDL types, job tickets)</li> <li>Practical constraints (unknown worker addresses)</li> <li>Refinement through discussion (progress updates, graceful close)</li> </ul> <p>Result: A working protocol defined in 15 lines of conversation, implemented with simple message passing, flexible enough to evolve.</p> <p>No API specs. No code generation. No framework lock-in. Just messages flowing between peers.</p>"},{"location":"mds/features/","title":"Features","text":"<ul> <li>Message-Based: Uses discrete messages for communication.</li> <li>Asynchronous: Enables non-blocking message exchanges.</li> <li>Duplex: Supports two-way communication.</li> <li>Peer-to-Peer: Allows equal roles after connection establishment.</li> <li>Stream oriented transport - TCP/IP and Unix Domain Sockets</li> <li>Multithread-friendly - All APIs are safe for concurrent access.</li> <li>Memory management for messages - Internal message pool</li> <li>Backpressure management - Allows to control receive of messages</li> <li>Customizable application flows - Allows to build various application flows not restricted to request/response or pub/sub</li> <li>Simplest API - You don't have to bother with or know the \"guts\" of socket interfaces</li> <li>DIY - No enforced authentication or serialization; provides features to design and implement your own.</li> <li>Callback enabled - This will be explained later. </li> </ul>"},{"location":"mds/imports/","title":"Imports","text":"<p>All examples assume that the snippet below is added to your code.</p> <pre><code>const std = @import(\"std\");\nconst log = std.log;\nconst Allocator = std.mem.Allocator;\nconst assert = std.debug.assert;\n\nconst testing = std.testing;\n\n// Import of module 'tofu'\npub const tofu = @import(\"tofu\");\n\n// Reactor: The single-threaded, event-driven implementation\n// of the Ampe interface. It utilizes the Reactor pattern to multiplex\n// non-blocking socket I/O via an internal poll-style loop.\npub const Reactor = tofu.Reactor;\n\npub const Ampe = tofu.Ampe;\n\n// Contains settings for the internal message pool.\npub const Options = tofu.Options;\n\n// The default configuration options for the pool.\npub const DefaultOptions = tofu.DefaultOptions;\n\n// A grouping mechanism for managing a collection of related channels.\npub const ChannelGroup = tofu.ChannelGroup;\n\npub const message = tofu.message;\n\n// The core Message structure processed by the engine.\npub const Message = tofu.Message;\n\n// Meta-data for the Message.\n// Used internally by the engine for routing and by the application for context.\npub const BinaryHeader = message.BinaryHeader;\n\npub const status = tofu.status;\n// An enum representation of the status byte\n// (part of BinaryHeader) for clear status tracking.\npub const AmpeStatus = status.AmpeStatus;\n// An error type corresponding to the status above,\n// used for conveying failure states.\npub const AmpeError = status.AmpeError;\n\n// Helpers - for convenient injection of socket addresses\n// to the message.\npub const configurator = tofu.configurator;\npub const Configurator = configurator.Configurator;\n</code></pre> <p>And don't forget to assign suitable allocator, e.g.: <pre><code>    var dbalctr = std.heap.DebugAllocator(.{}).init;\n    defer {\n        const deinit_status = dbalctr.deinit();\n        // fail test; can't try in defer as defer is executed after we return\n        if (deinit_status == .leak) {\n            std.log.err(\"memory leak detected\", .{});\n        }\n    }\n\n    const gpa: Allocator = dbalctr.allocator();\n</code></pre></p>"},{"location":"mds/installation/","title":"Installation","text":"<p>Add tofu to build.zig.zon: <pre><code>zig fetch --save git+https://github.com/g41797/tofu\n</code></pre></p> <p>Add tofu to build.zig:</p> Add dependency<pre><code>    const tofu: *build.Dependency = b.dependency(\"tofu\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n</code></pre> <p>For any xyz_mod module that uses tofu, add the following code<pre><code>    xyz_mod.addImport(\"tofu\", tofu.module(\"tofu\"));\n</code></pre> Import tofu<pre><code>pub const tofu = @import(\"tofu\");\n</code></pre></p>"},{"location":"mds/key-ingredients/","title":"Key ingredients","text":"<p>Tofu has only three main ingredients:</p> <ul> <li>Ampe \u2014 the Async Message Passing Engine (we call it the engine).</li> <li>ChannelGroup</li> <li>Message</li> </ul> <p>Each ingredient depends on the others, so it\u2019s hard to explain one without understanding the rest. Because of that, the short descriptions below give only the basic idea.</p> <p>The examples later will help you understand how tofu really works.</p>"},{"location":"mds/key-ingredients/#separation-of-concerns","title":"Separation of Concerns","text":""},{"location":"mds/key-ingredients/#logical-separation","title":"Logical Separation","text":"<p>The Engine owns all resources in Tofu software. It allocates and destroys Message(s) and ChannelGroup(s).</p> <p>The ChannelGroup handles async, two-way exchange of Messages.</p> <p>The Message does two things:</p> <ul> <li>Holds business data and metadata.</li> <li>Works as a command for Tofu.</li> </ul>"},{"location":"mds/key-ingredients/#physical-separation","title":"Physical Separation","text":"<p>The Engine name shows the real work it does. Every engine runs one internal thread with a poll loop. This loop handles all socket operations.</p> <p>The Ampe interface is implemented by the Reactor structure.</p> <p>All ChannelGroups share one internal socket to talk to the engine thread.</p> <p>Each ChannelGroup uses an internal queue for messages (from engine or application).</p> <p>The ChannelGroup is a thin layer. It forwards messages between application and engine thread.</p>"},{"location":"mds/key-ingredients/#tofu-based-communication-flow","title":"Tofu-based Communication Flow","text":"<p>The steps below show how communication works between network participants, called peers:</p> <ul> <li>Initialization: The peer creates a Reactor to get the Ampe interface.</li> <li>Channel Setup: The peer creates a ChannelGroup to manage channels (connections to other peers).</li> <li>Core Loop: In the main application loop, the peer:</li> <li>Sends: Gets Messages from Ampe, fills data, enqueues via ChannelGroup.</li> <li>Receives: Gets and processes incoming messages from other peers.</li> </ul> <p>This is a simple overview. Later sections show full logic and message lifecycle.</p>"},{"location":"mds/mantra/","title":"Mantra","text":"<p>Connect your developers. Then connect your applications.</p> <p>This tofu mantra is a paraphrase of Conway's Law.</p> <p>tofu \"expects\" that development starts with a conversation (connection) similar to the one shown below.</p> <p>Context:</p> <ul> <li>Two developers are discussing the message flow for a new Print Server.</li> <li>The first one is the Spool Server developer (S).</li> <li>The second one develops the RIP Worker Process (R).</li> <li>Don\u2019t worry \u2014 RIP means Raster Image Processing, not what you might think.</li> <li>Some terms may be unknown \u2014 that\u2019s fine. These two know exactly what they mean.</li> </ul> <p>This dialog is shown without the usual jokes or side comments common in real programmer discussions \u2014 just the technical part.</p> <pre><code>S: I don't know the addresses of the workers, so you should connect to me.\n\nR: I'll send a HelloRequest, because the worker can process only specific PDL types,\n   the PDL header will contain either PS or PDF.\n\nS: Do I need to send you a HelloResponse?\n\nR: No, just start sending me messages with PDL data.\n\nS: As signals?\n\nR: No, as multi-requests \u2014 each with a message ID equal to the job ID.\n\nS: You forgot the Job Ticket.\n\nR: Right. The first request should have a JobTicket header (JDF or PPD) and the\n   ticket data in the body. The following requests will have the PDL header\n   (PDF or PS) with the related content.\n\nS: But JDF is usually used only for PDF...\n\nR: Yes, but let's keep it flexible.\n\nS: Can you process several jobs simultaneously?\n\nR: It depends on licensing. Anyway, if I can, I'll send another HelloRequest \u2014\n   working one job per channel looks cleaner.\n\nS: I need a progress indicator.\n\nR: No problem. I'll send signals with the same message ID \u2014 the Progress header\n   will show the range [N:M] for page numbers.\n\nS: On job finish, send me a Response with the same message ID and processing status.\n   Also include the Progress header.\n\nR: Why should I send an obsolete message? Are you expecting a graceful close?\n\nS: Of course.\n\nR: Then I'll send a ByeRequest with the same information, and you'll send me a\n   ByeResponse. After that, I'll abort the connection immediately.\n\nS: That's enough for today. Send me a short text file with this protocol \u2014\n   I'll save it in Git.\n\nR: Deal. How about a cup of coffee?\n</code></pre> <p>I hope you got the point without long smart descriptions or advertising.</p>"},{"location":"mds/naq/","title":"NAQ","text":"What's NAQ? <p>I always wondered why even if the program is not used by anyone, there is still a FAQ section. Even if a question was asked once, why 'frequently'? That's why I use a more honest name: NAQ - Never Asked Questions. I ask myself. I answer myself. You didn't ask. Not even about NAQ.</p> <p>You will see 'NAQ' sections in different places throughout this documentation. I hope they will help clarify the content of the documentation.</p>"},{"location":"mds/overview/","title":"Overview","text":"<p>tofu is a protocol and an asynchronous Zig messaging library used to:</p> <ul> <li>Build custom communication flows.</li> <li>Create non-blocking systems.</li> <li>Enable peer-to-peer messaging between applications.</li> </ul> <p>tofu is a completely new project. It is not a port of old code, and it does not use any C libraries. It is built 100% in native Zig. The core functionality uses only the standard library.</p>"},{"location":"mds/overview/#why-tofu","title":"Why tofu?","text":"<p>As a food, tofu is very simple and has almost no flavor on its own. By using tofu cubes, you can:</p> <ul> <li>Eat it plain for a simple snack.</li> <li>Add a little spice to make it better.</li> <li>Create a culinary masterpiece.</li> </ul> <p>As a protocol, tofu uses messages like cubes. By \"cooking\" these messages together, you can grow your project:</p> <ul> <li>Start with minimal setups.</li> <li>Build complex flows.</li> <li>Create full distributed applications.</li> </ul> <p>Remember</p> <p>tofu is as good as you are a cook.</p>"},{"location":"mds/overview/#a-bit-of-history","title":"A Bit of History","text":"<p>tofu did not come from nowhere.</p> <p>The journey began in 2008 when I first built a similar system. I maintained and ran that system for many years in high-stakes environments. It powered everything from basic IPC to complex data transfers in a custom distributed file system.</p> <p>I left that project a few years ago, but I haven't heard any complaints yet \u2014 the systems are still running strong.</p> <p>Corporate lawyers can stay calm: I didn't take any code. I only took the \"smell.\" (See the precedent case about paying for a smell).</p> <p>By \"smell,\" I mean the core philosophy:</p> <ul> <li>The Message is the API: The data itself defines the connection.</li> <li>Gradual Evolution: Start with something simple and grow it into a powerful system over time.</li> <li>The Mantra: \"Connect your developers. Then connect your applications.\"</li> </ul>"},{"location":"mds/overview/#credits","title":"Credits","text":"<ul> <li>Karl Seguin \u2014 for introducing me to Zig networking</li> <li>Franck Blettner \u2014 for creating the template repository for documentation sites, which this documentation is based on </li> <li>Zig Community Forums (in order of my registration) - for your help and patience with my posts<ul> <li>Zig on Reddit</li> <li>Zig on Discord</li> <li>Zig on Discourse</li> </ul> </li> </ul>"},{"location":"mds/overview/#last-but-not-least","title":"Last but not least","text":"<p>\u2b50\ufe0f Like, share, and don\u2019t forget to subscribe to the channel !</p>"},{"location":"mds/protocol/","title":"Protocol","text":"<p>Well, calling it a \u201cprotocol\u201d might be saying too much.  It\u2019s more like a description that doesn\u2019t depend on any specific implementation.</p> <p>There are 3 participants :</p> <ul> <li>Messages</li> <li>Channels</li> <li>Engine</li> </ul>"},{"location":"mds/protocol/#engine","title":"Engine","text":"<p>The Engine\u2019s API is not defined \u2014 it depends on the implementation. </p> <p>What matters is that when the engine gets a message from the application, it</p> <ul> <li>checks the message\u2019s metadata </li> <li>creates a channel if needed</li> <li>sends the message to that channel\u2019s outgoing queue</li> </ul> <p>Also</p> <ul> <li>receives messages from the network</li> <li>returning them through the right channel.</li> </ul> <p>It also analyzes network issues and notifies the client code.</p> <p>All of these runs asynchronously, independent of the rest of the process code.</p> <p>Engine contains a set of channels (zero or more). The maximum number depends on the implementation.</p>"},{"location":"mds/protocol/#channel","title":"Channel","text":"<p>Think of a channel as a virtual socket.</p> <p>There are two kinds of channels:</p> <ul> <li>Listener \u2013 Analog of a listener socket.</li> <li>IO \u2013 Analog of client socket or accepted server socket.</li> </ul> NAQ: Why not just Socket <p>You cannot send messages to an unconnected socket, but it ok with channel.</p> <p>Channels are identified by a channel number in the range [1-65534].</p> <p>Two channel number values are reserved:</p> <ul> <li>0 \u2013 Unassigned channel number</li> <li>65535 \u2013 Tofu internal channel number</li> </ul> <p>Channel numbers are unique within the engine that created them, from creation until closure.</p> <p>Warn</p> <p>Another engine in the same process or an engine in a different process may assign the same channel number simultaneously.</p> <p>Every channel has 3 internal states:</p> <ul> <li>opened - engine assigned channel number</li> <li>ready<ul> <li>IO channel - ready for send/receive messages</li> <li>Listener channel - ready for accept incoming connections</li> </ul> </li> <li>closed</li> </ul>"},{"location":"mds/sockets101/","title":"Sockets 101","text":"<p>Because tofu uses sockets under the hood, you still need to understand:</p> <ul> <li>the addressing scheme</li> <li>the correct order of creating sockets</li> <li>the difference between client and server sides</li> <li>socket tuning</li> </ul>"},{"location":"mds/sockets101/#what-is-a-socket","title":"What is a Socket?","text":"<p>A socket is a software endpoint. It lets two programs communicate. This can be on the same computer or across a network.</p>"},{"location":"mds/sockets101/#stream-oriented-sockets","title":"Stream-Oriented Sockets","text":"<p>These use a reliable, ordered, connection-based protocol. TCP (Transmission Control Protocol) is the main example. Data is sent as a continuous stream of bytes. It guarantees all data arrives correctly.</p>"},{"location":"mds/sockets101/#socket-families-protocols","title":"Socket Families (Protocols)","text":"<p>Sockets use different communication protocol families.</p>"},{"location":"mds/sockets101/#1-tcpip-sockets","title":"1. TCP/IP Sockets","text":"<p>For network communication. Uses IP addresses to identify machines. TCP/IP is the foundation of the internet.</p>"},{"location":"mds/sockets101/#2-unix-domain-sockets-uds","title":"2. Unix Domain Sockets (UDS)","text":"<p>For local communication only. Works on the same computer. No network hardware needed. Often faster than TCP/IP for local processes.</p>"},{"location":"mds/sockets101/#socket-operations","title":"Socket Operations","text":"<p>Sockets follow this lifecycle.</p>"},{"location":"mds/sockets101/#1-create","title":"1. Create","text":"<p>First step: create the socket. This reserves system resources. Gives you a handle (file descriptor) for later use.</p>"},{"location":"mds/sockets101/#2-client-connect","title":"2. Client: Connect","text":"<p>Client uses connect(). Links its socket to the server's address. If successful, communication stream opens.</p>"},{"location":"mds/sockets101/#3-server-listen-and-accept","title":"3. Server: Listen and Accept","text":"<p>Server waits for client connections.</p> <ul> <li>Bind: Attach socket to specific local address.</li> <li>Listen: Wait for incoming connection requests.</li> <li>Accept: When client connects, accept() returns.<ul> <li>Creates a second, new socket.</li> <li>Original socket stays as listener.</li> <li>New socket handles data with that client.</li> </ul> </li> </ul>"},{"location":"mds/sockets101/#4-disconnect-close","title":"4. Disconnect (Close)","text":"<p>Communication ends when socket closes.</p> <ul> <li>Graceful close: Clean shutdown, data sent completely.</li> <li>Non-graceful close: Sudden close, data may be lost.</li> </ul>"},{"location":"mds/sockets101/#addresses-tcpip","title":"Addresses - TCP/IP","text":"<p>TCP/IP addresses combine IP address + port number.</p>"},{"location":"mds/sockets101/#server-address-bind","title":"Server Address (Bind)","text":"<p>Server binds to local IP address. Uses fixed port number (22, 80, 443).</p> <p>Specific Adapter: 192.168.1.10:80 - Only accepts connections to that IP.</p> <p>All Adapters (Wildcard): 0.0.0.0:8080 - Listens on all network cards on port 8080.</p>"},{"location":"mds/sockets101/#client-address-connect","title":"Client Address (Connect)","text":"<p>Client uses server's IP or hostname + port. Client gets temporary ephemeral port automatically.</p> <p>Example: Client connects to 192.168.1.10:80 Client local: 10.0.0.5:54321 (ephemeral port)</p>"},{"location":"mds/sockets101/#addresses-unix-domain-sockets-uds","title":"Addresses - Unix Domain Sockets (UDS)","text":"<p>No IP addresses or ports.</p> <p>Uses file system path instead. Example: /tmp/service.sock</p> <p>Server binds to path. Client connects to same path.</p>"},{"location":"mds/sockets101/#how-linux-tracks-sockets","title":"How Linux Tracks Sockets","text":""},{"location":"mds/sockets101/#file-descriptor-fd-socket-handle","title":"File Descriptor (FD) = Socket Handle","text":"<p>Every socket gets a small number (FD). Like an ID for your program. Example: socket_fd = 5</p> <p>Use it to read/write/close: send(5, ...), close(5)</p>"},{"location":"mds/sockets101/#fd-is-unique-only-inside-one-process","title":"FD is unique only inside one process","text":"<p>Process A: FD=3 Process B: FD=3 (different socket) OS uses (PID + FD) to identify real socket.</p>"},{"location":"mds/sockets101/#socket-tuning-with-options","title":"Socket tuning with options","text":""},{"location":"mds/sockets101/#reuse-port-quickly-so_reuseaddr-option","title":"Reuse Port Quickly - SO_REUSEADDR option","text":"<p>When TCP connection closes, socket enters TIME_WAIT state. Lasts 1-4 minutes.</p> <p>During TIME_WAIT: - System blocks new program from using same port.</p> <p>Problems: - Cannot restart server fast. - Testing slow (start/stop many times).</p> <p>SO_REUSEADDR fixes this.</p> <p>tofu sets SO_REUSEADDR on all listening sockets.</p> <p>Result: Every new tofu TCP server uses same port immediately.</p>"},{"location":"mds/sockets101/#socket-closing-modes-so_linger-option","title":"Socket closing modes - SO_LINGER option","text":"<p>Normal socket close:</p> <ul> <li>close() returns right away</li> <li>System sends remaining data in background (graceful close)</li> </ul> <p>SO_LINGER changes this.</p> <p>tofu uses only non-graceful (hard) close:</p> <ul> <li>close() returns immediately</li> <li>Connection closes instantly (reset)</li> <li>All unsent data discarded</li> </ul> <p>Get graceful close using other tofu features instead.</p>"},{"location":"mds/specification/","title":"PROJECT ARCHITECTURE &amp; IMPLEMENTATION","text":"<p>This section describes the tofu project comprehensively, independent of porting concerns.</p>"},{"location":"mds/specification/#11-high-level-philosophy","title":"1.1 High-Level Philosophy","text":""},{"location":"mds/specification/#core-principles","title":"Core Principles","text":"<p>1. \"The Message is the API\"</p> <ul> <li>The data structure itself defines the communication contract</li> <li>No complex API interfaces, RPC definitions, or service interfaces required upfront</li> <li>The message structure IS the contract</li> </ul> <p>2. \"Gradual Evolution\"</p> <ul> <li>Start with something simple and grow it into a powerful system over time</li> <li>Begin with basic message exchange, then add complexity as needed</li> </ul> <p>3. \"Connect your developers. Then connect your applications.\"</p> <ul> <li>Development starts with a conversation between developers, not with API specifications</li> <li>See the S/R Dialog pattern in README.md for exemplar</li> </ul>"},{"location":"mds/specification/#the-message-as-cube-metaphor","title":"The Message-as-Cube Metaphor","text":"<p>As food, tofu is very simple and has almost no flavor on its own. By using tofu cubes, you can:</p> <ul> <li>Eat it plain for a simple snack</li> <li>Add a little spice to make it better</li> <li>Create a culinary masterpiece</li> </ul> <p>As a protocol, tofu uses messages like cubes. By \"cooking\" these messages together, you can grow your project:</p> <ul> <li>Start with minimal setups</li> <li>Build complex flows</li> <li>Create full distributed applications</li> </ul>"},{"location":"mds/specification/#what-tofu-provides","title":"What Tofu Provides","text":"<ul> <li>Foundation layer for asynchronous message passing</li> <li>Stream-oriented transport (TCP/IP and Unix Domain Sockets)</li> <li>Pool-based memory management with backpressure control</li> <li>Thread-safe APIs for multi-threaded applications</li> <li>Reactor pattern for efficient I/O multiplexing</li> <li>Peer-to-peer, full-duplex communication after handshake</li> </ul>"},{"location":"mds/specification/#what-tofu-does-not-provide","title":"What Tofu Does NOT Provide","text":"<ul> <li>High-level serialization (JSON, Protobuf, etc.) - user chooses</li> <li>Authentication/authorization - user implements</li> <li>Load balancing, service discovery - user designs</li> <li>Opinionated business logic patterns</li> </ul>"},{"location":"mds/specification/#12-system-architecture","title":"1.2 System Architecture","text":""},{"location":"mds/specification/#top-level-components","title":"Top-Level Components","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Application Layer                    \u2502\n\u2502  (User code using tofu API - Services, Clients, etc.)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510\n\u2502                  Public API Layer                        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502      Ampe        \u2502        \u2502   ChannelGroup       \u2502    \u2502\n\u2502  \u2502   Interface      \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    Interface         \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502         \u2502                              \u2502                 \u2502\n\u2502         \u2502                              \u2502                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502              Message Pool                          \u2502  \u2502\n\u2502  \u2502  (Pool.zig - LIFO, mutex-protected)                \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               Engine Layer (Reactor)                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502   Reactor    \u2502  \u2502   Notifier  \u2502  \u2502ActiveChannels  \u2502  \u2502\n\u2502  \u2502  (Event Loop)\u2502  \u2502 (socketpair)\u2502  \u2502  (Registry)    \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502         \u2502                 \u2502                    \u2502        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502           Poller (poll/epoll/kqueue)               \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    OS Layer                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  TCP Sockets   \u2502          \u2502   Unix Domain Sockets\u2502   \u2502\n\u2502  \u2502  (non-blocking)\u2502          \u2502     (non-blocking)   \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"mds/specification/#component-responsibilities","title":"Component Responsibilities","text":"Component Responsibility Thread Safety Ampe Interface Message pool operations (get/put), ChannelGroup lifecycle Thread-safe (all methods) ChannelGroup Interface Message exchange (send/receive), receiver updates Mixed (see threading model) Reactor Event loop, I/O multiplexing, message dispatch Internal only (single thread) Pool Message lifecycle, allocation strategy, backpressure Thread-safe (mutex) ActiveChannels Channel registry, random channel allocation, ownership validation Thread-safe (mutex) Notifier Cross-thread notifications via socketpair Thread-safe (producer-consumer) Poller OS-specific I/O polling abstraction Internal only (Reactor thread) Message Data structure with header, text headers, body User-managed (pool lifecycle) MchnGroup ChannelGroup implementation with dual mailboxes Thread-safe (per interface spec)"},{"location":"mds/specification/#13-message-structure-core-data-type","title":"1.3 Message Structure (Core Data Type)","text":""},{"location":"mds/specification/#message-anatomy","title":"Message Anatomy","text":"<p>Every message has three logical parts:</p>"},{"location":"mds/specification/#part-1-persistent-fields-transmitted-over-wire","title":"Part 1: Persistent Fields (Transmitted Over Wire)","text":"<p>BinaryHeader (16 bytes, packed, big-endian on wire): <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 channel_number  \u2502 proto        \u2502 status  \u2502 message_id   \u2502  &lt;thl&gt;   \u2502  &lt;bl&gt;    \u2502\n\u2502    (u16)        \u2502 (ProtoFields)\u2502  (u8)   \u2502   (u64)      \u2502  (u16)   \u2502  (u16)   \u2502\n\u2502    2 bytes      \u2502   1 byte     \u2502 1 byte  \u2502   8 bytes    \u2502  2 bytes \u2502  2 bytes \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nTotal: 16 bytes\n</code></pre></p> <p>ProtoFields (8 bits packed):</p> <ul> <li><code>mtype</code> (3 bits): Message type - <code>.welcome</code>, <code>.hello</code>, <code>.bye</code>, <code>.regular</code></li> <li><code>role</code> (2 bits): Message role - <code>.request</code>, <code>.response</code>, <code>.signal</code></li> <li><code>origin</code> (1 bit): Origin - <code>.application</code>, <code>.engine</code></li> <li><code>more</code> (1 bit): More messages in sequence - <code>.last</code>, <code>.expected</code></li> <li><code>oob</code> (1 bit): Out-of-band (priority) - <code>.off</code>, <code>.on</code></li> </ul> <p>TextHeaders (Optional, HTTP-style key-value pairs):</p> <pre><code>Key1: Value1\\r\\n\nKey2: Value2\\r\\n\n\\r\\n\n</code></pre> <ul> <li>Used for configuration (IP addresses, ports, paths)</li> <li>Used for application metadata (job tickets, progress indicators, etc.)</li> <li>Engine manages length in <code>&lt;thl&gt;</code> field</li> <li>HTTP-like parsing with iterator</li> </ul> <p>Body (Optional, application payload):</p> <ul> <li>Appendable buffer (dynamically growing)</li> <li>Engine does not interpret contents</li> <li>Engine manages length in <code>&lt;bl&gt;</code> field</li> <li>Can hold binary or text data</li> </ul>"},{"location":"mds/specification/#part-2-transient-fields-not-transmitted","title":"Part 2: Transient Fields (NOT Transmitted)","text":"<pre><code>@\"&lt;void*&gt;\": ?*anyopaque  // Application-specific pointer (user can use)\n@\"&lt;ctx&gt;\": ?*anyopaque    // Engine-internal context pointer (engine uses)\n</code></pre>"},{"location":"mds/specification/#part-3-intrusive-list-nodes","title":"Part 3: Intrusive List Nodes","text":"<pre><code>prev: ?*Message  // Previous message in queue\nnext: ?*Message  // Next message in queue\n</code></pre> <ul> <li>Enables zero-allocation queuing via intrusive linked lists</li> <li>Used by Pool, Mailboxes, and internal queues</li> </ul>"},{"location":"mds/specification/#message-lifecycle","title":"Message Lifecycle","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Pool: Initialize\n    Pool --&gt; InUse: get() - Application acquires\n    InUse --&gt; ConfiguredLocal: Set fields (bhdr, thdrs, body)\n    ConfiguredLocal --&gt; Sent: enqueueToPeer() - Ownership transfers\n    Sent --&gt; InFlight: Engine serializes &amp; sends\n    InFlight --&gt; Received: Peer receives\n    Received --&gt; Pool: put() - Application releases\n    Pool --&gt; [*]: Shutdown\n\n    note right of InUse\n        Application owns message\n        Must call put() via defer\n    end note\n\n    note right of Sent\n        Message pointer becomes NULL\n        Cannot be used after send\n    end note\n\n    note right of Received\n        New message from pool\n        Contains received data\n    end note</code></pre> <p>Critical Ownership Rule: After <code>enqueueToPeer(&amp;msg)</code>, the message pointer becomes NULL. Application cannot use message after send. This prevents use-after-free bugs at compile time.</p>"},{"location":"mds/specification/#message-validation","title":"Message Validation","text":"<p>Before sending, messages undergo validation via <code>check_and_prepare()</code>:</p> <p>Valid Combinations (ValidCombination enum):</p> <ol> <li> <p>Welcome/Hello:</p> <ul> <li><code>mtype</code>: <code>.welcome</code> or <code>.hello</code></li> <li><code>role</code>: <code>.request</code> or <code>.response</code></li> <li><code>channel_number</code>: Must be 0 (special)</li> </ul> </li> <li> <p>Regular Request:</p> <ul> <li><code>mtype</code>: <code>.regular</code></li> <li><code>role</code>: <code>.request</code></li> <li><code>channel_number</code>: Non-zero</li> <li><code>message_id</code>: Auto-generated if 0</li> </ul> </li> <li> <p>Regular Response:</p> <ul> <li><code>mtype</code>: <code>.regular</code></li> <li><code>role</code>: <code>.response</code></li> <li><code>channel_number</code>: Non-zero</li> <li><code>message_id</code>: Must be non-zero (matches request)</li> </ul> </li> <li> <p>Regular Signal:</p> <ul> <li><code>mtype</code>: <code>.regular</code></li> <li><code>role</code>: <code>.signal</code></li> <li><code>channel_number</code>: Non-zero</li> <li><code>message_id</code>: Auto-generated if 0</li> </ul> </li> <li> <p>Bye:</p> <ul> <li><code>mtype</code>: <code>.bye</code></li> <li><code>role</code>: <code>.request</code>, <code>.response</code>, or <code>.signal</code></li> <li><code>channel_number</code>: Non-zero</li> </ul> </li> </ol> <p>Validation Checks:</p> <ul> <li>Headers length fits in u16 (<code>&lt;thl&gt;</code>)</li> <li>Body length fits in u16 (<code>&lt;bl&gt;</code>)</li> <li>Type/role combination is valid</li> <li>Channel number constraints respected</li> <li>Response has non-zero message_id</li> </ul>"},{"location":"mds/specification/#14-reactor-pattern-event-loop","title":"1.4 Reactor Pattern (Event Loop)","text":""},{"location":"mds/specification/#reactor-thread-lifecycle","title":"Reactor Thread Lifecycle","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Creating: Reactor.Create()\n    Creating --&gt; Initializing: Allocate structures\n    Initializing --&gt; Starting: Spawn reactor thread\n    Starting --&gt; Polling: Enter event loop\n\n    Polling --&gt; Processing: Events detected\n    Processing --&gt; SendMessages: Process send queue\n    SendMessages --&gt; ReceiveMessages: Process socket reads\n    ReceiveMessages --&gt; HandleNotifications: Check notifier\n    HandleNotifications --&gt; Polling: Continue loop\n\n    Polling --&gt; ShuttingDown: Shutdown signal\n    ShuttingDown --&gt; Cleanup: Close sockets, free resources\n    Cleanup --&gt; [*]: Thread exits\n\n    note right of Polling\n        poll/epoll/kqueue waits for:\n        - Socket readable\n        - Socket writable\n        - Notifier event\n    end note\n\n    note right of Processing\n        Single-threaded:\n        - No locks needed\n        - Sequential processing\n    end note</code></pre>"},{"location":"mds/specification/#reactor-components","title":"Reactor Components","text":"<p>1. Poller (poller.zig)</p> <ul> <li>Abstraction over OS-specific polling mechanisms</li> <li>Linux: <code>epoll</code> (epoll_create1, epoll_ctl, epoll_wait)</li> <li>BSD/macOS: <code>kqueue</code> (kqueue, kevent)</li> <li>Fallback: <code>poll</code> (poll syscall)</li> <li>Manages file descriptor interest registration</li> <li>Returns triggered sockets on each poll cycle</li> </ul> <p>2. TriggeredChannels (triggeredSkts.zig)</p> <ul> <li>Maps socket fd \u2192 channel number</li> <li>Stores which channels have I/O events</li> <li>Read events vs. Write events tracking</li> <li>Cleared each poll cycle</li> </ul> <p>3. Notifier (Notifier.zig)</p> <ul> <li>Purpose: Wake reactor thread from blocking poll</li> <li>Mechanism: Socketpair (or UDS on Linux)<ul> <li>Sender socket: Application threads write to this</li> <li>Receiver socket: Reactor thread polls this</li> </ul> </li> <li>Notification Types:<ul> <li><code>message</code>: New message to send (from mailbox)</li> <li><code>alert</code>: Pool freed memory or shutdown started</li> </ul> </li> <li>Format: 8-bit packed notification<ul> <li><code>kind</code> (1 bit): message vs alert</li> <li><code>oob</code> (1 bit): out-of-band flag</li> <li><code>vc</code> (4 bits): ValidCombination hint</li> <li><code>at</code> (2 bits): AlertType (pool freed, shutdown, etc.)</li> </ul> </li> </ul> <p>4. Mailboxes (dual MSGMailBox)</p> <ul> <li>Structure: Two intrusive mailboxes per MchnGroup<ul> <li><code>msgs[0]</code>: Send queue (app \u2192 engine)</li> <li><code>msgs[1]</code>: Receive queue (engine \u2192 app)</li> </ul> </li> <li>Implementation: Intrusive queue (MailBoxIntrusive from external library)</li> <li>Thread Safety: Lock-free producer-consumer pattern</li> <li>Blocking: <code>send()</code> and <code>receive()</code> can block/timeout</li> </ul> <p>5. ActiveChannels (channels.zig)</p> <ul> <li>Purpose: Registry of all active channels</li> <li>Channel Allocation: Random u16 (excluding 0 and u16::MAX)<ul> <li>Avoids sequential predictability</li> <li>Circular buffer tracks recently removed channels (prevents immediate reuse)</li> </ul> </li> <li>Validation: <code>check()</code> method ensures channel belongs to correct ChannelGroup</li> <li>Thread Safety: Mutex-protected</li> <li>Data Structure: <code>std.AutoArrayHashMap(ChannelNumber, ActiveChannel)</code><ul> <li>ActiveChannel contains: channel number, message_id, proto fields, context pointer</li> </ul> </li> </ul>"},{"location":"mds/specification/#reactor-event-loop-pseudocode","title":"Reactor Event Loop Pseudocode","text":"<pre><code>function reactorLoop():\n    while not shutdown:\n        // 1. Poll for I/O events (with timeout)\n        triggered_sockets = poller.poll(timeout_ms)\n\n        // 2. Process notifier events first (highest priority)\n        if notifier.receiver in triggered_sockets:\n            notification = notifier.readNotification()\n            if notification.kind == shutdown:\n                shutdown = true\n                continue\n            if notification.kind == alert:\n                handlePoolAlert()\n\n        // 3. Process send queue (messages from application)\n        while sendMailbox.hasMessages():\n            msg = sendMailbox.dequeue()\n\n            if msg.isHelloOrWelcome():\n                handleConnectionRequest(msg)\n            else if msg.isBye():\n                handleDisconnection(msg)\n            else:\n                enqueueForSocketWrite(msg)\n\n        // 4. Process writable sockets (send pending data)\n        for each socket in triggered_sockets where writable:\n            if hasDataToSend(socket):\n                bytesSent = socket.send(data)\n                if fully_sent:\n                    removePendingSend(socket)\n\n        // 5. Process readable sockets (receive data)\n        for each socket in triggered_sockets where readable:\n            if socket.isListener():\n                newClient = socket.accept()\n                sendHelloToApp(newClient)\n            else:\n                data = socket.receive()\n                msg = parseMessage(data)\n                receiveMailbox.enqueue(msg)\n                notifyApplication()  // Wake waitReceive()\n\n        // 6. Handle socket errors\n        for each socket in triggered_sockets where error:\n            sendChannelClosedStatus(socket.channel)\n            closeSocket(socket)\n</code></pre>"},{"location":"mds/specification/#connection-state-machine","title":"Connection State Machine","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; WelcomeRequest: Server sends (ch=0)\n    WelcomeRequest --&gt; Listening: Engine creates listener\n    Listening --&gt; WelcomeResponse: Success/Error status\n\n    [*] --&gt; HelloRequest: Client sends (ch=0)\n    HelloRequest --&gt; Connecting: Engine connects socket\n    Connecting --&gt; HelloSent: TCP handshake complete\n    HelloSent --&gt; WaitHelloResponse: Sent on wire\n\n    Listening --&gt; NewConnection: accept() returns\n    NewConnection --&gt; AssignChannel: Random ch# generated\n    AssignChannel --&gt; HelloReceived: Send to app\n    HelloReceived --&gt; HelloResponseSent: App responds\n\n    WaitHelloResponse --&gt; Connected: Receive HelloResponse\n    HelloResponseSent --&gt; Connected: Both peers ready\n\n    Connected --&gt; RegularMessaging: Exchange messages\n    RegularMessaging --&gt; Connected: Continue\n\n    Connected --&gt; ByeRequest: Graceful close\n    ByeRequest --&gt; ByeResponse: Peer confirms\n    ByeResponse --&gt; ChannelClosed: Clean shutdown\n\n    Connected --&gt; ByeSignal: Force close (oob=on)\n    ByeSignal --&gt; ChannelClosed: Immediate\n\n    Connected --&gt; SocketError: Network failure\n    SocketError --&gt; ChannelClosed: Send error status\n\n    ChannelClosed --&gt; [*]</code></pre>"},{"location":"mds/specification/#15-memory-management","title":"1.5 Memory Management","text":""},{"location":"mds/specification/#pool-architecture","title":"Pool Architecture","text":"<p>Design Pattern: LIFO (Last In, First Out) pool for cache locality</p> <p>Structure (Pool.zig): <pre><code>Pool {\n    allocator: Allocator           // GPA-compatible allocator\n    mutex: Mutex                   // Thread-safe access\n    first: ?*Message               // Head of LIFO stack\n    closed: bool                   // Pool shutdown flag\n    current: usize                 // Current pool size\n    high: usize                    // High-water mark\n    alerter: Alerter               // Callback to notify engine\n}\n</code></pre></p> <p>Operations:</p> <ol> <li> <p>get(strategy: AllocationStrategy) \u2192 ?*Message</p> <ul> <li>Lock mutex</li> <li>If pool not empty: pop from stack, return</li> <li>If pool empty:<ul> <li><code>poolOnly</code> strategy: return null</li> <li><code>always</code> strategy: allocate new message</li> </ul> </li> <li>If pool empty, call alerter.alert(.pool_empty)</li> <li>Unlock mutex</li> </ul> </li> <li> <p>put(msg: ?Message) \u2192 void</p> <ul> <li>If msg is null: return (no-op)</li> <li>Lock mutex</li> <li>If pool closed: destroy message, unlock, return</li> <li>If pool size &gt;= maxPoolMsgs: destroy message, unlock, return</li> <li>Push to stack (msg.next = first; first = msg)</li> <li>Increment current size</li> <li>Call alerter.alert(.pool_freed) if was empty</li> <li>Unlock mutex</li> </ul> </li> <li> <p>inform() \u2192 void</p> <ul> <li>If pool was empty and now has messages: alert engine</li> <li>If pool is full: alert engine (backpressure)</li> </ul> </li> </ol> <p>Configuration: <pre><code>Options {\n    initialPoolMsgs: ?u16 = 16   // Pre-allocated messages\n    maxPoolMsgs: ?u16 = 64       // Pool capacity limit\n}\n</code></pre></p> <p>Why LIFO?</p> <ul> <li>Cache locality: Recently returned messages likely still hot in CPU cache</li> <li>Simpler code: No tail pointer needed</li> <li>Performance: Fewer memory accesses</li> </ul> <p>Backpressure Mechanism:</p> <ul> <li>When pool empty \u2192 send <code>.pool_empty</code> status to application</li> <li>Application can:<ul> <li>Add messages to pool dynamically</li> <li>Use <code>.poolOnly</code> strategy and handle nulls</li> <li>Reduce send rate</li> </ul> </li> <li>Pool full \u2192 excess messages destroyed (prevents unbounded growth)</li> </ul>"},{"location":"mds/specification/#memory-ownership-model","title":"Memory Ownership Model","text":"<p>Rule 1: Pool Owns All Messages</p> <ul> <li>Messages come from pool</li> <li>Messages return to pool</li> <li>Application borrows messages temporarily</li> </ul> <p>Rule 2: Ownership Transfer via Pointer-to-Pointer</p> <pre><code>var msg: ?*Message = try ampe.get(.always);  // Ownership: Application\ndefer ampe.put(&amp;msg);                        // Ensures return to pool\n\n_ = try chnls.enqueueToPeer(&amp;msg);           // Ownership: Engine (msg becomes null)\n// msg is now NULL - cannot use after this point\n</code></pre> <p>Rule 3: defer Pattern Mandatory</p> <ul> <li>Every <code>get()</code> must have corresponding <code>defer put()</code></li> <li>Ensures cleanup even on error paths</li> <li>Prevents message leaks</li> </ul> <p>Rule 4: Received Messages Also Use Pool</p> <pre><code>var received: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;received);  // Return to pool when done\n</code></pre>"},{"location":"mds/specification/#allocator-usage","title":"Allocator Usage","text":"<p>Principle: Allocator-agnostic, user provides</p> <p>Main Allocator GeneralPurposeAllocator (GPA)</p> <p>Allocation Points: 1. Reactor creation: <code>Reactor.Create(allocator, options)</code> 2. Message creation: <code>Message.create(allocator)</code> (if pool empty with <code>.always</code>) 3. ActiveChannels: Pre-allocates nodes for removed-channels buffer 4. TextHeaders/Body: Dynamic growth using <code>Appendable</code> buffer</p> <p>Deallocation Points: 1. Reactor destruction: <code>Reactor.Destroy()</code> 2. Message destruction: When pool full or closed 3. ChannelGroup destruction: Cleanup mailboxes</p>"},{"location":"mds/specification/#16-concurrency-model","title":"1.6 Concurrency Model","text":""},{"location":"mds/specification/#threading-model","title":"Threading Model","text":"<p>Single Reactor Thread + Multiple Application Threads</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Application Threads                          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2502\n\u2502  \u2502 Thread 1 \u2502  \u2502 Thread 2 \u2502  \u2502 Thread 3 \u2502  \u2502 Thread N \u2502          \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n\u2502       \u2502             \u2502             \u2502             \u2502                \u2502\n\u2502       \u2502 get/put     \u2502 get/put     \u2502 get/put     \u2502 get/put        \u2502\n\u2502       \u2502 enqueue     \u2502 enqueue     \u2502 enqueue     \u2502 enqueue        \u2502\n\u2502       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                \u2502\n\u2502                             \u2502                                    \u2502\n\u2502                             \u25bc                                    \u2502\n\u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502              \u2502    Pool (Mutex)          \u2502                        \u2502\n\u2502              \u2502    Mailboxes             \u2502                        \u2502\n\u2502              \u2502    ActiveChannels (Mutex)\u2502                        \u2502\n\u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2502                             \u2502                                    \u2502\n\u2502                             \u25bc                                    \u2502\n\u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502              \u2502     Notifier             \u2502                        \u2502\n\u2502              \u2502   (socketpair)           \u2502                        \u2502\n\u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Reactor Thread                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502              Event Loop (Single-threaded)                  \u2502 \u2502\n\u2502  \u2502  - Poll I/O events                                         \u2502 \u2502\n\u2502  \u2502  - Process send queue                                      \u2502 \u2502\n\u2502  \u2502  - Read/write sockets                                      \u2502 \u2502\n\u2502  \u2502  - Dispatch received messages                              \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"mds/specification/#thread-safety-table","title":"Thread-Safety Table","text":"Operation Thread-Safe? Synchronization Mechanism <code>ampe.get()</code> \u2705 Yes Pool.mutex <code>ampe.put()</code> \u2705 Yes Pool.mutex <code>ampe.create()</code> \u2705 Yes Reactor.crtMtx <code>ampe.destroy()</code> \u2705 Yes Reactor.crtMtx <code>chnls.enqueueToPeer()</code> \u2705 Yes Mailbox lock-free + Reactor.sndMtx <code>chnls.updateReceiver()</code> \u2705 Yes Mailbox lock-free <code>chnls.waitReceive()</code> \u274c NO One thread only per ChannelGroup Reactor event loop \u274c Internal Reactor thread only ActiveChannels registry \u2705 Yes ActiveChannels.mutex"},{"location":"mds/specification/#mutex-inventory","title":"Mutex Inventory","text":"<p>1. Pool.mutex</p> <ul> <li>Purpose: Protect LIFO stack operations</li> <li>Scope: get(), put(), inform()</li> <li>Contention Risk: Moderate (all threads access)</li> </ul> <p>2. Reactor.sndMtx</p> <ul> <li>Purpose: Protect send operations</li> <li>Scope: submitMsg(), internal send queue manipulation</li> <li>Contention Risk: Moderate (all enqueueToPeer calls)</li> </ul> <p>3. Reactor.crtMtx</p> <ul> <li>Purpose: Protect create/destroy operations</li> <li>Scope: createChannelGroup(), destroyChannelGroup()</li> <li>Contention Risk: Low (infrequent operations)</li> </ul> <p>4. ActiveChannels.mutex</p> <ul> <li>Purpose: Protect channel registry</li> <li>Scope: createChannel(), removeChannel(), check(), exists()</li> <li>Contention Risk: Moderate (channel lifecycle operations)</li> </ul> <p>Lock Ordering (to prevent deadlock):</p> <ul> <li>Never hold multiple mutexes simultaneously</li> <li>Each mutex protects independent data structure</li> <li>No nested locking patterns observed</li> </ul>"},{"location":"mds/specification/#mailbox-communication","title":"Mailbox Communication","text":"<p>Intrusive Mailbox (from external <code>mailbox</code> library):</p> <ul> <li>Producer-Consumer: Lock-free intrusive queue</li> <li>Operations:<ul> <li><code>send(msg)</code>: Enqueue message (may block if full)</li> <li><code>receive(timeout)</code>: Dequeue message (blocks until available or timeout)</li> <li><code>close()</code>: Shutdown mailbox, return all messages</li> </ul> </li> </ul> <p>Dual Mailbox Pattern (MchnGroup): <pre><code>MchnGroup {\n    msgs: [2]MSGMailBox\n    //    [0] = Send queue (app \u2192 engine)\n    //    [1] = Receive queue (engine \u2192 app)\n}\n</code></pre></p> <p>Flow:</p> <ol> <li>Application calls <code>enqueueToPeer(&amp;msg)</code> \u2192 puts msg in <code>msgs[0]</code> \u2192 notifies reactor</li> <li>Reactor reads from <code>msgs[0]</code> \u2192 processes \u2192 sends on socket</li> <li>Reactor receives from socket \u2192 puts msg in <code>msgs[1]</code> \u2192 notifies application</li> <li>Application calls <code>waitReceive()</code> \u2192 blocks on <code>msgs[1]</code> \u2192 returns received msg</li> </ol>"},{"location":"mds/specification/#atomic-operations","title":"Atomic Operations","text":"<p>Usage (recipes/services.zig):</p> <pre><code>cancel: Atomic(bool) = .init(false)\n\nsetCancel(): cancel.store(true, .monotonic)\nwasCancelled(): return cancel.load(.monotonic)\n</code></pre> <p>Memory Ordering:</p> <ul> <li><code>.monotonic</code>: Sufficient for simple flags (no dependent loads)</li> <li>No <code>.seq_cst</code> needed (no multi-variable synchronization)</li> </ul>"},{"location":"mds/specification/#17-io-and-networking","title":"1.7 I/O and Networking","text":""},{"location":"mds/specification/#non-blocking-socket-pattern","title":"Non-Blocking Socket Pattern","text":"<p>Socket Creation (Skt.zig): <pre><code>1. Create socket: socket(AF_INET/AF_UNIX, SOCK_STREAM, 0)\n2. Set non-blocking: fcntl(fd, F_SETFL, O_NONBLOCK)\n3. Set SO_REUSEADDR (TCP only)\n4. Bind (server) or Connect (client)\n5. Return Skt wrapper struct\n</code></pre></p> <p>Skt Structure: <pre><code>Skt {\n    channel_number: ChannelNumber  // Associated channel\n    sktFd: SocketFd                // OS socket file descriptor\n    listener: bool                 // true = listener, false = connected\n    connecting: bool               // true during TCP handshake\n    // ... OS-specific fields\n}\n</code></pre></p>"},{"location":"mds/specification/#poller-abstraction-pollerzig","title":"Poller Abstraction (poller.zig)","text":"<p>Implemented using tagged union.</p> <p>Current implementation based on  poll().</p>"},{"location":"mds/specification/#protocol-wire-format","title":"Protocol Wire Format","text":"<p>Message Serialization: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Wire Message                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 BinaryHeader (16 bytes, big-endian)                       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 ch_num | proto | status | msg_id | thl | bl         \u2502  \u2502\n\u2502  \u2502 (u16)  | (u8)  | (u8)   | (u64)  |(u16)|(u16)       \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 TextHeaders (thl bytes)                                   \u2502\n\u2502  Key1: Value1\\r\\n                                         \u2502\n\u2502  Key2: Value2\\r\\n                                         \u2502\n\u2502  \\r\\n                                                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Body (bl bytes)                                           \u2502\n\u2502  [arbitrary binary data]                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Serialization (toBytes): <pre><code>fn toBytes(bhdr: *BinaryHeader, buffer: []u8) void {\n    // Convert each field to big-endian\n    writeBigEndianU16(buffer[0..2], bhdr.channel_number)\n    buffer[2] = bhdr.proto.toByte()\n    buffer[3] = bhdr.status\n    writeBigEndianU64(buffer[4..12], bhdr.message_id)\n    writeBigEndianU16(buffer[12..14], bhdr.@\"&lt;thl&gt;\")\n    writeBigEndianU16(buffer[14..16], bhdr.@\"&lt;bl&gt;\")\n}\n</code></pre></p> <p>Deserialization (fromBytes):</p> <ul> <li>Reverse process: read big-endian bytes \u2192 populate struct fields</li> </ul>"},{"location":"mds/specification/#socket-io-state-machine","title":"Socket I/O State Machine","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Idle: Socket created\n    Idle --&gt; Connecting: connect() called (client)\n    Idle --&gt; Listening: listen() called (server)\n\n    Connecting --&gt; WaitWritable: EINPROGRESS\n    WaitWritable --&gt; Connected: Writable event\n\n    Listening --&gt; WaitReadable: accept() would block\n    WaitReadable --&gt; AcceptReady: Readable event\n    AcceptReady --&gt; NewClient: accept() succeeds\n\n    Connected --&gt; ReadReady: Data available\n    ReadReady --&gt; Reading: recv() in progress\n    Reading --&gt; ReadComplete: All data read\n    ReadComplete --&gt; Connected: Ready for more\n\n    Connected --&gt; WriteReady: Can write\n    WriteReady --&gt; Writing: send() in progress\n    Writing --&gt; WriteComplete: All data sent\n    WriteComplete --&gt; Connected: Ready for more\n\n    Reading --&gt; WouldBlock: EAGAIN/EWOULDBLOCK\n    Writing --&gt; WouldBlock: EAGAIN/EWOULDBLOCK\n    WouldBlock --&gt; Connected: Re-register with poller\n\n    Reading --&gt; Error: Socket error\n    Writing --&gt; Error: Socket error\n    Connected --&gt; Error: Peer closed\n\n    Error --&gt; Closed: Close socket\n    Closed --&gt; [*]</code></pre>"},{"location":"mds/specification/#tcp-vs-unix-domain-sockets","title":"TCP vs Unix Domain Sockets","text":"<p>TCP Configuration: <pre><code>TCPServerConfigurator {\n    address: []const u8  // IP address (e.g., \"0.0.0.0\", \"127.0.0.1\")\n    port: u16            // Port number\n}\n\nTCPClientConfigurator {\n    address: []const u8  // Server IP\n    port: u16            // Server port\n}\n</code></pre></p> <p>UDS Configuration: <pre><code>UDSServerConfigurator {\n    path: []const u8     // File path (e.g., \"/tmp/tofu.sock\")\n}\n\nUDSClientConfigurator {\n    path: []const u8     // Same path as server\n}\n</code></pre></p> <p>Differences:</p> Aspect TCP Unix Domain Sockets Address IP:Port File path Scope Network-wide Local machine only Performance Slower (network stack) Faster (kernel bypass) Use Case Distributed systems IPC (Inter-Process Communication)"},{"location":"mds/specification/#18-os-dependencies","title":"1.8 OS Dependencies","text":""},{"location":"mds/specification/#posix-system-calls","title":"POSIX System Calls","text":"<p>Core I/O:</p> <ul> <li><code>socket()</code> - Create socket endpoint</li> <li><code>bind()</code> - Bind socket to address</li> <li><code>listen()</code> - Mark socket as listener</li> <li><code>accept()</code> - Accept incoming connection</li> <li><code>connect()</code> - Initiate connection</li> <li><code>send()</code> / <code>recv()</code> - Send/receive data</li> <li><code>close()</code> - Close file descriptor</li> <li><code>fcntl()</code> - Set non-blocking mode (F_SETFL, O_NONBLOCK)</li> <li><code>setsockopt()</code> - Set socket options (SO_REUSEADDR)</li> </ul> <p>Polling:</p> <ul> <li>Linux: <code>poll()</code></li> </ul> <p>Notifier:</p> <ul> <li><code>socketpair()</code> - Create connected socket pair (AF_UNIX, SOCK_STREAM)</li> <li>Alternative on Linux: Unix domain socket pair</li> </ul> <p>Threading:</p> <ul> <li><code>std.Thread.spawn()</code> - Spawn thread (uses pthread internally on POSIX)</li> <li><code>std.Thread.Mutex</code> - Mutex (pthread_mutex)</li> <li><code>std.Thread.Semaphore</code> - Semaphore (pthread_cond + pthread_mutex)</li> <li><code>std.Thread.Atomic</code> - Atomic operations (compiler intrinsics)</li> </ul>"},{"location":"mds/specification/#external-library-dependencies","title":"External Library Dependencies","text":"<p>From build.zig.zon:</p> <ol> <li> <p>nats (https://github.com/g41797/nats.zig)</p> <ul> <li>Provides: <code>Appendable</code> (dynamically growing buffer)</li> <li>Used for: Message body, TextHeaders storage</li> <li>Provides: <code>Formatter</code> (string formatting utilities)</li> </ul> </li> <li> <p>mailbox (https://github.com/g41797/mailbox)</p> <ul> <li>Provides: <code>MailBoxIntrusive</code> (intrusive lock-free queue)</li> <li>Used for: Dual mailboxes in MchnGroup (send/receive queues)</li> </ul> </li> <li> <p>temp (https://github.com/g41797/temp.zig)</p> <ul> <li>Provides: Temporary file path generation</li> <li>Used for: UDS testing (create temp socket paths)</li> </ul> </li> <li> <p>datetime (https://github.com/g41797/datetime)</p> <ul> <li>Provides: Date/time handling utilities</li> <li>Used for: Timestamps (not core to message passing)</li> </ul> </li> </ol> <p>Critical Dependencies for Porting:</p> <ul> <li><code>Appendable</code>: Dynamic buffer implementation needed</li> <li><code>MailBoxIntrusive</code>: Lock-free intrusive queue needed (or equivalent sync primitive)</li> </ul>"},{"location":"mds/specification/#19-entity-catalog-and-responsibilities","title":"1.9 Entity Catalog and Responsibilities","text":""},{"location":"mds/specification/#core-entities","title":"Core Entities","text":"Entity File Lines Responsibility Reactor <code>src/ampe/Reactor.zig</code> ~967 Event loop, I/O multiplexing, message routing Pool <code>src/ampe/Pool.zig</code> ~200 Message pool management, backpressure MchnGroup <code>src/ampe/MchnGroup.zig</code> ~229 ChannelGroup implementation, dual mailboxes ActiveChannels <code>src/ampe/channels.zig</code> ~341 Channel registry, random allocation, validation Message <code>src/message.zig</code> ~600 Message structure, serialization, validation BinaryHeader <code>src/message.zig</code> ~150 16-byte header, big-endian conversion Notifier <code>src/ampe/Notifier.zig</code> ~200 Socketpair notification mechanism Poller <code>src/ampe/poller.zig</code> ~400 OS-specific I/O polling abstraction Skt <code>src/ampe/Skt.zig</code> ~300 Socket wrapper, connection state IntrusiveQueue <code>src/ampe/IntrusiveQueue.zig</code> ~105 Generic intrusive linked list queue Configurator <code>src/configurator.zig</code> ~200 TCP/UDS configuration helpers Status <code>src/status.zig</code> ~150 AmpeStatus/AmpeError, conversions"},{"location":"mds/specification/#public-api-interfaces","title":"Public API Interfaces","text":"Interface File Methods Purpose Ampe <code>src/ampe.zig</code> <code>get</code>, <code>put</code>, <code>create</code>, <code>destroy</code>, <code>getAllocator</code> Engine interface ChannelGroup <code>src/ampe.zig</code> <code>enqueueToPeer</code>, <code>waitReceive</code>, <code>updateReceiver</code> Message exchange interface"},{"location":"mds/specification/#recipe-patterns","title":"Recipe Patterns","text":"Pattern File Purpose EchoService <code>recipes/services.zig</code> Simple request-response echo EchoClient <code>recipes/services.zig</code> Client pattern with reconnection MultiHomed <code>recipes/MultiHomed.zig</code> Multiple listeners (TCP + UDS) on one thread Cookbook Examples <code>recipes/cookbook.zig</code> 40+ examples covering all patterns"},{"location":"mds/specification/#110-architectural-flows","title":"1.10 Architectural Flows","text":""},{"location":"mds/specification/#flow-1-server-startup-and-client-connection","title":"Flow 1: Server Startup and Client Connection","text":"<pre><code>sequenceDiagram\n    participant App as Application Thread\n    participant Pool as Message Pool\n    participant Reactor as Reactor Thread\n    participant OS as Operating System\n\n    Note over App: Server Startup\n    App-&gt;&gt;Pool: get(.always)\n    Pool--&gt;&gt;App: welcomeMsg\n    App-&gt;&gt;App: Configure: WelcomeRequest&lt;br/&gt;address=\"0.0.0.0\", port=8080\n    App-&gt;&gt;Reactor: enqueueToPeer(&amp;welcomeMsg)\n    Note over App: welcomeMsg becomes NULL\n\n    Reactor-&gt;&gt;OS: socket(AF_INET, SOCK_STREAM)\n    OS--&gt;&gt;Reactor: listener_fd\n    Reactor-&gt;&gt;OS: bind(listener_fd, 0.0.0.0:8080)\n    Reactor-&gt;&gt;OS: listen(listener_fd)\n    Reactor-&gt;&gt;Reactor: Register listener_fd with poller\n\n    Reactor-&gt;&gt;Pool: get(.always)\n    Pool--&gt;&gt;Reactor: responseMsg\n    Reactor-&gt;&gt;Reactor: Set WelcomeResponse&lt;br/&gt;status=success, ch#=listener_channel\n    Reactor-&gt;&gt;App: receiveMailbox.send(responseMsg)\n\n    App-&gt;&gt;Reactor: waitReceive()\n    Reactor--&gt;&gt;App: responseMsg (WelcomeResponse)\n    Note over App: Server is listening\n\n    Note over App: Client Startup (different app)\n    App-&gt;&gt;Pool: get(.always)\n    Pool--&gt;&gt;App: helloMsg\n    App-&gt;&gt;App: Configure: HelloRequest&lt;br/&gt;address=\"127.0.0.1\", port=8080\n    App-&gt;&gt;Reactor: enqueueToPeer(&amp;helloMsg)\n\n    Reactor-&gt;&gt;OS: socket(AF_INET, SOCK_STREAM)\n    OS--&gt;&gt;Reactor: client_fd\n    Reactor-&gt;&gt;OS: connect(client_fd, 127.0.0.1:8080)\n    Note over Reactor: Non-blocking: returns EINPROGRESS\n    Reactor-&gt;&gt;Reactor: Register client_fd for write\n\n    Note over Reactor: Later: poller returns writable\n    Reactor-&gt;&gt;Reactor: Connection established\n    Reactor-&gt;&gt;Reactor: Generate random channel#\n    Reactor-&gt;&gt;OS: send(client_fd, HelloRequest bytes)\n\n    Note over OS: Server side\n    OS-&gt;&gt;Reactor: accept() on listener_fd\n    Reactor-&gt;&gt;OS: accept(listener_fd)\n    OS--&gt;&gt;Reactor: new_client_fd\n    Reactor-&gt;&gt;Reactor: Generate random channel#\n    Reactor-&gt;&gt;Reactor: Register new_client_fd for read\n\n    Note over Reactor: Later: poller returns readable\n    Reactor-&gt;&gt;OS: recv(new_client_fd)\n    OS--&gt;&gt;Reactor: HelloRequest bytes\n    Reactor-&gt;&gt;Reactor: Parse message\n    Reactor-&gt;&gt;Pool: get(.always)\n    Pool--&gt;&gt;Reactor: incomingMsg\n    Reactor-&gt;&gt;Reactor: Populate incomingMsg with HelloRequest\n    Reactor-&gt;&gt;App: receiveMailbox.send(incomingMsg)\n\n    App-&gt;&gt;Reactor: waitReceive()\n    Reactor--&gt;&gt;App: incomingMsg (HelloRequest from client)\n\n    App-&gt;&gt;App: Process HelloRequest\n    App-&gt;&gt;App: Create HelloResponse\n    App-&gt;&gt;Reactor: enqueueToPeer(&amp;response)\n\n    Reactor-&gt;&gt;OS: send(new_client_fd, HelloResponse bytes)\n\n    Note over App,OS: Connection established. Ready for regular messages.</code></pre>"},{"location":"mds/specification/#flow-2-message-exchange-request-response","title":"Flow 2: Message Exchange (Request-Response)","text":"<pre><code>sequenceDiagram\n    participant Client as Client App\n    participant CPool as Client Pool\n    participant CReactor as Client Reactor\n    participant Net as Network\n    participant SReactor as Server Reactor\n    participant SPool as Server Pool\n    participant Server as Server App\n\n    Client-&gt;&gt;CPool: get(.always)\n    CPool--&gt;&gt;Client: requestMsg\n    Client-&gt;&gt;Client: Set: role=request, ch#=123&lt;br/&gt;message_id=0 (will be generated)\n    Client-&gt;&gt;Client: Add headers, body\n    Client-&gt;&gt;CReactor: enqueueToPeer(&amp;requestMsg)\n    Note over Client: requestMsg is NULL now\n\n    CReactor-&gt;&gt;CReactor: Generate message_id=456\n    CReactor-&gt;&gt;CReactor: Serialize to bytes\n    CReactor-&gt;&gt;Net: send() on socket for ch#123\n\n    Net-&gt;&gt;SReactor: recv() detects readable\n    SReactor-&gt;&gt;SReactor: Read BinaryHeader (16 bytes)\n    SReactor-&gt;&gt;SReactor: Read TextHeaders + Body\n    SReactor-&gt;&gt;SReactor: Parse into Message struct\n\n    SReactor-&gt;&gt;SPool: get(.always)\n    SPool--&gt;&gt;SReactor: receivedMsg\n    SReactor-&gt;&gt;SReactor: Copy parsed data to receivedMsg\n    SReactor-&gt;&gt;Server: receiveMailbox.send(receivedMsg)\n\n    Server-&gt;&gt;SReactor: waitReceive()\n    SReactor--&gt;&gt;Server: receivedMsg\n    Server-&gt;&gt;Server: Process request&lt;br/&gt;(message_id=456, ch#=123)\n\n    Server-&gt;&gt;Server: Reuse receivedMsg for response\n    Server-&gt;&gt;Server: Set: role=response&lt;br/&gt;message_id=456 (same as request)\n    Server-&gt;&gt;SReactor: enqueueToPeer(&amp;receivedMsg)\n\n    SReactor-&gt;&gt;SReactor: Serialize response\n    SReactor-&gt;&gt;Net: send() on socket for ch#123\n\n    Net-&gt;&gt;CReactor: recv() detects readable\n    CReactor-&gt;&gt;CReactor: Parse response\n    CReactor-&gt;&gt;CPool: get(.always)\n    CPool--&gt;&gt;CReactor: responseMsg\n    CReactor-&gt;&gt;CReactor: Copy parsed data to responseMsg\n    CReactor-&gt;&gt;Client: receiveMailbox.send(responseMsg)\n\n    Client-&gt;&gt;CReactor: waitReceive()\n    CReactor--&gt;&gt;Client: responseMsg (message_id=456)\n    Client-&gt;&gt;Client: Match response to request&lt;br/&gt;via message_id\n    Client-&gt;&gt;CPool: put(&amp;responseMsg)</code></pre>"},{"location":"mds/specification/#flow-3-pool-empty-handling","title":"Flow 3: Pool Empty Handling","text":"<pre><code>sequenceDiagram\n    participant App as Application\n    participant Pool as Message Pool\n    participant Reactor as Reactor\n\n    App-&gt;&gt;Pool: get(.always)\n    Note over Pool: Pool is empty!\n    Pool-&gt;&gt;Pool: Allocate new message\n    Pool-&gt;&gt;Reactor: alerter.alert(.pool_empty)\n    Pool--&gt;&gt;App: newMsg (newly allocated)\n\n    App-&gt;&gt;App: Configure message\n    App-&gt;&gt;Reactor: enqueueToPeer(&amp;newMsg)\n\n    Note over Reactor: Process message, send, receive response\n\n    Reactor-&gt;&gt;Pool: get(.always)\n    Note over Pool: Still empty!\n    Pool-&gt;&gt;Pool: Allocate another message\n    Pool-&gt;&gt;Reactor: alerter.alert(.pool_empty)\n    Pool--&gt;&gt;Reactor: responseMsg (newly allocated)\n\n    Reactor-&gt;&gt;Reactor: Populate with response data\n    Reactor-&gt;&gt;Reactor: Set status=pool_empty&lt;br/&gt;origin=engine\n    Reactor-&gt;&gt;App: receiveMailbox.send(responseMsg)\n\n    App-&gt;&gt;Reactor: waitReceive()\n    Reactor--&gt;&gt;App: responseMsg\n    App-&gt;&gt;App: Check status: pool_empty detected\n\n    App-&gt;&gt;App: Create 3 new messages\n    loop 3 times\n        App-&gt;&gt;Pool: Message.create(allocator)\n        Pool-&gt;&gt;Pool: Store message\n        App-&gt;&gt;Pool: put(&amp;msg)\n    end\n\n    Pool-&gt;&gt;Reactor: alerter.alert(.pool_freed)\n    Note over Pool: Pool now has 3 messages\n\n    App-&gt;&gt;Pool: get(.always)\n    Note over Pool: Pool has messages\n    Pool--&gt;&gt;App: msg (from pool, not allocated)\n    Note over App: Normal operation resumes</code></pre>"},{"location":"mds/specification/#flow-4-inter-thread-communication","title":"Flow 4: Inter-Thread Communication","text":"<pre><code>sequenceDiagram\n    participant AppThread as Application Thread\n    participant SendMbox as Send Mailbox [0]\n    participant Notifier as Notifier (socketpair)\n    participant Reactor as Reactor Thread\n    participant RecvMbox as Receive Mailbox [1]\n\n    Note over AppThread,RecvMbox: Message Send Flow\n    AppThread-&gt;&gt;SendMbox: msgs[0].send(message)\n    SendMbox-&gt;&gt;Notifier: Wake reactor\n    Notifier-&gt;&gt;Reactor: Readable on receiver socket\n    Reactor-&gt;&gt;SendMbox: msgs[0].receive()\n    SendMbox--&gt;&gt;Reactor: message\n    Reactor-&gt;&gt;Reactor: Process &amp; send on socket\n\n    Note over AppThread,RecvMbox: Message Receive Flow\n    Reactor-&gt;&gt;Reactor: Receive from socket\n    Reactor-&gt;&gt;RecvMbox: msgs[1].send(message)\n    RecvMbox-&gt;&gt;AppThread: (waitReceive unblocks)\n    AppThread-&gt;&gt;RecvMbox: msgs[1].receive()\n    RecvMbox--&gt;&gt;AppThread: message</code></pre>"},{"location":"mds/tofu-implementation-review/","title":"Review","text":""},{"location":"mds/tofu-implementation-review/#document-purpose","title":"Document Purpose","text":"<p>This document analyzes tofu implementation from Zig programming language perspective. It identifies:</p> <ul> <li>What should be improved</li> <li>Questionable implementations</li> <li>Best practices alignment</li> <li>Safety concerns</li> <li>Performance considerations</li> </ul> <p>Target Audience: Zig developers reviewing or contributing to tofu</p> <p>Analysis Date: December 2025 Zig Version: 0.14.0+ (targeting 0.15.2)</p>"},{"location":"mds/tofu-implementation-review/#executive-summary","title":"Executive Summary","text":"<p>Overall Assessment: Solid implementation with good understanding of Zig. Several areas need attention for safety, maintainability, and Zig idioms.</p> <p>Strengths:</p> <ul> <li>Good use of intrusive data structures (zero allocation)</li> <li>Proper use of defer/errdefer patterns</li> <li>Clear separation of concerns</li> <li>Thread safety where needed</li> <li>Packed structs for wire protocol</li> </ul> <p>Areas Needing Improvement:</p> <ul> <li>Extensive use of <code>?*anyopaque</code> reduces type safety</li> <li>Error handling mixes status bytes with Zig errors</li> <li>Some questionable pointer casting patterns</li> <li>TODOs and commented code in production</li> <li>Inconsistent naming conventions</li> </ul>"},{"location":"mds/tofu-implementation-review/#1-memory-management-analysis","title":"1. Memory Management Analysis","text":""},{"location":"mds/tofu-implementation-review/#11-message-pool-pattern-good","title":"1.1 Message Pool Pattern \u2705 GOOD","text":"<p>File: <code>src/ampe/Pool.zig</code></p> <p>What It Does: <pre><code>pub fn get(pool: *Pool, ac: AllocationStrategy) AmpeError!*Message {\n    pool.mutex.lock();\n    defer pool.*.inform();\n    defer pool.mutex.unlock();\n    // ...\n}\n</code></pre></p> <p>Strengths:</p> <ul> <li>LIFO pool reduces allocation pressure</li> <li>Thread-safe with mutex</li> <li>Two strategies: <code>poolOnly</code> (return null) vs <code>always</code> (allocate)</li> <li>Proper defer usage for unlock and inform</li> </ul> <p>Concerns:</p> <ul> <li><code>defer pool.*.inform()</code> called even on error paths (intended?)</li> <li><code>defer</code> order: inform \u2192 unlock (inform happens while locked)</li> </ul> <p>Recommendation: Consider if <code>inform()</code> should be called before or after unlock. Current order means inform runs while mutex is held.</p>"},{"location":"mds/tofu-implementation-review/#12-intrusive-lists-excellent","title":"1.2 Intrusive Lists \u2705 EXCELLENT","text":"<p>File: <code>src/ampe/IntrusiveQueue.zig</code></p> <p>Pattern: <pre><code>pub const Message = struct {\n    prev: ?*Message = null,\n    next: ?*Message = null,\n    // ... rest of fields\n};\n</code></pre></p> <p>Strengths:</p> <ul> <li>Zero allocation for queueing</li> <li>Cache-friendly (fields in same struct)</li> <li>Clean generic implementation with <code>comptime</code></li> </ul> <p>No concerns. This is textbook Zig.</p>"},{"location":"mds/tofu-implementation-review/#13-allocator-usage-mixed","title":"1.3 Allocator Usage \u26a0\ufe0f MIXED","text":"<p>Good: <pre><code>pub fn Create(gpa: Allocator, options: Options) AmpeError!*Reactor {\n    const rtr: *Reactor = gpa.create(Reactor) catch {\n        return AmpeError.AllocationFailed;\n    };\n    errdefer gpa.destroy(rtr);\n    // ...\n}\n</code></pre></p> <ul> <li>Proper use of <code>errdefer</code> for cleanup</li> <li>Single allocator passed through</li> </ul> <p>Questionable: <pre><code>// src/message.zig:373\npub fn create(allocator: Allocator) AmpeError!*Message {\n    var msg = allocator.create(Message) catch {\n        return AmpeError.AllocationFailed;\n    };\n    msg.* = .{};\n    msg.bhdr = .{};  // Redundant - already in .{}\n    // ...\n}\n</code></pre></p> <p>Issue: <code>msg.bhdr = .{};</code> is redundant since <code>msg.* = .{}</code> already zeroes everything.</p> <p>Recommendation: <pre><code>pub fn create(allocator: Allocator) AmpeError!*Message {\n    var msg = allocator.create(Message) catch {\n        return AmpeError.AllocationFailed;\n    };\n    msg.* = .{};  // This is enough\n    errdefer allocator.destroy(msg);  // Add this\n    // ...\n}\n</code></pre></p>"},{"location":"mds/tofu-implementation-review/#2-type-safety-analysis","title":"2. Type Safety Analysis","text":""},{"location":"mds/tofu-implementation-review/#21-excessive-use-of-anyopaque-major-concern","title":"2.1 Excessive Use of <code>?*anyopaque</code> \u274c MAJOR CONCERN","text":"<p>Problem: Type erasure used extensively</p> <p>Examples:</p> <ol> <li> <p>Vtable pattern (<code>src/ampe.zig</code>): <pre><code>pub const Ampe = struct {\n    ptr: ?*anyopaque,  // Could be *Reactor\n    vtable: *const vtables.AmpeVTable,\n};\n</code></pre></p> </li> <li> <p>Context pointer in Message (<code>src/message.zig</code>): <pre><code>pub const Message = struct {\n    @\"&lt;ctx&gt;\": ?*anyopaque = null,  // Engine context\n    @\"&lt;void*&gt;\": ?*anyopaque = null,  // User context\n};\n</code></pre></p> </li> <li> <p>Pointer casting everywhere (<code>src/ampe/MchnGroup.zig</code>): <pre><code>pub fn enqueueToPeer(ptr: ?*anyopaque, amsg: *?*Message) AmpeError!BinaryHeader {\n    const grp: *MchnGroup = @ptrCast(@alignCast(ptr));  // DANGER\n    // ...\n}\n</code></pre></p> </li> </ol> <p>Why This Is Problematic:</p> <ul> <li>Loses type information at compile time</li> <li>Runtime crashes instead of compile errors</li> <li>No compiler help with refactoring</li> <li>Easy to pass wrong type (crash only at runtime)</li> </ul> <p>Impact: This is standard vtable pattern in Zig, but it's risky.</p> <p>Better Alternatives:</p> <p>Option 1: Tagged Union (if few implementations) <pre><code>pub const Ampe = union(enum) {\n    reactor: *Reactor,\n    // future: other implementations\n\n    pub fn get(self: Ampe, strategy: AllocationStrategy) !?*Message {\n        return switch (self) {\n            .reactor =&gt; |r| r._get(strategy),\n        };\n    }\n};\n</code></pre></p> <p>Option 2: Comptime Generics (if performance critical) <pre><code>pub fn Ampe(comptime Impl: type) type {\n    return struct {\n        impl: *Impl,\n\n        pub fn get(self: @This(), strategy: AllocationStrategy) !?*Message {\n            return self.impl.get(strategy);\n        }\n    };\n}\n</code></pre></p> <p>Recommendation: Current vtable approach is acceptable for library flexibility, but:</p> <ul> <li>Document the safety contract clearly</li> <li>Consider adding runtime type tags for debugging</li> <li>Add asserts in debug builds to catch type mismatches</li> </ul>"},{"location":"mds/tofu-implementation-review/#22-pointer-casting-patterns-unsafe","title":"2.2 Pointer Casting Patterns \u26a0\ufe0f UNSAFE","text":"<p>File: <code>src/ampe/MchnGroup.zig</code>, <code>src/ampe/Reactor.zig</code></p> <p>Pattern: <pre><code>const grp: *MchnGroup = @ptrCast(@alignCast(ptr));\n</code></pre></p> <p>Problems:</p> <ul> <li>No compile-time verification</li> <li>Wrong type = immediate crash</li> <li>Alignment issues possible</li> </ul> <p>When This Fails: <pre><code>// Wrong usage (compiles but crashes at runtime):\nvar wrong: u32 = 42;\nvar ptr: ?*anyopaque = &amp;wrong;\n// Later...\nconst grp: *MchnGroup = @ptrCast(@alignCast(ptr));  // BOOM\n</code></pre></p> <p>Recommendation: Add runtime checks in debug builds: <pre><code>const grp: *MchnGroup = @ptrCast(@alignCast(ptr));\nif (tofu.DBG) {\n    std.debug.assert(@intFromPtr(grp) % @alignOf(MchnGroup) == 0);\n}\n</code></pre></p>"},{"location":"mds/tofu-implementation-review/#23-packed-structs-good","title":"2.3 Packed Structs \u2705 GOOD","text":"<p>File: <code>src/message.zig</code></p> <pre><code>pub const BinaryHeader = packed struct {\n    channel_number: ChannelNumber = 0,\n    proto: ProtoFields = .{},\n    status: u8 = 0,\n    message_id: MessageID = 0,\n    @\"&lt;thl&gt;\": u16 = 0,\n    @\"&lt;bl&gt;\": u16 = 0,\n\n    pub const BHSIZE = @sizeOf(BinaryHeader);  // 16 bytes\n};\n</code></pre> <p>Strengths:</p> <ul> <li>Correct use of <code>packed struct</code> for wire protocol</li> <li>Explicit size verification with comptime</li> <li>Big-endian conversion for network byte order</li> </ul> <p>No concerns. This is proper network protocol handling.</p>"},{"location":"mds/tofu-implementation-review/#3-error-handling-analysis","title":"3. Error Handling Analysis","text":""},{"location":"mds/tofu-implementation-review/#31-dual-error-system-confusing","title":"3.1 Dual Error System \u274c CONFUSING","text":"<p>Problem: Two parallel error systems</p> <p>System 1: Zig Errors (<code>src/status.zig</code>) <pre><code>pub const AmpeError = error{\n    NotImplementedYet,\n    WrongConfiguration,\n    // ... 30+ errors\n};\n</code></pre></p> <p>System 2: Status Bytes (u8 in message.bhdr.status) <pre><code>pub const AmpeStatus = enum(u8) {\n    success = 0,\n    not_implemented_yet,\n    // ... same errors as AmpeError\n};\n</code></pre></p> <p>Conversion Hell: <pre><code>// Convert raw byte -&gt; status enum\npub inline fn raw_to_status(rs: u8) AmpeStatus { ... }\n\n// Convert raw byte -&gt; error (or void)\npub inline fn raw_to_error(rs: u8) AmpeError!void { ... }\n\n// Convert status enum -&gt; error\npub inline fn status_to_error(status: AmpeStatus) AmpeError!void { ... }\n\n// Convert error -&gt; status enum\npub fn errorToStatus(err: AmpeError) AmpeStatus { ... }\n</code></pre></p> <p>Why This Exists: Status byte travels over wire. Zig errors don't. Need conversion.</p> <p>Problem: Easy to use wrong conversion function. No type safety between them.</p> <p>Example Confusion: <pre><code>const st: u8 = msg.bhdr.status;\n\n// Which to use?\nconst status1 = status.raw_to_status(st);         // \u2192 AmpeStatus\ntry status.raw_to_error(st);                      // \u2192 void or error\ntry status.status_to_error(status1);              // \u2192 void or error\nconst status2 = status.errorToStatus(err);        // \u2190 requires error\n</code></pre></p> <p>Recommendation:</p> <p>Option 1: Use newtype pattern <pre><code>pub const WireStatus = packed struct {\n    value: u8,\n\n    pub fn toError(self: WireStatus) AmpeError!void {\n        if (self.value == 0) return;\n        return raw_to_error(self.value);\n    }\n\n    pub fn fromError(err: AmpeError) WireStatus {\n        return .{ .value = @intFromEnum(errorToStatus(err)) };\n    }\n};\n</code></pre></p> <p>Option 2: Simplify to single conversion function <pre><code>pub const StatusConversion = struct {\n    pub fn wireToZig(wire: u8) AmpeError!void { ... }\n    pub fn zigToWire(err: AmpeError) u8 { ... }\n};\n</code></pre></p>"},{"location":"mds/tofu-implementation-review/#32-error-context-loss-poor-dx","title":"3.2 Error Context Loss \u26a0\ufe0f POOR DX","text":"<p>File: Many files</p> <p>Pattern: <pre><code>const msg: *Message = Message.create(pool.allocator) catch {\n    return AmpeError.AllocationFailed;\n};\n</code></pre></p> <p>Problem: Original error thrown away. User sees only <code>AllocationFailed</code> but not WHY (OOM? Permission? Other?).</p> <p>Better: <pre><code>const msg: *Message = Message.create(pool.allocator) catch |err| {\n    log.err(\"Message.create failed: {s}\", .{@errorName(err)});\n    return AmpeError.AllocationFailed;\n};\n</code></pre></p> <p>Or use error trace (Zig 0.11+): <pre><code>const msg: *Message = Message.create(pool.allocator) catch |err| {\n    if (@errorReturnTrace()) |trace| {\n        std.debug.dumpStackTrace(trace.*);\n    }\n    return AmpeError.AllocationFailed;\n};\n</code></pre></p> <p>Recommendation: Add error context in at least debug builds. Silent failures hurt debugging.</p>"},{"location":"mds/tofu-implementation-review/#33-typo-in-error-name-minor-bug","title":"3.3 typo in Error Name \u26a0\ufe0f MINOR BUG","text":"<p>File: <code>src/status.zig:22</code></p> <pre><code>pub const AmpeStatus = enum(u8) {\n    // ...\n    invelid_mchn_group,  // TYPO: should be \"invalid_mchn_group\"\n    // ...\n};\n</code></pre> <p>Impact: Minor, but breaks consistency.</p> <p>Recommendation: Fix typo. Update everywhere it's used.</p>"},{"location":"mds/tofu-implementation-review/#4-threading-model-analysis","title":"4. Threading Model Analysis","text":""},{"location":"mds/tofu-implementation-review/#41-thread-safety-documentation-good","title":"4.1 Thread Safety Documentation \u2705 GOOD","text":"<p>File: <code>src/ampe.zig</code></p> <p>Clear documentation of what's thread-safe: <pre><code>/// Thread-safe.\npub fn get(ampe: Ampe, strategy: AllocationStrategy) !?*Message { ... }\n\n/// Call in a loop from **one thread only**.\npub fn waitReceive(chnls: ChannelGroup, timeout_ns: u64) !?*Message { ... }\n</code></pre></p> <p>Strengths: - Clear documentation - Reasonable model (most operations thread-safe) - Single-threaded <code>waitReceive</code> simplifies receiver logic</p> <p>No concerns.</p>"},{"location":"mds/tofu-implementation-review/#42-mutex-usage-double-check-needed","title":"4.2 Mutex Usage \u26a0\ufe0f DOUBLE-CHECK NEEDED","text":"<p>File: <code>src/ampe/Reactor.zig</code></p> <p>Pattern: <pre><code>sndMtx: Mutex = undefined,\ncrtMtx: Mutex = undefined,\n</code></pre></p> <p>Two mutexes for different operations: - <code>sndMtx</code>: Protects send operations - <code>crtMtx</code>: Protects create/destroy operations</p> <p>Concern: Are there scenarios where both mutexes needed? Potential for deadlock?</p> <p>Example: <pre><code>// Thread A:\ncrtMtx.lock();\n// ... needs sndMtx?\n\n// Thread B:\nsndMtx.lock();\n// ... needs crtMtx?\n</code></pre></p> <p>Recommendation:</p> <ul> <li>Document lock ordering if both can be held</li> <li>Or prove they never overlap</li> <li>Consider single coarse-grained lock if performance allows</li> </ul>"},{"location":"mds/tofu-implementation-review/#43-atomic-usage-reasonable","title":"4.3 Atomic Usage \u2705 REASONABLE","text":"<p>File: <code>recipes/services.zig</code></p> <pre><code>pub const EchoService = struct {\n    cancel: Atomic(bool) = .init(false),\n\n    pub inline fn setCancel(echo: *EchoService) void {\n        echo.*.cancel.store(true, .monotonic);\n    }\n\n    pub inline fn wasCancelled(echo: *EchoService) bool {\n        return echo.*.cancel.load(.monotonic);\n    }\n};\n</code></pre> <p>Strengths: - Correct use of <code>Atomic</code> for cross-thread flags - <code>.monotonic</code> ordering appropriate for flag</p> <p>No concerns.</p>"},{"location":"mds/tofu-implementation-review/#5-api-design-analysis","title":"5. API Design Analysis","text":""},{"location":"mds/tofu-implementation-review/#51-ownership-transfer-pattern-excellent","title":"5.1 Ownership Transfer Pattern \u2705 EXCELLENT","text":"<p>File: <code>src/ampe.zig</code></p> <p>Pattern: <pre><code>pub fn enqueueToPeer(\n    chnls: ChannelGroup,\n    msg: *?*message.Message,  // Pointer to optional pointer\n) AmpeError!message.BinaryHeader {\n    // After success:\n    msg.* = null;  // Ownership transferred\n    return bhdr;\n}\n</code></pre></p> <p>Strengths:</p> <ul> <li>Clear ownership transfer (caller loses message)</li> <li>Impossible to use message after send (it's null)</li> <li>Compiler helps prevent use-after-free</li> </ul> <p>This is excellent Zig API design.</p>"},{"location":"mds/tofu-implementation-review/#52-vtable-pattern-standard-but-verbose","title":"5.2 VTable Pattern \u26a0\ufe0f STANDARD BUT VERBOSE","text":"<p>File: <code>src/ampe/vtables.zig</code></p> <pre><code>pub const AmpeVTable = struct {\n    get: *const fn (ptr: ?*anyopaque, strategy: AllocationStrategy) AmpeError!?*message.Message,\n    put: *const fn (ptr: ?*anyopaque, msg: *?*message.Message) void,\n    create: *const fn (ptr: ?*anyopaque) AmpeError!ChannelGroup,\n    destroy: *const fn (ptr: ?*anyopaque, chnlsimpl: ?*anyopaque) AmpeError!void,\n    getAllocator: *const fn (ptr: ?*anyopaque) Allocator,\n};\n</code></pre> <p>Pros:</p> <ul> <li>Standard pattern for runtime polymorphism in Zig</li> <li>Allows multiple implementations</li> <li>No hidden costs</li> </ul> <p>Cons:</p> <ul> <li>Verbose to implement</li> <li>Every function needs <code>@ptrCast(@alignCast(ptr))</code></li> <li>Easy to mess up (type safety lost)</li> </ul> <p>Recommendation: Current approach is standard. Document this is modeled after Zig stdlib (std.mem.Allocator uses same pattern).</p>"},{"location":"mds/tofu-implementation-review/#53-todo-comment-in-interface-production-code","title":"5.3 TODO Comment in Interface \u274c PRODUCTION CODE","text":"<p>File: <code>src/ampe.zig:7</code></p> <pre><code>// 2DO - Define error set(s) for errors returned by ChannelGroup and Ampe\n</code></pre> <p>Problem: This is core API. TODO should be resolved before 1.0.</p> <p>Recommendation: Either implement or remove comment. Current <code>AmpeError</code> seems sufficient.</p>"},{"location":"mds/tofu-implementation-review/#6-zig-idioms-analysis","title":"6. Zig Idioms Analysis","text":""},{"location":"mds/tofu-implementation-review/#61-defererrdefer-usage-mostly-good","title":"6.1 Defer/Errdefer Usage \u2705 MOSTLY GOOD","text":"<p>Good Example: <pre><code>pub fn Create(gpa: Allocator, options: Options) AmpeError!*Reactor {\n    const rtr: *Reactor = gpa.create(Reactor) catch {\n        return AmpeError.AllocationFailed;\n    };\n    errdefer gpa.destroy(rtr);  // \u2713 Cleanup on error\n\n    rtr.acns = ActiveChannels.init(rtr.allocator, 1024) catch {\n        return AmpeError.AllocationFailed;\n    };\n    errdefer rtr.acns.deinit();  // \u2713 Cleanup on error\n    // ...\n}\n</code></pre></p> <p>Questionable Example: <pre><code>// src/ampe/Pool.zig:61\npub fn get(pool: *Pool, ac: AllocationStrategy) AmpeError!*Message {\n    pool.mutex.lock();\n    defer pool.*.inform();     // Runs even on error\n    defer pool.mutex.unlock(); // Runs even on error\n    // ...\n}\n</code></pre></p> <p>Question: Should <code>inform()</code> run on error path?</p> <p>Recommendation: Add comment explaining why <code>inform()</code> on error is intentional (or fix if it's not).</p>"},{"location":"mds/tofu-implementation-review/#62-explicit-types-good-per-coding-style","title":"6.2 Explicit Types \u2705 GOOD (per coding style)","text":"<p>Pattern: <pre><code>var msg: ?*Message = try ampe.get(.always);  // Explicit type\n</code></pre></p> <p>Strengths:</p> <ul> <li>Consistent with project style</li> <li>Helps non-IDE users</li> <li>Clear intent</li> </ul> <p>No concerns. This is project convention.</p>"},{"location":"mds/tofu-implementation-review/#63-comptime-usage-good","title":"6.3 Comptime Usage \u2705 GOOD","text":"<p>File: <code>src/ampe/IntrusiveQueue.zig</code></p> <pre><code>pub fn IntrusiveQueue(comptime T: type) type {\n    return struct {\n        const Self = @This();\n        first: ?*T = null,\n        last: ?*T = null,\n        // ...\n    };\n}\n</code></pre> <p>Strengths:</p> <ul> <li>Proper generic programming</li> <li>Type-safe</li> <li>Zero runtime cost</li> </ul> <p>No concerns. Textbook Zig.</p>"},{"location":"mds/tofu-implementation-review/#64-sentinel-values-questionable","title":"6.4 Sentinel Values \u26a0\ufe0f QUESTIONABLE","text":"<p>File: <code>src/message.zig</code></p> <pre><code>pub const SpecialMinChannelNumber = std.math.minInt(u16);  // 0\npub const SpecialMaxChannelNumber = std.math.maxInt(u16);  // 65535\n</code></pre> <p>Used for:</p> <ul> <li>0: Unassigned channel (Hello/Welcome)</li> <li>65535: Engine internal</li> </ul> <p>Problem: Reduces usable range to 1-65534. Not documented clearly.</p> <p>Better: <pre><code>pub const ChannelNumber = enum(u16) {\n    unassigned = 0,\n    engine_internal = std.math.maxInt(u16),\n    _,  // Non-exhaustive\n};\n</code></pre></p> <p>Then use <code>@enumFromInt</code> for normal channels.</p> <p>Recommendation: Document the special values clearly. Or use enum approach.</p>"},{"location":"mds/tofu-implementation-review/#7-safety-analysis","title":"7. Safety Analysis","text":""},{"location":"mds/tofu-implementation-review/#71-undefined-behavior-risks-critical","title":"7.1 Undefined Behavior Risks \u274c CRITICAL","text":"<p>Pattern Found: Uninitialized fields</p> <p>File: <code>src/ampe/Reactor.zig:29-47</code></p> <pre><code>pub const Reactor = @This();\n\nsndMtx: Mutex = undefined,\ncrtMtx: Mutex = undefined,\nshtdwnStrt: bool = undefined,\nallocator: Allocator = undefined,\noptions: tofu.Options = undefined,\nmsgs: [2]MSGMailBox = undefined,\nntfr: Notifier = undefined,\npool: Pool = undefined,\n// ... many more undefined\n</code></pre> <p>Then in Create: <pre><code>rtr.* = .{\n    .sndMtx = .{},\n    .crtMtx = .{},\n    .shtdwnStrt = false,\n    // ... initialize everything\n};\n</code></pre></p> <p>Problem: If Create forgets to initialize a field \u2192 undefined behavior.</p> <p>Safer: <pre><code>pub const Reactor = @This();\n\nsndMtx: Mutex = .{},  // Default init\ncrtMtx: Mutex = .{},\nshtdwnStrt: bool = false,\nallocator: Allocator,  // No default - must provide\n// ...\n</code></pre></p> <p>Then Create can omit fields with good defaults: <pre><code>rtr.* = .{\n    .allocator = gpa,  // Only provide required fields\n};\n</code></pre></p> <p>Recommendation: Provide sensible defaults. Only use <code>= undefined</code> for fields that MUST be set in init.</p>"},{"location":"mds/tofu-implementation-review/#72-assert-vs-error-return-inconsistent","title":"7.2 Assert vs Error Return \u26a0\ufe0f INCONSISTENT","text":"<p>Pattern 1: Assert (crashes in debug, undefined in release) <pre><code>// src/ampe/MchnGroup.zig:93\nstd.debug.assert(sendMsg.*.bhdr.channel_number != 0);\n</code></pre></p> <p>Pattern 2: Error Return <pre><code>if (sendMsg.*.bhdr.channel_number == 0) {\n    return AmpeError.InvalidChannelNumber;\n}\n</code></pre></p> <p>Problem: Inconsistent. When to use which?</p> <p>Guideline:</p> <ul> <li>Assert: Programmer error (bug in tofu)</li> <li>Error return: User error (bad input)</li> </ul> <p>Recommendation: Document this guideline. Review all asserts to ensure they're programmer errors, not user errors.</p>"},{"location":"mds/tofu-implementation-review/#73-null-pointer-handling-good","title":"7.3 Null Pointer Handling \u2705 GOOD","text":"<p>Pattern: <pre><code>var msg: ?*Message = try ampe.get(.poolOnly);\nif (msg == null) {\n    // Handle pool empty\n}\ndefer ampe.put(&amp;msg);  // put() handles null safely\n</code></pre></p> <p>Strengths:</p> <ul> <li>Explicit optionals</li> <li>Null handling in put()</li> <li>Compiler forces null checks</li> </ul> <p>No concerns.</p>"},{"location":"mds/tofu-implementation-review/#8-performance-considerations","title":"8. Performance Considerations","text":""},{"location":"mds/tofu-implementation-review/#81-intrusive-structures-excellent","title":"8.1 Intrusive Structures \u2705 EXCELLENT","text":"<p>Zero allocation for queuing. Already covered. No concerns.</p>"},{"location":"mds/tofu-implementation-review/#82-pool-lifo-vs-fifo-consider","title":"8.2 Pool LIFO vs FIFO \u26a0\ufe0f CONSIDER","text":"<p>File: <code>src/ampe/Pool.zig</code></p> <p>Current: LIFO (stack) <pre><code>pub fn put(pool: *Pool, msg: *Message) void {\n    // ...\n    msg.*.next = pool.first;\n    pool.first = msg;  // Push to front\n}\n</code></pre></p> <p>Question: Why LIFO?</p> <p>LIFO Pros:</p> <ul> <li>Better cache locality (recently used message hot in cache)</li> <li>Simpler code</li> </ul> <p>FIFO Pros:</p> <ul> <li>More fair distribution</li> <li>Avoids message \"starvation\"</li> </ul> <p>Recommendation: Current LIFO is probably better for performance. Document reasoning.</p>"},{"location":"mds/tofu-implementation-review/#83-mutex-contention-potential-bottleneck","title":"8.3 Mutex Contention \u26a0\ufe0f POTENTIAL BOTTLENECK","text":"<p>Files: <code>Pool.zig</code>, <code>channels.zig</code></p> <p>Both use mutexes. Under high load, contention possible.</p> <p>Recommendation:</p> <ul> <li>Consider lock-free data structures if profiling shows contention</li> <li>Or use sharded pools (multiple pools, hash to select)</li> <li>Current approach is fine for most workloads</li> </ul>"},{"location":"mds/tofu-implementation-review/#84-message-clone-expensive","title":"8.4 Message Clone \u26a0\ufe0f EXPENSIVE","text":"<p>File: <code>src/message.zig:386</code></p> <pre><code>pub fn clone(self: *Message) !*Message {\n    const alc = self.body.allocator;\n    const msg: *Message = try alc.create(Message);\n    errdefer msg.*.destroy();\n\n    // Copy all fields\n    // Clone body and thdrs\n}\n</code></pre> <p>Used in: Reconnection logic (cookbook.zig)</p> <p>Problem: Full clone is expensive. Most reconnections probably don't need data.</p> <p>Recommendation: Consider shallow clone option (clone headers only, not body).</p>"},{"location":"mds/tofu-implementation-review/#9-code-quality-issues","title":"9. Code Quality Issues","text":""},{"location":"mds/tofu-implementation-review/#91-commented-code-remove","title":"9.1 Commented Code \u274c REMOVE","text":"<p>File: <code>src/ampe/Notifier.zig:144</code></p> <pre><code>pub fn isReadyToSend(ntfr: *Notifier) bool {\n    // _ = ntfr;\n    // return true;\n    return _isReadyToSend(ntfr.sender);\n}\n</code></pre> <p>Recommendation: Remove commented code. Git history preserves old versions.</p>"},{"location":"mds/tofu-implementation-review/#92-magic-numbers-should-be-constants","title":"9.2 Magic Numbers \u26a0\ufe0f SHOULD BE CONSTANTS","text":"<p>Examples:</p> <p>File: <code>src/ampe/Reactor.zig:100</code> <pre><code>rtr.acns = ActiveChannels.init(rtr.allocator, 1024) catch { ... }\n</code></pre></p> <p>File: <code>src/message.zig:359-360</code> <pre><code>const blen: u16 = 256;\nconst tlen: u16 = 64;\n</code></pre></p> <p>Better: <pre><code>pub const DEFAULT_ACTIVE_CHANNELS_CAPACITY: usize = 1024;\npub const DEFAULT_MESSAGE_BODY_LENGTH: u16 = 256;\npub const DEFAULT_MESSAGE_HEADERS_LENGTH: u16 = 64;\n</code></pre></p> <p>Recommendation: Extract all magic numbers to named constants.</p>"},{"location":"mds/tofu-implementation-review/#93-naming-inconsistencies-minor","title":"9.3 Naming Inconsistencies \u26a0\ufe0f MINOR","text":"<p>Mixed conventions:</p> <ul> <li><code>Create</code> vs <code>init</code> (functions that create instances)</li> <li><code>Destroy</code> vs <code>deinit</code> (functions that clean up)</li> </ul> <p>Example: <pre><code>pub fn Create(gpa: Allocator, ...) !*Reactor  // Capital C\npub fn Destroy(rtr: *Reactor) void            // Capital D\n</code></pre></p> <p>vs</p> <pre><code>pub fn init(...) !Pool      // lowercase\npub fn deinit(...) void     // lowercase\n</code></pre> <p>Zig Convention:</p> <ul> <li><code>init</code> / <code>deinit</code> for non-allocating</li> <li><code>create</code> / <code>destroy</code> when allocating</li> </ul> <p>Recommendation: Follow Zig convention consistently:</p> <ul> <li><code>Reactor.create()</code> not <code>Reactor.Create()</code></li> <li><code>reactor.destroy()</code> not <code>reactor.Destroy()</code></li> </ul>"},{"location":"mds/tofu-implementation-review/#10-zig-014-015-migration-concerns","title":"10. Zig 0.14 \u2192 0.15 Migration Concerns","text":""},{"location":"mds/tofu-implementation-review/#101-potential-breaking-changes","title":"10.1 Potential Breaking Changes","text":"<p>Based on Zig evolution, watch for:</p> <p>1. Error handling changes</p> <ul> <li>Error return traces may change</li> <li><code>anyerror</code> deprecated (tofu doesn't use it \u2713)</li> </ul> <p>2. Packed struct alignment</p> <ul> <li>May become stricter</li> <li>Test <code>BinaryHeader</code> size carefully</li> </ul> <p>3. Atomic API changes</p> <ul> <li><code>.monotonic</code> \u2192 may change</li> <li>Watch stdlib changes</li> </ul> <p>4. Build system</p> <ul> <li><code>build.zig</code> API changes likely</li> <li>Test after migration</li> </ul> <p>Recommendation: Run full test suite after Zig upgrade. Pay attention to packed structs and atomics.</p>"},{"location":"mds/tofu-implementation-review/#11-summary-of-recommendations","title":"11. Summary of Recommendations","text":""},{"location":"mds/tofu-implementation-review/#critical-fix-before-10","title":"Critical (Fix Before 1.0)","text":"<ol> <li>Reduce <code>?*anyopaque</code> usage - Add runtime type checks at minimum</li> <li>Fix undefined field initialization - Provide defaults where possible</li> <li>Fix typo - <code>invelid_mchn_group</code> \u2192 <code>invalid_mchn_group</code></li> <li>Remove TODOs from public API - Resolve or remove <code>src/ampe.zig:7</code></li> </ol>"},{"location":"mds/tofu-implementation-review/#high-priority","title":"High Priority","text":"<ol> <li>Simplify error handling - Consolidate status/error conversions</li> <li>Add error context - Log original errors before converting to AmpeError</li> <li>Document mutex ordering - Prevent potential deadlocks</li> <li>Review all asserts - Ensure they're programmer errors not user errors</li> </ol>"},{"location":"mds/tofu-implementation-review/#medium-priority","title":"Medium Priority","text":"<ol> <li>Extract magic numbers - Named constants improve maintainability</li> <li>Consistent naming - <code>create</code>/<code>destroy</code> not <code>Create</code>/<code>Destroy</code></li> <li>Remove commented code - Clean up production code</li> <li>Document special channel numbers - 0 and 65535 are special</li> </ol>"},{"location":"mds/tofu-implementation-review/#low-priority-nice-to-have","title":"Low Priority (Nice to Have)","text":"<ol> <li>Consider shallow clone - Performance optimization for reconnection</li> <li>Profile mutex contention - Optimize if needed</li> <li>Document LIFO pool choice - Explain reasoning</li> </ol>"},{"location":"mds/tofu-implementation-review/#12-positive-highlights","title":"12. Positive Highlights","text":"<p>What tofu does well:</p> <ol> <li>Intrusive data structures - Zero allocation queuing</li> <li>Ownership transfer - Excellent use of Zig pointers</li> <li>Thread safety documentation - Clear what's safe where</li> <li>Packed structs - Proper network protocol handling</li> <li>Defer/errdefer - Good cleanup patterns</li> <li>Pool pattern - Smart memory management</li> <li>Message-as-cube philosophy - Clean architecture</li> </ol>"},{"location":"mds/tofu-implementation-review/#13-conclusion","title":"13. Conclusion","text":"<p>Tofu is solid Zig code with good understanding of the language. Main concerns:</p> <p>Safety:</p> <ul> <li>Too much <code>?*anyopaque</code> reduces type safety</li> <li>Undefined field initialization risky</li> </ul> <p>Maintainability:</p> <ul> <li>Dual error system confusing</li> <li>TODOs and commented code in production</li> </ul> <p>Performance:</p> <ul> <li>Generally good</li> <li>Watch for mutex contention under load</li> </ul> <p>Overall: Fix critical items before 1.0. Rest can be iterative improvements.</p>"},{"location":"mds/tofu-message-patterns-and-recipes/","title":"Recipes","text":""},{"location":"mds/tofu-message-patterns-and-recipes/#overview","title":"Overview","text":"<p>This document explains how to work with tofu messages. It shows common patterns from the recipe files. It explains the message-as-cube concept.</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#message-anatomy-the-three-parts","title":"Message Anatomy: The Three Parts","text":"<p>Every tofu message has three parts:</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#1-persistent-fields-sent-between-peers","title":"1. Persistent Fields (Sent Between Peers)","text":""},{"location":"mds/tofu-message-patterns-and-recipes/#binaryheader-16-bytes-big-endian-on-wire","title":"BinaryHeader (16 bytes, big-endian on wire)","text":"<pre><code>pub const BinaryHeader = packed struct {\n    channel_number: u16,      // Which channel (connection)\n    proto: ProtoFields,       // 8 bits: type, role, origin, more, oob\n    status: u8,               // Success (0) or error code\n    message_id: u64,          // Unique identifier\n    @\"&lt;thl&gt;\": u16,           // Text headers length (engine-managed)\n    @\"&lt;bl&gt;\": u16,            // Body length (engine-managed)\n};\n</code></pre> <p>ProtoFields contains: - <code>mtype</code> (3 bits): welcome, hello, bye, regular - <code>role</code> (2 bits): request, response, signal - <code>origin</code> (1 bit): application or engine - <code>more</code> (1 bit): more messages in sequence coming - <code>oob</code> (1 bit): out-of-band (high priority)</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#textheaders-optional-http-style-key-value-pairs","title":"TextHeaders (Optional, HTTP-style key-value pairs)","text":"<pre><code>PDL: PDF\\r\\n\nJobTicket: JDF\\r\\n\nProgress: [1:10]\\r\\n\n\\r\\n\n</code></pre>"},{"location":"mds/tofu-message-patterns-and-recipes/#body-optional-application-data","title":"Body (Optional, application data)","text":"<p>Binary or text data. The tofu engine does not interpret this data.</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#2-transient-fields-not-sent","title":"2. Transient Fields (Not Sent)","text":"<pre><code>@\"&lt;void*&gt;\": ?*anyopaque,  // Your application can use this\n@\"&lt;ctx&gt;\": ?*anyopaque,    // Tofu engine uses this internally\n</code></pre>"},{"location":"mds/tofu-message-patterns-and-recipes/#3-intrusive-list-nodes-for-internal-queue-management","title":"3. Intrusive List Nodes (For Internal Queue Management)","text":"<pre><code>prev: ?*Self,  // Previous message in queue\nnext: ?*Self,  // Next message in queue\n</code></pre>"},{"location":"mds/tofu-message-patterns-and-recipes/#message-lifecycle-pool-use-pool","title":"Message Lifecycle: Pool \u2192 Use \u2192 Pool","text":""},{"location":"mds/tofu-message-patterns-and-recipes/#the-rule","title":"The Rule","text":"<p>Messages come from a pool. Messages return to the pool. Always use get() and put().</p> <pre><code>// 1. Get message from pool\nvar msg: ?*Message = try ampe.get(.always);\n\n// 2. Use defer to ensure message returns to pool\ndefer ampe.put(&amp;msg);\n\n// 3. Set message fields\nmsg.?.*.bhdr.proto.mtype = .hello;\nmsg.?.*.bhdr.proto.role = .request;\ntry msg.?.*.thdrs.add(\"Config\", \"value\");\n\n// 4. Send (ownership moves to engine, msg becomes null)\n_ = try chnls.enqueueToPeer(&amp;msg);\n\n// After send, msg is null. You cannot use it anymore.\n</code></pre>"},{"location":"mds/tofu-message-patterns-and-recipes/#allocation-strategies","title":"Allocation Strategies","text":"<pre><code>pub const AllocationStrategy = enum {\n    poolOnly,  // Return null if pool is empty\n    always,    // Create new message if pool is empty\n};\n</code></pre> <p>Use poolOnly when: - Performance is critical - You want to handle pool_empty status yourself - You have backup logic</p> <p>Use always when: - You want simpler code - You do not want to handle null returns - Pool exhaustion is rare</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#pool-configuration","title":"Pool Configuration","text":"<pre><code>pub const Options = struct {\n    initialPoolMsgs: ?u16 = null,  // Messages created at start\n    maxPoolMsgs: ?u16 = null,      // Maximum pool size\n};\n\nconst DefaultOptions: Options = .{\n    .initialPoolMsgs = 16,\n    .maxPoolMsgs = 64,\n};\n</code></pre> <p>How to tune the pool: - Start with default values - If you see frequent <code>pool_empty</code> status \u2192 increase <code>maxPoolMsgs</code> - If memory usage is too high \u2192 decrease <code>maxPoolMsgs</code> - Set <code>initialPoolMsgs</code> = expected number of concurrent messages</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#common-message-patterns","title":"Common Message Patterns","text":""},{"location":"mds/tofu-message-patterns-and-recipes/#pattern-1-request-response","title":"Pattern 1: Request-Response","text":"<p>From S/R Dialog: \"I will send a HelloRequest\" \u2192 \"Send me a HelloResponse\"</p> <pre><code>// Client sends request\nvar request: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;request);\n\nrequest.?.*.bhdr.proto.mtype = .hello;\nrequest.?.*.bhdr.proto.role = .request;\nrequest.?.*.bhdr.channel_number = 0;  // Hello uses channel 0\n\nconst sentBhdr: BinaryHeader = try chnls.enqueueToPeer(&amp;request);\n\n// Server receives and responds\nvar received: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;received);\n\nassert(received.?.*.bhdr.proto.mtype == .hello);\nassert(received.?.*.bhdr.proto.role == .request);\n\n// Server reuses the received message to send response\nreceived.?.*.bhdr.proto.role = .response;\n_ = try chnls.enqueueToPeer(&amp;received);\n\n// Client receives response\nvar response: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;response);\n\nassert(response.?.*.bhdr.message_id == sentBhdr.message_id);  // Same ID\n</code></pre> <p>Important: Response uses the same message_id as request.</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#pattern-2-multi-request-sequence","title":"Pattern 2: Multi-Request Sequence","text":"<p>From S/R Dialog: \"multi-requests with message ID equal to job ID\"</p> <pre><code>const jobId: u64 = 12345;\n\n// Send multiple messages for one job\nfor (chunks) |chunk| {\n    var msg: ?*Message = try ampe.get(.always);\n    defer ampe.put(&amp;msg);\n\n    msg.?.*.bhdr.proto.mtype = .regular;\n    msg.?.*.bhdr.proto.role = .request;\n    msg.?.*.bhdr.message_id = jobId;  // Same ID for all chunks\n    msg.?.*.bhdr.channel_number = channelNum;\n\n    // Is this the last chunk?\n    if (chunk == chunks[chunks.len - 1]) {\n        msg.?.*.bhdr.proto.more = .last;\n    } else {\n        msg.?.*.bhdr.proto.more = .expected;\n    }\n\n    // Add chunk data to body\n    try msg.?.*.body.append(chunk);\n\n    _ = try chnls.enqueueToPeer(&amp;msg);\n}\n</code></pre> <p>Important: Same message_id connects related messages.</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#pattern-3-signal-one-way","title":"Pattern 3: Signal (One-Way)","text":"<p>From S/R Dialog: \"I will send signals with the same message ID for progress\"</p> <pre><code>// Progress update (no response expected)\nvar progress: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;progress);\n\nprogress.?.*.bhdr.proto.mtype = .regular;\nprogress.?.*.bhdr.proto.role = .signal;  // Signal means no response\nprogress.?.*.bhdr.message_id = jobId;\nprogress.?.*.bhdr.channel_number = channelNum;\n\n// Add progress data\ntry progress.?.*.thdrs.add(\"Progress\", \"[5:10]\");\n\n_ = try chnls.enqueueToPeer(&amp;progress);\n</code></pre> <p>Important: Signals do not expect responses. Fire and forget.</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#pattern-4-out-of-band-priority","title":"Pattern 4: Out-of-Band (Priority)","text":"<pre><code>// Close connection immediately\nvar bye: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;bye);\n\nbye.?.*.bhdr.proto.mtype = .bye;\nbye.?.*.bhdr.proto.role = .signal;\nbye.?.*.bhdr.proto.oob = .on;  // High priority\nbye.?.*.bhdr.channel_number = channelNum;\n\n_ = try chnls.enqueueToPeer(&amp;bye);\n</code></pre> <p>Important: OOB messages go to front of send queue.</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#recipe-file-patterns","title":"Recipe File Patterns","text":""},{"location":"mds/tofu-message-patterns-and-recipes/#pattern-a-echoservice-serviceszig","title":"Pattern A: EchoService (services.zig)","text":"<p>Purpose: Simple echo server. Receives request. Sends response.</p> <p>Code pattern: <pre><code>fn processMessage(echo: *EchoService, msg: *?*Message) bool {\n    // Check if pool is empty\n    if (status.raw_to_status(msg.*.?.*.bhdr.status) == .pool_empty) {\n        return echo.*.addMessagesToPool();\n    }\n\n    // Change request to response\n    if (msg.*.?.*.bhdr.proto.role == .request) {\n        msg.*.?.*.bhdr.proto.role = .response;\n    }\n\n    // Send back\n    _ = echo.*.sendTo.?.enqueueToPeer(msg) catch {\n        return false;\n    };\n\n    return true;  // Continue processing\n}\n</code></pre></p> <p>What you learn: - Handle <code>pool_empty</code> by adding messages to pool - You can reuse messages (change request to response) - Return <code>true</code> to continue processing. Return <code>false</code> to stop.</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#pattern-b-echoclient-serviceszig","title":"Pattern B: EchoClient (services.zig)","text":"<p>Purpose: Complete client: connect \u2192 exchange messages \u2192 disconnect</p> <p>Code pattern: <pre><code>fn connect(self: *Self) !void {\n    // Send HelloRequest\n    var helloRequest: ?*Message = self.*.ampe.get(.always) catch unreachable;\n    defer self.*.ampe.put(&amp;helloRequest);\n\n    self.*.cfg.prepareRequest(helloRequest.?) catch unreachable;\n    self.*.helloBh = try self.*.chnls.?.enqueueToPeer(&amp;helloRequest);\n\n    // Wait for response. Retry on pool_empty.\n    while (true) {\n        var response: ?*Message = try self.*.chnls.?.waitReceive(timeout);\n        defer self.*.ampe.put(&amp;response);\n\n        // Check status\n        const sts: AmpeStatus = status.raw_to_status(response.?.*.bhdr.status);\n\n        if (sts == .pool_empty) {\n            continue;  // defer returns message to pool. Try again.\n        }\n\n        if (response.?.*.bhdr.proto.origin == .engine) {\n            // This error came from tofu engine\n            return status.status_to_error(sts);\n        }\n\n        // Success\n        assert(response.?.*.bhdr.proto.mtype == .hello);\n        assert(response.?.*.bhdr.proto.role == .response);\n        break;\n    }\n}\n</code></pre></p> <p>What you learn: - Save BinaryHeader from send. You need it for correlation. - Loop on <code>waitReceive</code> to handle pool_empty - Check <code>origin</code> field. Distinguishes engine errors from application errors. - Use defer pattern for all messages</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#pattern-c-multihomed-multihomedzig","title":"Pattern C: MultiHomed (MultiHomed.zig)","text":"<p>Purpose: One thread. Multiple listeners. Multiple clients.</p> <p>Code pattern: <pre><code>fn mainLoop(mh: *MultiHomed) void {\n    while (true) {\n        var receivedMsg: ?*Message = mh.*.chnls.?.waitReceive(timeout) catch {\n            return;\n        };\n        defer mh.*.ampe.?.put(&amp;receivedMsg);\n\n        const sts: AmpeStatus = status.raw_to_status(receivedMsg.?.*.bhdr.status);\n\n        // Check for stop command\n        if (sts == .receiver_update) {\n            return;\n        }\n\n        // Check if this is a listener channel\n        if (mh.*.lstnChnls.?.contains(receivedMsg.?.*.bhdr.channel_number)) {\n            // Listener channel has error\n            return;\n        }\n\n        // This is a client channel. Pass to service.\n        const cont: bool = mh.*.srvcs.onMessage(&amp;receivedMsg);\n        if (!cont) {\n            return;\n        }\n    }\n}\n</code></pre></p> <p>What you learn: - One <code>waitReceive()</code> handles all channels - You dispatch by channel_number - <code>receiver_update</code> status means another thread woke you up - Cooperative service pattern</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#pattern-d-reconnection-cookbookzig","title":"Pattern D: Reconnection (cookbook.zig)","text":"<p>Purpose: Handle connection failures without crashing</p> <p>Code pattern: <pre><code>fn tryToConnect(cc: *ClientConnector, recvd: *?*Message) !bool {\n    defer cc.*.ampe.put(recvd);\n\n    if (cc.*.connected) {\n        return true;\n    }\n\n    // First time: send HelloRequest\n    if (cc.helloBh == null) {\n        var helloClone: ?*Message = try cc.*.helloRequest.?.*.clone();\n        cc.*.helloBh = cc.*.chnls.?.enqueueToPeer(&amp;helloClone) catch |err| {\n            cc.*.ampe.put(&amp;helloClone);\n            return err;\n        };\n    }\n\n    // No response yet\n    if (recvd.* == null) {\n        return false;\n    }\n\n    // Check status and decide what to do\n    switch (status.raw_to_status((*recvd.*.?).bhdr.status)) {\n        .success =&gt; {\n            cc.*.connected = true;\n            return true;\n        },\n        .connect_failed, .channel_closed =&gt; {\n            cc.*.helloBh = null;  // Reset. Will retry.\n            return false;\n        },\n        .invalid_address =&gt; return AmpeError.InvalidAddress,  // Fatal error\n        .pool_empty =&gt; return false,  // Will retry\n        else =&gt; |st| return status.status_to_error(st),\n    }\n}\n</code></pre></p> <p>What you learn: - Save request message for retries. Clone if needed. - Separate fatal errors from temporary errors - Reset state on temporary failures - Caller controls retry timing</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"mds/tofu-message-patterns-and-recipes/#status-check-pattern","title":"Status Check Pattern","text":"<pre><code>var msg: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;msg);\n\nconst st: u8 = msg.?.*.bhdr.status;\nconst ampeSt: AmpeStatus = status.raw_to_status(st);\n\n// Check origin first\nif (msg.?.*.bhdr.proto.origin == .engine) {\n    // This is an engine status\n    switch (ampeSt) {\n        .success =&gt; {},\n        .pool_empty =&gt; try addMessagesToPool(3),\n        .connect_failed =&gt; return error.ConnectionFailed,\n        .channel_closed =&gt; return error.ChannelClosed,\n        else =&gt; return status.status_to_error(ampeSt),\n    }\n} else {\n    // This is application status. Your custom logic.\n    if (st != 0) {\n        // Handle your application error\n    }\n}\n</code></pre>"},{"location":"mds/tofu-message-patterns-and-recipes/#pool-empty-handling","title":"Pool Empty Handling","text":"<pre><code>// Strategy 1: Add messages to pool\nif (ampeSt == .pool_empty) {\n    const allocator: Allocator = ampe.getAllocator();\n    for (0..3) |_| {\n        var newMsg: ?*Message = try Message.create(allocator);\n        ampe.put(&amp;newMsg);\n    }\n    continue;  // Retry operation\n}\n\n// Strategy 2: Use poolOnly and handle null\nvar msg: ?*Message = try ampe.get(.poolOnly);\nif (msg == null) {\n    // Pool is empty. Do something else or wait.\n    std.Thread.sleep(100 * std.time.ns_per_ms);\n    continue;\n}\ndefer ampe.put(&amp;msg);\n</code></pre>"},{"location":"mds/tofu-message-patterns-and-recipes/#threading-patterns","title":"Threading Patterns","text":""},{"location":"mds/tofu-message-patterns-and-recipes/#single-threaded-pattern","title":"Single-Threaded Pattern","text":"<pre><code>// One engine. One channel group. One thread.\nconst rtr: *Reactor = try Reactor.Create(gpa, options);\ndefer rtr.*.Destroy();\n\nconst ampe: Ampe = try rtr.*.ampe();\nconst chnls: ChannelGroup = try ampe.create();\ndefer tofu.DestroyChannels(ampe, chnls);\n\n// All operations happen on this thread\nwhile (true) {\n    var msg: ?*Message = try chnls.waitReceive(timeout);\n    defer ampe.put(&amp;msg);\n    // Process msg here\n}\n</code></pre>"},{"location":"mds/tofu-message-patterns-and-recipes/#multi-threaded-pattern","title":"Multi-Threaded Pattern","text":"<pre><code>// One engine. Multiple channel groups. Multiple threads.\nconst rtr: *Reactor = try Reactor.Create(gpa, options);\ndefer rtr.*.Destroy();\n\nconst ampe: Ampe = try rtr.*.ampe();\n\n// Thread 1: Server\nconst serverChnls: ChannelGroup = try ampe.create();\nconst serverThread = try std.Thread.spawn(.{}, serverLoop, .{ampe, serverChnls});\n\n// Thread 2: Client\nconst clientChnls: ChannelGroup = try ampe.create();\nconst clientThread = try std.Thread.spawn(.{}, clientLoop, .{ampe, clientChnls});\n\n// These operations are thread-safe:\n// - ampe.get() / ampe.put()\n// - chnls.enqueueToPeer()\n// - chnls.updateReceiver()\n\n// This operation is NOT thread-safe:\n// - chnls.waitReceive() - call from ONE thread only per ChannelGroup\n</code></pre>"},{"location":"mds/tofu-message-patterns-and-recipes/#updatereceiver-pattern","title":"updateReceiver Pattern","text":"<pre><code>// Thread A: Waiting for messages\nwhile (true) {\n    var msg: ?*Message = try chnls.waitReceive(timeout);\n    defer ampe.put(&amp;msg);\n\n    if (status.raw_to_status(msg.?.*.bhdr.status) == .receiver_update) {\n        // Another thread woke me up\n        break;\n    }\n}\n\n// Thread B: Wake Thread A\nvar nullMsg: ?*Message = null;\ntry chnls.updateReceiver(&amp;nullMsg);  // Wake waitReceive\n\n// Or send data to Thread A\nvar notifyMsg: ?*Message = try ampe.get(.always);\ntry notifyMsg.?.*.thdrs.add(\"Command\", \"stop\");\ntry chnls.updateReceiver(&amp;notifyMsg);  // notifyMsg becomes null\n</code></pre>"},{"location":"mds/tofu-message-patterns-and-recipes/#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"mds/tofu-message-patterns-and-recipes/#tcp-server","title":"TCP Server","text":"<pre><code>var cfg: Configurator = .{\n    .tcp_server = TCPServerConfigurator.init(\"0.0.0.0\", port)\n};\n\nvar msg: ?*Message = try ampe.get(.always);\ntry cfg.prepareRequest(msg.?);  // This adds TextHeaders to message\n\nmsg.?.*.bhdr.proto.mtype = .welcome;\nmsg.?.*.bhdr.proto.role = .request;\n</code></pre>"},{"location":"mds/tofu-message-patterns-and-recipes/#tcp-client","title":"TCP Client","text":"<pre><code>var cfg: Configurator = .{\n    .tcp_client = TCPClientConfigurator.init(\"127.0.0.1\", port)\n};\n\nvar msg: ?*Message = try ampe.get(.always);\ntry cfg.prepareRequest(msg.?);  // This adds TextHeaders to message\n\nmsg.?.*.bhdr.proto.mtype = .hello;\nmsg.?.*.bhdr.proto.role = .request;\n</code></pre>"},{"location":"mds/tofu-message-patterns-and-recipes/#uds-serverclient","title":"UDS Server/Client","text":"<pre><code>const path: []const u8 = \"/tmp/tofu.sock\";\n\nvar srvCfg: Configurator = .{\n    .uds_server = UDSServerConfigurator.init(path)\n};\n\nvar cltCfg: Configurator = .{\n    .uds_client = UDSClientConfigurator.init(path)\n};\n</code></pre>"},{"location":"mds/tofu-message-patterns-and-recipes/#message-as-cube-real-example","title":"Message as Cube: Real Example","text":"<p>The S/R dialog with actual message structures:</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#cube-1-hello-with-pdl","title":"Cube 1: Hello with PDL","text":"<pre><code>// Worker tells server: I can handle PDF or PS\nvar hello: Message = .{\n    .bhdr = .{\n        .channel_number = 0,\n        .proto = .{ .mtype = .hello, .role = .request, .origin = .application },\n        .status = 0,\n        .message_id = 1,\n    },\n};\ntry hello.thdrs.add(\"PDL\", \"PDF\");  // Add PDL type to message\n</code></pre>"},{"location":"mds/tofu-message-patterns-and-recipes/#cube-2-job-ticket","title":"Cube 2: Job Ticket","text":"<pre><code>// First request: send ticket\nvar jobTicket: Message = .{\n    .bhdr = .{\n        .channel_number = channelNum,\n        .proto = .{ .mtype = .regular, .role = .request, .origin = .application },\n        .message_id = jobId,  // Job ID becomes message ID\n    },\n};\ntry jobTicket.thdrs.add(\"JobTicket\", \"JDF\");\ntry jobTicket.body.append(ticketData);\n</code></pre>"},{"location":"mds/tofu-message-patterns-and-recipes/#cube-3-pdl-data","title":"Cube 3: PDL Data","text":"<pre><code>// Next requests: send PDL chunks\nvar pdfChunk: Message = .{\n    .bhdr = .{\n        .channel_number = channelNum,\n        .proto = .{\n            .mtype = .regular,\n            .role = .request,\n            .origin = .application,\n            .more = .expected,  // More chunks are coming\n        },\n        .message_id = jobId,  // Same job\n    },\n};\ntry pdfChunk.thdrs.add(\"PDL\", \"PDF\");\ntry pdfChunk.body.append(pdfData);\n</code></pre>"},{"location":"mds/tofu-message-patterns-and-recipes/#cube-4-progress-signal","title":"Cube 4: Progress Signal","text":"<pre><code>// Progress update\nvar progress: Message = .{\n    .bhdr = .{\n        .channel_number = channelNum,\n        .proto = .{ .mtype = .regular, .role = .signal, .origin = .application },\n        .message_id = jobId,  // Same job\n    },\n};\ntry progress.thdrs.add(\"Progress\", \"[5:10]\");  // Page 5 of 10\n</code></pre> <p>Pattern: Each cube is independent. But they connect through: - Same <code>channel_number</code> (one worker) - Same <code>message_id</code> (one job) - Different <code>role</code> (request vs signal) - Different headers (JobTicket vs PDL vs Progress)</p> <p>This shows message-as-cube. You combine simple cubes to build complex flows.</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#summary-important-points","title":"Summary: Important Points","text":""},{"location":"mds/tofu-message-patterns-and-recipes/#1-messages-use-pool","title":"1. Messages Use Pool","text":"<p>Always use <code>get()</code> and <code>put()</code>. The defer pattern helps you.</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#2-send-transfers-ownership","title":"2. Send Transfers Ownership","text":"<p>After <code>enqueueToPeer()</code>, message becomes null. You cannot use it. This prevents bugs.</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#3-message-id-is-context","title":"3. Message ID is Context","text":"<p>Use message_id for correlation. Use it for business transactions. Use it for multi-message sequences.</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#4-roles-have-meaning","title":"4. Roles Have Meaning","text":"<ul> <li>Request: expects response</li> <li>Response: completes request (same message_id)</li> <li>Signal: one-way notification</li> </ul>"},{"location":"mds/tofu-message-patterns-and-recipes/#5-headers-extend-protocol","title":"5. Headers Extend Protocol","text":"<p>Add your own headers. Old code ignores unknown headers. No breaking changes.</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#6-status-byte-has-errors","title":"6. Status Byte Has Errors","text":"<p>Check <code>origin</code> first. Engine errors are different from application errors.</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#7-one-channelgroup-one-waitreceive-thread","title":"7. One ChannelGroup = One waitReceive Thread","text":"<p>But many threads can call <code>enqueueToPeer()</code> and <code>updateReceiver()</code>.</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#8-channels-are-independent","title":"8. Channels are Independent","text":"<p>Each channel is separate. No message routing needed.</p>"},{"location":"mds/tofu-message-patterns-and-recipes/#learning-path","title":"Learning Path","text":"<ol> <li>Read <code>cookbook.zig</code> examples in order</li> <li>Try <code>EchoService</code> pattern first (most simple)</li> <li>Study <code>MultiHomed</code> for multiple listeners</li> <li>Learn reconnection patterns</li> <li>Design your own message flow (like S and R did)</li> </ol> <p>Remember: tofu provides foundations. You build your communication on top. You use simple message passing.</p>"},{"location":"mds/tofu-philosophy-and-advantages/","title":"Philosophy","text":""},{"location":"mds/tofu-philosophy-and-advantages/#executive-summary","title":"Executive Summary","text":"<p>Tofu is fundamentally different from traditional messaging frameworks. Its core philosophy: \"The Message is the API\" - meaning the data structure itself defines the communication contract, not complex API interfaces.</p> <p>This document analyzes tofu's unique approach, centered on the S/R dialog pattern, and explains why this matters for developers building distributed systems.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#the-core-philosophy-three-principles","title":"The Core Philosophy: Three Principles","text":""},{"location":"mds/tofu-philosophy-and-advantages/#1-the-message-is-the-api","title":"1. The Message is the API","text":"<p>The data itself defines the connection. No complex API contracts, RPC definitions, or service interfaces required upfront. The message structure IS the contract.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#2-gradual-evolution","title":"2. Gradual Evolution","text":"<p>Start with something simple and grow it into a powerful system over time. Begin with basic message exchange, then add complexity as needed.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#3-the-mantra-connect-your-developers-then-connect-your-applications","title":"3. The Mantra: \"Connect your developers. Then connect your applications.\"","text":"<p>This is a paraphrase of Conway's Law. Tofu expects development to start with a conversation between developers, not with API specifications.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#the-sr-dialog-tofus-killer-feature","title":"The S/R Dialog: Tofu's Killer Feature","text":""},{"location":"mds/tofu-philosophy-and-advantages/#the-dialog-from-readmemd","title":"The Dialog (From README.md)","text":"<p>Context: Two developers discussing the message flow for a new Print Server: - S: Spool Server developer - R: RIP Worker Process developer (Raster Image Processing)</p> <pre><code>S: I don't know the addresses of the workers, so you should connect to me.\n\nR: I'll send a HelloRequest, because the worker can process only specific PDL types,\n   the PDL header will contain either PS or PDF.\n\nS: Do I need to send you a HelloResponse?\n\nR: No, just start sending me messages with PDL data.\n\nS: As signals?\n\nR: No, as multi-requests \u2014 each with a message ID equal to the job ID.\n\nS: You forgot the Job Ticket.\n\nR: Right. The first request should have a JobTicket header (JDF or PPD) and the\n   ticket data in the body. The following requests will have the PDL header\n   (PDF or PS) with the related content.\n\nS: But JDF is usually used only for PDF...\n\nR: Yes, but let's keep it flexible.\n\nS: Can you process several jobs simultaneously?\n\nR: It depends on licensing. Anyway, if I can, I'll send another HelloRequest \u2014\n   working one job per channel looks cleaner.\n\nS: I need a progress indicator.\n\nR: No problem. I'll send signals with the same message ID \u2014 the Progress header\n   will show the range [N:M] for page numbers.\n\nS: On job finish, send me a Response with the same message ID and processing status.\n   Also include the Progress header.\n\nR: Why should I send an obsolete message? Are you expecting a graceful close?\n\nS: Of course.\n\nR: Then I'll send a ByeRequest with the same information, and you'll send me a\n   ByeResponse. After that, I'll abort the connection immediately.\n\nS: That's enough for today. Send me a short text file with this protocol \u2014\n   I'll save it in Git.\n\nR: Deal. How about a cup of coffee?\n</code></pre>"},{"location":"mds/tofu-philosophy-and-advantages/#why-this-dialog-matters","title":"Why This Dialog Matters","text":"<p>Traditional Approach (API-First): 1. Define service interfaces (gRPC, Thrift, etc.) 2. Generate code from IDL 3. Implement complex service classes 4. Handle versioning, compatibility 5. Then finally: start coding business logic</p> <p>Tofu Approach (Message-First): 1. Have a conversation like S and R 2. Define message structure (headers + body) 3. Write the protocol as plain text 4. Implement directly using Messages 5. Done - you're coding business logic from day 1</p>"},{"location":"mds/tofu-philosophy-and-advantages/#messages-as-cubes-the-tofu-metaphor","title":"Messages as Cubes: The Tofu Metaphor","text":""},{"location":"mds/tofu-philosophy-and-advantages/#the-food-analogy","title":"The Food Analogy","text":"<p>As a food, tofu is very simple and has almost no flavor on its own. By using tofu cubes, you can: - Eat it plain for a simple snack - Add a little spice to make it better - Create a culinary masterpiece</p>"},{"location":"mds/tofu-philosophy-and-advantages/#the-software-analogy","title":"The Software Analogy","text":"<p>As a protocol, tofu uses messages like cubes. By \"cooking\" these messages together, you can grow your project: - Start with minimal setups - Build complex flows - Create full distributed applications</p>"},{"location":"mds/tofu-philosophy-and-advantages/#messages-building-blocks","title":"Messages = Building Blocks","text":"<p>Each message is a self-contained cube: - BinaryHeader (16 bytes): Metadata (channel, type, role, status, message_id) - TextHeaders (optional): Key-value pairs for configuration/app data - Body (optional): Application payload</p> <p>You combine these cubes to build complex communication flows, just like combining tofu cubes creates a meal.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#key-advantages-analysis","title":"Key Advantages Analysis","text":""},{"location":"mds/tofu-philosophy-and-advantages/#1-developer-communication-first","title":"1. Developer Communication First","text":"<p>Traditional frameworks force you to think in: - Service definitions - Method signatures - Complex type systems - Code generation tools</p> <p>Tofu lets you think in: - Natural conversation (\"I'll send you a HelloRequest with PDL type\") - Message flow (\"You reply with HelloResponse, then I send multi-requests\") - Business logic (\"Progress header will show [N:M] for page numbers\")</p>"},{"location":"mds/tofu-philosophy-and-advantages/#2-flexibility-without-complexity","title":"2. Flexibility Without Complexity","text":"<p>Notice in the S/R dialog: - They changed their mind mid-conversation (\"You forgot the Job Ticket\") - They discussed options (\"JDF is usually only for PDF\" \u2192 \"Let's keep it flexible\") - They adapted the protocol on the fly (\"working one job per channel looks cleaner\")</p> <p>Traditional API-first would require: - Regenerating code - Updating service definitions - Version management - Complex migration paths</p> <p>Tofu just requires: - Updating the message structure - Documenting the new headers - Implementing the logic</p>"},{"location":"mds/tofu-philosophy-and-advantages/#3-message-id-as-business-context","title":"3. Message ID as Business Context","text":"<p>In the S/R dialog: \"each with a message ID equal to the job ID\"</p> <p>This is powerful - the message ID becomes your business transaction ID. No need for separate correlation, no complex context propagation. The message carries everything.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#4-channel-per-context","title":"4. Channel per Context","text":"<p>\"I'll send another HelloRequest \u2014 working one job per channel looks cleaner\"</p> <p>Each channel is an independent communication stream. No multiplexing complexity, no message routing overhead. One channel = one context.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#5-headers-as-protocol-extension","title":"5. Headers as Protocol Extension","text":"<ul> <li>PDL header: PS or PDF</li> <li>JobTicket header: JDF or PPD</li> <li>Progress header: [N:M]</li> </ul> <p>Headers extend the protocol naturally without breaking compatibility. Old code ignores unknown headers, new code uses them.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#6-roles-make-semantics-clear","title":"6. Roles Make Semantics Clear","text":"<ul> <li>Request: Expects response</li> <li>Response: Reply to request (same message_id)</li> <li>Signal: One-way, no response expected</li> </ul> <p>The S/R dialog shows this: signals for progress, requests for jobs, responses for completion.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#7-peer-to-peer-after-handshake","title":"7. Peer-to-Peer After Handshake","text":"<p>After Hello/Welcome, both sides are equal peers. No client/server rigidity. Both can send requests, both can signal. True duplex communication.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#what-tofu-is-not","title":"What Tofu Is NOT","text":""},{"location":"mds/tofu-philosophy-and-advantages/#not-a-high-level-framework","title":"Not a High-Level Framework","text":"<p>Tofu doesn't provide: - Built-in serialization (JSON, Protobuf, etc.) - you choose - Authentication/authorization - you implement - Load balancing, discovery - you design</p> <p>This is intentional. Tofu is the foundation. You build your solution on top.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#not-zero-configuration","title":"Not \"Zero Configuration\"","text":"<p>You must: - Design your message structure - Handle your business logic - Manage your application state</p> <p>But: You do this with simple message passing, not complex frameworks.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#not-opinionated-about-business-logic","title":"Not Opinionated About Business Logic","text":"<p>Tofu doesn't force: - Request/response patterns only - Pub/sub only - RPC semantics</p> <p>You design the flow that makes sense for your application (like S and R did).</p>"},{"location":"mds/tofu-philosophy-and-advantages/#from-user-perspective-getting-started","title":"From User Perspective: Getting Started","text":""},{"location":"mds/tofu-philosophy-and-advantages/#1-have-the-conversation","title":"1. Have the Conversation","text":"<p>Sit with your peer (like S and R) and discuss: - Who connects to whom? - What message types do we need? - What goes in headers? What in body? - Request/response or signals? - What are the failure modes?</p>"},{"location":"mds/tofu-philosophy-and-advantages/#2-write-it-down","title":"2. Write It Down","text":"<p>Create a simple text file describing: <pre><code>Client \u2192 Server: HelloRequest with PDL header (PS or PDF)\nServer \u2192 Client: HelloResponse (success)\nClient \u2192 Server: Request with JobTicket header (JDF/PPD) + ticket data in body\nClient \u2192 Server: Requests with PDL header + PDL data in body (same message_id)\nClient \u2192 Server: Signals with Progress header [N:M]\nClient \u2192 Server: ByeRequest\nServer \u2192 Client: ByeResponse\n</code></pre></p>"},{"location":"mds/tofu-philosophy-and-advantages/#3-implement-with-tofu-messages","title":"3. Implement with Tofu Messages","text":"<pre><code>// Get message from pool\nvar msg: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;msg);\n\n// Set message type and role\nmsg.?.*.bhdr.proto.mtype = .hello;\nmsg.?.*.bhdr.proto.role = .request;\n\n// Add your business headers\ntry msg.?.*.thdrs.add(\"PDL\", \"PDF\");\n\n// Send it\n_ = try chnls.enqueueToPeer(&amp;msg);\n\n// Receive response\nvar resp: ?*Message = try chnls.waitReceive(timeout);\n// Process resp...\n</code></pre>"},{"location":"mds/tofu-philosophy-and-advantages/#4-iterate","title":"4. Iterate","text":"<p>Change your protocol as you learn. Add headers. Adjust message types. Refine the flow.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#comparison-with-other-approaches","title":"Comparison with Other Approaches","text":""},{"location":"mds/tofu-philosophy-and-advantages/#vs-grpcthrift","title":"vs. gRPC/Thrift","text":"<p>gRPC: - Define .proto files - Generate code - Implement service interfaces - Complex error handling - Version management hell</p> <p>Tofu: - Define message structure (can be plain text) - Write business logic with messages - Handle errors via status byte - Evolve headers naturally</p>"},{"location":"mds/tofu-philosophy-and-advantages/#vs-http-rest","title":"vs. HTTP REST","text":"<p>REST: - URL design debates - HTTP method semantics - Status code confusion - No built-in duplex</p> <p>Tofu: - Channels (not URLs) - Message roles (request/response/signal) - Status byte + custom app statuses - Full duplex by design</p>"},{"location":"mds/tofu-philosophy-and-advantages/#vs-message-queue-rabbitmq-kafka","title":"vs. Message Queue (RabbitMQ, Kafka)","text":"<p>MQ: - Topics, queues, exchanges - Complex routing - Separate broker infrastructure - Usually one-way</p> <p>Tofu: - Channels (direct peer-to-peer) - No broker needed - Built into your app - Bidirectional by default</p>"},{"location":"mds/tofu-philosophy-and-advantages/#the-tofu-advantage-summary","title":"The Tofu Advantage Summary","text":""},{"location":"mds/tofu-philosophy-and-advantages/#1-conversation-driven-development","title":"1. Conversation-Driven Development","text":"<p>Start with human discussion, not API specs. The S/R dialog proves this works.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#2-messages-as-first-class-citizens","title":"2. Messages as First-Class Citizens","text":"<p>Everything is a message. Protocol commands (Hello, Bye) and application data use the same structure.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#3-gradual-complexity","title":"3. Gradual Complexity","text":"<p>Start simple, add sophistication as needed. No big-design-up-front required.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#4-flexibility-through-simplicity","title":"4. Flexibility Through Simplicity","text":"<p>16-byte binary header + optional text headers + optional body = infinite possibilities.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#5-no-lock-in","title":"5. No Lock-In","text":"<ul> <li>Choose your serialization</li> <li>Choose your authentication</li> <li>Choose your deployment model</li> </ul>"},{"location":"mds/tofu-philosophy-and-advantages/#6-threading-model-that-works","title":"6. Threading Model That Works","text":"<ul> <li>Thread-safe APIs for <code>get()</code>, <code>put()</code>, <code>enqueueToPeer()</code></li> <li>Single-threaded <code>waitReceive()</code> per ChannelGroup</li> <li>Clear concurrency model</li> </ul>"},{"location":"mds/tofu-philosophy-and-advantages/#7-explicit-not-magic","title":"7. Explicit, Not Magic","text":"<ul> <li>Explicit pointer dereferencing</li> <li>Explicit type annotations</li> <li>No hidden behaviors</li> <li>What you see is what you get</li> </ul>"},{"location":"mds/tofu-philosophy-and-advantages/#success-pattern-the-recipe-files","title":"Success Pattern: The Recipe Files","text":"<p>The recipe files (cookbook.zig, services.zig, MultiHomed.zig) show real patterns:</p>"},{"location":"mds/tofu-philosophy-and-advantages/#echoservice","title":"EchoService","text":"<p>Simple service: receive request \u2192 send response. Shows the basics.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#multihomed","title":"MultiHomed","text":"<p>Multiple listeners (TCP + UDS) on one thread. Shows scaling pattern.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#echoclientserver","title":"EchoClientServer","text":"<p>Complete system with multiple clients and server. Shows production-like setup.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#reconnection-patterns","title":"Reconnection Patterns","text":"<p>Both single-threaded and multi-threaded reconnection. Shows resilience.</p> <p>Each pattern builds on messages. No complex inheritance, no deep abstraction layers. Just messages flowing through channels.</p>"},{"location":"mds/tofu-philosophy-and-advantages/#conclusion","title":"Conclusion","text":"<p>Tofu's philosophy is radical in its simplicity:</p> <p>Don't design APIs. Design conversations. Don't implement services. Send messages. Don't build frameworks. Combine cubes.</p> <p>The S/R dialog isn't just an example - it's the entire development methodology:</p> <ol> <li>Talk about what messages you need</li> <li>Write down the message flow</li> <li>Implement with tofu Messages</li> <li>Iterate based on real usage</li> </ol> <p>This is tofu's killer feature: it gets out of your way and lets you focus on what you're communicating, not how the framework wants you to communicate.</p>"},{"location":"mds/tofu-quick-reference-guide/","title":"Quick Reference","text":""},{"location":"mds/tofu-quick-reference-guide/#purpose","title":"Purpose","text":"<p>This document provides quick reference for developers working with tofu. </p>"},{"location":"mds/tofu-quick-reference-guide/#core-concepts-30-second-summary","title":"Core Concepts (30-Second Summary)","text":"<p>Tofu Philosophy:</p> <ul> <li>Message is the API</li> <li>Design through conversation (like S/R dialog)</li> <li>Messages are cubes - combine them to build flows</li> </ul> <p>Three Main Components:</p> <ol> <li>Ampe - The engine (owns resources)</li> <li>ChannelGroup - Manages message exchange</li> <li>Message - Data + command (16-byte header + optional text headers + optional body)</li> </ol> <p>Message Roles:</p> <ul> <li>Request - expects response</li> <li>Response - replies to request (same message_id)</li> <li>Signal - one-way, no response</li> </ul>"},{"location":"mds/tofu-quick-reference-guide/#common-operations-reference","title":"Common Operations Reference","text":""},{"location":"mds/tofu-quick-reference-guide/#1-initialize-engine","title":"1. Initialize Engine","text":"<pre><code>// Create reactor (engine implementation)\nvar rtr: *Reactor = try Reactor.Create(gpa, DefaultOptions);\ndefer rtr.*.Destroy();\n\n// Get Ampe interface\nconst ampe: Ampe = try rtr.*.ampe();\n\n// Create channel group\nconst chnls: ChannelGroup = try ampe.create();\ndefer tofu.DestroyChannels(ampe, chnls);\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#2-get-and-release-messages","title":"2. Get and Release Messages","text":"<pre><code>// Get message from pool\nvar msg: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;msg);  // Always use defer\n\n// Configure message\nmsg.?.*.bhdr.proto.mtype = .hello;\nmsg.?.*.bhdr.proto.role = .request;\nmsg.?.*.bhdr.channel_number = channelNum;\n\n// Send (msg becomes null after this)\n_ = try chnls.enqueueToPeer(&amp;msg);\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#3-start-tcp-server","title":"3. Start TCP Server","text":"<pre><code>const port: u16 = try tofu.FindFreeTcpPort();\n\nvar cfg: Configurator = .{\n    .tcp_server = TCPServerConfigurator.init(\"0.0.0.0\", port)\n};\n\nvar welcomeMsg: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;welcomeMsg);\n\ntry cfg.prepareRequest(welcomeMsg.?);\n\nconst bhdr: BinaryHeader = try chnls.enqueueToPeer(&amp;welcomeMsg);\n\nvar response: ?*Message = try chnls.waitReceive(tofu.waitReceive_INFINITE_TIMEOUT);\ndefer ampe.put(&amp;response);\n\n// Check response.?.*.bhdr.status == 0 for success\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#4-connect-tcp-client","title":"4. Connect TCP Client","text":"<pre><code>var cfg: Configurator = .{\n    .tcp_client = TCPClientConfigurator.init(\"127.0.0.1\", port)\n};\n\nvar helloMsg: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;helloMsg);\n\ntry cfg.prepareRequest(helloMsg.?);\n\nconst bhdr: BinaryHeader = try chnls.enqueueToPeer(&amp;helloMsg);\n\nvar response: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;response);\n\n// Check response for connection status\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#5-send-request","title":"5. Send Request","text":"<pre><code>var request: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;request);\n\nrequest.?.*.bhdr.proto.mtype = .regular;\nrequest.?.*.bhdr.proto.role = .request;\nrequest.?.*.bhdr.channel_number = channelNum;\n\n// Optional: Add text headers\ntry request.?.*.thdrs.add(\"MyHeader\", \"value\");\n\n// Optional: Add body\ntry request.?.*.body.append(data);\n\nconst sentBhdr: BinaryHeader = try chnls.enqueueToPeer(&amp;request);\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#6-send-response","title":"6. Send Response","text":"<pre><code>// Reuse received message\nreceivedMsg.?.*.bhdr.proto.role = .response;\nreceivedMsg.?.*.bhdr.proto.origin = .application;\n\n// Optionally modify body or headers\n\n_ = try chnls.enqueueToPeer(&amp;receivedMsg);\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#7-send-signal","title":"7. Send Signal","text":"<pre><code>var signal: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;signal);\n\nsignal.?.*.bhdr.proto.mtype = .regular;\nsignal.?.*.bhdr.proto.role = .signal;\nsignal.?.*.bhdr.channel_number = channelNum;\nsignal.?.*.bhdr.message_id = correlationId;\n\n_ = try chnls.enqueueToPeer(&amp;signal);\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#8-receive-messages","title":"8. Receive Messages","text":"<pre><code>var msg: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;msg);\n\nif (msg == null) {\n    // Timeout occurred\n    return;\n}\n\n// Check status\nconst st: u8 = msg.?.*.bhdr.status;\nif (st != 0) {\n    // Handle error (see error handling section)\n}\n\n// Process message based on type and role\nswitch (msg.?.*.bhdr.proto.mtype) {\n    .hello =&gt; {}, // Handle hello\n    .bye =&gt; {},   // Handle bye\n    .regular =&gt; {}, // Handle application message\n    else =&gt; {},\n}\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#9-close-connection-graceful","title":"9. Close Connection (Graceful)","text":"<pre><code>var byeRequest: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;byeRequest);\n\nbyeRequest.?.*.bhdr.proto.mtype = .bye;\nbyeRequest.?.*.bhdr.proto.role = .request;\nbyeRequest.?.*.bhdr.channel_number = channelNum;\n\n_ = try chnls.enqueueToPeer(&amp;byeRequest);\n\n// Wait for ByeResponse\nvar byeResponse: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;byeResponse);\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#10-close-connection-force","title":"10. Close Connection (Force)","text":"<pre><code>var byeSignal: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;byeSignal);\n\nbyeSignal.?.*.bhdr.proto.mtype = .bye;\nbyeSignal.?.*.bhdr.proto.role = .signal;\nbyeSignal.?.*.bhdr.proto.oob = .on;  // High priority\nbyeSignal.?.*.bhdr.channel_number = channelNum;\n\n_ = try chnls.enqueueToPeer(&amp;byeSignal);\n\n// Wait for channel_closed status\nvar closeMsg: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;closeMsg);\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#error-handling-reference","title":"Error Handling Reference","text":""},{"location":"mds/tofu-quick-reference-guide/#check-message-status","title":"Check Message Status","text":"<pre><code>var msg: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;msg);\n\nconst st: u8 = msg.?.*.bhdr.status;\nconst ampeSt: AmpeStatus = status.raw_to_status(st);\n\n// Check who created this status\nif (msg.?.*.bhdr.proto.origin == .engine) {\n    // Engine status\n    switch (ampeSt) {\n        .success =&gt; {},\n        .pool_empty =&gt; try handlePoolEmpty(),\n        .connect_failed =&gt; return error.ConnectFailed,\n        .channel_closed =&gt; return error.ChannelClosed,\n        else =&gt; return status.status_to_error(ampeSt),\n    }\n} else {\n    // Application status - your custom logic\n    if (st != 0) {\n        // Handle your error\n    }\n}\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#common-status-values","title":"Common Status Values","text":"Status Meaning Action <code>.success</code> Operation succeeded Continue <code>.pool_empty</code> Message pool is empty Add messages to pool <code>.connect_failed</code> Connection failed Retry or abort <code>.channel_closed</code> Channel closed Clean up <code>.invalid_address</code> Bad IP/port/path Fix configuration <code>.uds_path_not_found</code> UDS file not found Check path or retry <code>.receiver_update</code> Wake signal from updateReceiver Handle notification"},{"location":"mds/tofu-quick-reference-guide/#handle-pool-empty","title":"Handle Pool Empty","text":"<pre><code>// Method 1: Add messages to pool\nif (ampeSt == .pool_empty) {\n    const allocator: Allocator = ampe.getAllocator();\n    for (0..3) |_| {\n        var newMsg: ?*Message = try Message.create(allocator);\n        ampe.put(&amp;newMsg);\n    }\n    continue;  // Retry\n}\n\n// Method 2: Use poolOnly strategy\nvar msg: ?*Message = try ampe.get(.poolOnly);\nif (msg == null) {\n    // Pool empty - handle it\n    std.Thread.sleep(100 * std.time.ns_per_ms);\n    continue;\n}\ndefer ampe.put(&amp;msg);\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#threading-reference","title":"Threading Reference","text":""},{"location":"mds/tofu-quick-reference-guide/#thread-safe-operations","title":"Thread-Safe Operations","text":"<p>These can be called from multiple threads: <pre><code>ampe.get()              // Get message from pool\nampe.put()              // Return message to pool\nampe.create()           // Create channel group\nampe.destroy()          // Destroy channel group\nchnls.enqueueToPeer()   // Send message\nchnls.updateReceiver()  // Wake or notify receiver\n</code></pre></p>"},{"location":"mds/tofu-quick-reference-guide/#single-thread-operations","title":"Single-Thread Operations","text":"<p>These can be called from ONE thread only per ChannelGroup: <pre><code>chnls.waitReceive()     // Wait for message\n</code></pre></p>"},{"location":"mds/tofu-quick-reference-guide/#wake-receiver-from-another-thread","title":"Wake Receiver from Another Thread","text":"<pre><code>// Thread A: Waiting\nwhile (true) {\n    var msg: ?*Message = try chnls.waitReceive(timeout);\n    defer ampe.put(&amp;msg);\n\n    if (status.raw_to_status(msg.?.*.bhdr.status) == .receiver_update) {\n        break;  // Woken up\n    }\n}\n\n// Thread B: Wake Thread A\nvar nullMsg: ?*Message = null;\ntry chnls.updateReceiver(&amp;nullMsg);\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#configuration-quick-reference","title":"Configuration Quick Reference","text":""},{"location":"mds/tofu-quick-reference-guide/#tcp-server","title":"TCP Server","text":"<p><pre><code>.tcp_server = TCPServerConfigurator.init(\"0.0.0.0\", port)\n</code></pre> - <code>\"0.0.0.0\"</code> = listen on all interfaces - <code>\"127.0.0.1\"</code> = listen on localhost only - Specific IP = listen on that interface only</p>"},{"location":"mds/tofu-quick-reference-guide/#tcp-client","title":"TCP Client","text":"<p><pre><code>.tcp_client = TCPClientConfigurator.init(\"127.0.0.1\", port)\n</code></pre> - Use server IP address - Use server port number</p>"},{"location":"mds/tofu-quick-reference-guide/#uds-server","title":"UDS Server","text":"<p><pre><code>.uds_server = UDSServerConfigurator.init(\"/tmp/tofu.sock\")\n</code></pre> - Use file path - Path must not exist (will be created)</p>"},{"location":"mds/tofu-quick-reference-guide/#uds-client","title":"UDS Client","text":"<p><pre><code>.uds_client = UDSClientConfigurator.init(\"/tmp/tofu.sock\")\n</code></pre> - Use same path as server - Path must exist</p>"},{"location":"mds/tofu-quick-reference-guide/#message-structure-quick-reference","title":"Message Structure Quick Reference","text":""},{"location":"mds/tofu-quick-reference-guide/#binaryheader-fields","title":"BinaryHeader Fields","text":"<pre><code>.channel_number: u16   // Which connection\n.proto.mtype           // .welcome, .hello, .bye, .regular\n.proto.role            // .request, .response, .signal\n.proto.origin          // .application, .engine\n.proto.more            // .last, .expected (for multi-message)\n.proto.oob             // .off, .on (priority)\n.status: u8            // 0 = success, non-zero = error\n.message_id: u64       // Correlation ID\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#message-types","title":"Message Types","text":"Type Channel Used For <code>.welcome</code> 0 Server starts listening <code>.hello</code> 0 Client connects <code>.bye</code> Non-zero Close connection <code>.regular</code> Non-zero Application messages"},{"location":"mds/tofu-quick-reference-guide/#message-roles","title":"Message Roles","text":"Role Meaning Message ID <code>.request</code> Expects response Auto-generated or custom <code>.response</code> Replies to request Same as request <code>.signal</code> One-way Auto-generated or custom"},{"location":"mds/tofu-quick-reference-guide/#common-patterns-quick-reference","title":"Common Patterns Quick Reference","text":""},{"location":"mds/tofu-quick-reference-guide/#request-response-pattern","title":"Request-Response Pattern","text":"<pre><code>// Send request, save BinaryHeader\nconst sentBh: BinaryHeader = try chnls.enqueueToPeer(&amp;request);\n\n// Receive response, check message_id\nvar response: ?*Message = try chnls.waitReceive(timeout);\nassert(response.?.*.bhdr.message_id == sentBh.message_id);\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#multi-request-pattern","title":"Multi-Request Pattern","text":"<pre><code>const jobId: u64 = 12345;\n\n// Send multiple requests with same message_id\nfor (chunks) |chunk, i| {\n    msg.?.*.bhdr.message_id = jobId;\n    msg.?.*.bhdr.proto.more = if (i == chunks.len - 1) .last else .expected;\n    // Send chunk\n}\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#progress-signal-pattern","title":"Progress Signal Pattern","text":"<pre><code>// Send progress updates with same message_id as job\nprogress.?.*.bhdr.proto.role = .signal;\nprogress.?.*.bhdr.message_id = jobId;\ntry progress.?.*.thdrs.add(\"Progress\", \"[5:10]\");\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#pool-configuration-reference","title":"Pool Configuration Reference","text":"<pre><code>pub const Options = struct {\n    initialPoolMsgs: ?u16 = null,  // Created at start\n    maxPoolMsgs: ?u16 = null,      // Maximum size\n};\n\nconst DefaultOptions: Options = .{\n    .initialPoolMsgs = 16,\n    .maxPoolMsgs = 64,\n};\n</code></pre> <p>Tuning Guide: - See frequent <code>pool_empty</code> \u2192 increase <code>maxPoolMsgs</code> - High memory usage \u2192 decrease <code>maxPoolMsgs</code> - Set <code>initialPoolMsgs</code> = expected concurrent messages</p>"},{"location":"mds/tofu-quick-reference-guide/#timeout-constants","title":"Timeout Constants","text":"<pre><code>tofu.waitReceive_INFINITE_TIMEOUT  // Wait forever\ntofu.waitReceive_SEC_TIMEOUT       // 1 second\n</code></pre> <p>Custom timeout: <pre><code>const timeout: u64 = 5 * std.time.ns_per_s;  // 5 seconds\n</code></pre></p>"},{"location":"mds/tofu-quick-reference-guide/#allocation-strategies","title":"Allocation Strategies","text":"<pre><code>.poolOnly   // Return null if pool empty\n.always     // Create new if pool empty\n</code></pre> <p>When to use: - <code>.poolOnly</code> - Performance critical, handle pool_empty yourself - <code>.always</code> - Simpler code, pool exhaustion rare</p>"},{"location":"mds/tofu-quick-reference-guide/#text-headers-reference","title":"Text Headers Reference","text":""},{"location":"mds/tofu-quick-reference-guide/#add-header","title":"Add Header","text":"<pre><code>try msg.?.*.thdrs.add(\"Name\", \"Value\");\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#read-headers","title":"Read Headers","text":"<pre><code>var it: TextHeaderIterator = TextHeaderIterator.init(msg.?.*.thdrs.slice());\nwhile (it.next()) |header| {\n    // header.name\n    // header.value\n}\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#debugging-tips","title":"Debugging Tips","text":""},{"location":"mds/tofu-quick-reference-guide/#dump-message-metadata","title":"Dump Message Metadata","text":"<pre><code>msg.?.*.bhdr.dumpMeta(\"received message\");\n</code></pre> <p>Output example: <pre><code>received message: ch=123 mtype=regular role=request origin=application status=0 mid=456\n</code></pre></p>"},{"location":"mds/tofu-quick-reference-guide/#check-channel-number","title":"Check Channel Number","text":"<pre><code>log.debug(\"Channel: {d}\", .{msg.?.*.bhdr.channel_number});\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#check-message-id","title":"Check Message ID","text":"<pre><code>log.debug(\"Message ID: {d}\", .{msg.?.*.bhdr.message_id});\n</code></pre>"},{"location":"mds/tofu-quick-reference-guide/#common-mistakes","title":"Common Mistakes","text":""},{"location":"mds/tofu-quick-reference-guide/#using-message-after-send","title":"\u274c Using Message After Send","text":"<pre><code>_ = try chnls.enqueueToPeer(&amp;msg);\nmsg.?.*.bhdr.status = 0;  // WRONG! msg is null now\n</code></pre> <p>\u2705 Correct: <pre><code>const bhdr: BinaryHeader = try chnls.enqueueToPeer(&amp;msg);\n// msg is null, but you saved bhdr\n</code></pre></p>"},{"location":"mds/tofu-quick-reference-guide/#forgetting-defer","title":"\u274c Forgetting defer","text":"<pre><code>var msg: ?*Message = try ampe.get(.always);\n// Forgot defer - message leaks if error occurs\n</code></pre> <p>\u2705 Correct: <pre><code>var msg: ?*Message = try ampe.get(.always);\ndefer ampe.put(&amp;msg);  // Always runs\n</code></pre></p>"},{"location":"mds/tofu-quick-reference-guide/#multiple-threads-one-waitreceive","title":"\u274c Multiple Threads, One waitReceive","text":"<pre><code>// Thread 1\nvar msg1: ?*Message = try chnls.waitReceive(timeout);  // WRONG!\n\n// Thread 2\nvar msg2: ?*Message = try chnls.waitReceive(timeout);  // WRONG!\n</code></pre> <p>\u2705 Correct: <pre><code>// One thread per ChannelGroup for waitReceive\n// Or create separate ChannelGroup per thread\n</code></pre></p>"},{"location":"mds/tofu-quick-reference-guide/#ignoring-status","title":"\u274c Ignoring Status","text":"<pre><code>var msg: ?*Message = try chnls.waitReceive(timeout);\n// Didn't check msg.?.*.bhdr.status\n</code></pre> <p>\u2705 Correct: <pre><code>var msg: ?*Message = try chnls.waitReceive(timeout);\ndefer ampe.put(&amp;msg);\n\nconst st: u8 = msg.?.*.bhdr.status;\nif (st != 0) {\n    // Handle error\n}\n</code></pre></p>"},{"location":"mds/tofu-quick-reference-guide/#file-locations","title":"File Locations","text":""},{"location":"mds/tofu-quick-reference-guide/#recipe-files-examples","title":"Recipe Files (Examples)","text":"<ul> <li><code>recipes/cookbook.zig</code> - Basic patterns</li> <li><code>recipes/services.zig</code> - Service patterns (EchoService, EchoClient)</li> <li><code>recipes/MultiHomed.zig</code> - Multiple listeners</li> </ul>"},{"location":"mds/tofu-quick-reference-guide/#core-source-files","title":"Core Source Files","text":"<ul> <li><code>src/tofu.zig</code> - Public API exports</li> <li><code>src/ampe.zig</code> - Ampe interface</li> <li><code>src/message.zig</code> - Message structure</li> <li><code>src/status.zig</code> - Status/error handling</li> <li><code>src/configurator.zig</code> - TCP/UDS configuration</li> </ul>"},{"location":"mds/tofu-quick-reference-guide/#test-files","title":"Test Files","text":"<ul> <li><code>tests/reactor_tests.zig</code> - Engine tests</li> <li><code>tests/message_tests.zig</code> - Message tests</li> <li><code>tests/configurator_tests.zig</code> - Configuration tests</li> </ul>"},{"location":"mds/tofu-quick-reference-guide/#quick-start-checklist","title":"Quick Start Checklist","text":"<ol> <li>\u2705 Create Reactor (engine)</li> <li>\u2705 Get Ampe interface</li> <li>\u2705 Create ChannelGroup</li> <li>\u2705 Configure server (Welcome) or client (Hello)</li> <li>\u2705 Start message loop (waitReceive)</li> <li>\u2705 Handle messages based on type/role</li> <li>\u2705 Clean up (Destroy ChannelGroup, Destroy Reactor)</li> </ol>"},{"location":"mds/tofu-quick-reference-guide/#when-things-go-wrong","title":"When Things Go Wrong","text":""},{"location":"mds/tofu-quick-reference-guide/#connection-fails","title":"Connection Fails","text":"<ul> <li>Check IP address and port</li> <li>Ensure server is running first</li> <li>Check firewall</li> <li>Check <code>status == .connect_failed</code></li> </ul>"},{"location":"mds/tofu-quick-reference-guide/#pool-empty","title":"Pool Empty","text":"<ul> <li>Increase <code>maxPoolMsgs</code></li> <li>Add messages to pool dynamically</li> <li>Check for message leaks (missing put())</li> </ul>"},{"location":"mds/tofu-quick-reference-guide/#channel-closed-unexpectedly","title":"Channel Closed Unexpectedly","text":"<ul> <li>Check peer disconnected</li> <li>Check network errors</li> <li>Handle <code>.channel_closed</code> status</li> </ul>"},{"location":"mds/tofu-quick-reference-guide/#waitreceive-blocks-forever","title":"waitReceive Blocks Forever","text":"<ul> <li>Use timeout instead of INFINITE_TIMEOUT</li> <li>Check peer is sending messages</li> <li>Use updateReceiver to wake</li> </ul>"}]}